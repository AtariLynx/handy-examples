Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page    1
                                                        18:23:55  

    1                   ; Example program skeleton - multiplayer
    2                   ; 12/8/89 M. Peter Engelbrite
    3                   	.list off
   44                   	.list on
   45                   
   46                   
   47                   ; zero page variables for sys
   48                   
   49                   	BEGIN_ZPAGE
    1      FFFE       + TEMPORG	  .= *
    2 FFFE:           + 	  .ORG NEXTZPG
    3                 + 
   50                   ; variables to clear upon entry to a new world
   51 0006:             random.ndx		.ds 2	;for random number generator
   52 0008:             tmp			.ds 4	;temporary (used by system or user)
   53 000C:             count			.ds 1	;incremented once each game frame
   54 000D:             vscroll			.ds 2	;this is the screens "window" on the w
   55 000F:             hscroll			.ds 2	;upper left corner of screen
   56                   
   57                   ;used by system
   58 0011:             new.colors		.ds 1	;used in palette control
   59 0012:             fading			.ds 1	;used in palette control
   60 0013:             slow.fade		.ds 1	;set to $ff to cause colors to fade s
   61                   
   62                   ; game score
   63 0014:             score			.ds SCORE_SIZE	;score (in BCD)
   64                   
   65                   
   66                   ; control.level
   67                   ; joystick / fire control (1 = pressed, 0 = not presse
   68                   ; bits 4-7 = $f0 means: pause button pressed
   69                   
   70                   ; control.edge
   71                   ; similar to control.level, but it indicates the leadi
   72                   ; this state exists for one game frame only!
   73                   ; 1 = just pressed, 0 = not
   74                   
   75                   
   76      TRUE         	#ifdef MULTIPLAYER
   77 0019:             number.of.players	.ds 1	; total number of players logg
   78 001A:             my.player		.ds 1	; player number for this unit
   79 001B:             control.level		.ds MAX_PLAYERS
   80 001F:             control.edge		.ds MAX_PLAYERS
   81 0023:             level			.ds MAX_PLAYERS
   82 0027:             edge			.ds MAX_PLAYERS
   83 002B:             pause.timer		.ds MAX_PLAYERS
   84 002F:             opt2.timer		.ds MAX_PLAYERS
   85                   
   86                   	#else
   93                   	#endif
   94 0033:             pause.flag		.ds 1
   95                   
   96      TRUE         	#ifdef MUSIC_TOGGLE
   97 0034:             quiet			.ds 1
   98                   	#endif
   99                   
  100                   	END_ZPAGE
    1      0035       + NEXTZPG	  .= *
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page    2
                        sys.src                         18:23:55  

    2      FALSE        	  #IF NEXTZPG > $0100
    4                 + 	  #ENDIF
    5 0035:           + 	  .ORG TEMPORG
    6                 + 
  101                   
  102 FFFE:             	.or $400
  103                   ; ---- COLD START ENTRY ----
  104                   ;this is entered on powerup
  105 0400:             cold.start
  106 0400:78           	sei
  107 0401:D8           	cld
  108 0402:A2 FF        	ldx #$ff
  109 0404:9A           	txs
  110                   ; clear out all work variables
  111 0405:A9 **        	lda #>most.variables
  112 0407:85 01        	sta 1
  113 0409:64 00        	stz 0
  114 040B:A0 **        	ldy #<most.variables
  115 040D:             .11
  116 040D:A9 00        	lda #0
  117 040F:             .10
  118 040F:91 00        	sta (0),y
  119 0411:C8           	iny
  120 0412:D0 FB        	bne .10
  121 0414:E6 01        	inc 1
  122 0416:A5 01        	lda 1
  123 0418:C9 FC        	cmp #$fc
  124 041A:D0 F1        	bne .11
  125                   
  126 041C:A2 00        	ldx #0
  127 041E:             .00
  128 041E:74 00        	stz 0,x
  129 0420:9E 00 01     	stz $100,x
  130 0423:9E 00 02     	stz $200,x
  131 0426:9E 00 03     	stz $300,x
  132 0429:CA           	dex
  133 042A:D0 F2        	bne .00
  134                   
  135                   	INITSYS
    1 042C:A9 0D      + 	LDA #DISP_COLOR+DISP_FOURBIT+DMA_ENABLE
    2 042E:8D ** **   + 	STA DISPCTL_RAM
    3 0431:A9 08      + 	LDA #LEFTHAND		
    4 0433:8D ** **   + 	STA SPRSYS_RAM
    5 0436:8D 92 FC   + 	STA SPRSYS
    6 0439:A9 08      + 	LDA #VECTOR_SPACE	
    7 043B:8D F9 FF   + 	STA MAPCTL
    8      FALSE         #IFDEF RAMCART_USER
   10                 +  #ELSE
   11 043E:A9 0A      + 	LDA #CART_ADDR_DATA+RESTLESS
   12                 +  #ENDIF
   13 0440:8D ** **   + 	STA IODAT_RAM
   14 0443:8D 8B FD   + 	STA IODAT
   15 0446:8D ** **   + 	STA IODIR_RAM
   16 0449:8D 8A FD   + 	STA IODIR
   17 044C:A9 04      + 	LDA #TXOPEN	
   18 044E:8D 8C FD   + 	STA SERCTL	
   19      FALSE        	  #IFDEF AUTO_TIMEOUT_USER
   22                 + 	  #ENDIF
   23                 + 
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page    3
                        sys.src                         18:23:55  

  136                   	INITINT	MyIntTable,MyReturn
    1      ****       + sysIntTable	.EQ MyIntTable
    2 0451:A9 **      + 		LDA #<UserIntHandler
    3 0453:8D FE FF   + 		STA CPU_IRQ
    4 0456:A9 **      + 		LDA #>UserIntHandler
    5 0458:8D FF FF   + 		STA CPU_IRQ+1
    6 045B:A2 0F      + 		LDX #8*2-1
    7      045D       + INITINT.0006	.= *
    8 045D:A9 **      + 		  LDA #>IntReturn
    9 045F:9D ** **   + 		  STA MyIntTable,X
   10 0462:CA         + 		  DEX
   11 0463:A9 **      + 		  LDA #<IntReturn
   12 0465:9D ** **   + 		  STA MyIntTable,X
   13 0468:CA         + 		  DEX
   14 0469:10 F2      + 		 BPL INITINT.0006
   15      FALSE        	  #IFDEF BRK_USER
   20                 + 	  #ENDIF 
   21      FALSE        	  #IFDEF SERIALPORT_USER
   26                 + 	  #ENDIF
   27                 + 
  137 046B:9C ** **     	stz DisplayFrameCount
  138                   	INITHMUSIC
    1 046E:20 ** **   + 	JSR InitHMusic
    2                 + 
  139                   	SETCOLL Buffer1,2	; no collision (set to sceen anyway
    1 0471:A9 **      + 		LDA	#<Buffer1
    2 0473:8D 0A FC   + 		STA	COLLBASL
    3 0476:A9 **      + 		LDA	#>Buffer1
    4 0478:8D 0B FC   + 		STA	COLLBASH
    5 047B:A9 02      + 		LDA	#<2
    6 047D:8D 24 FC   + 		STA	COLLOFFL
    7 0480:A9 00      + 		LDA	#>2
    8 0482:8D 25 FC   + 		STA	COLLOFFH
    9                 + 
  140                   	SETDISP_60
    1                   		SETDISP	$9E,$98,$68,$9F,$29
    1 0485:A9 9E      + 		LDA	#$9E
    2 0487:8D 00 FD   + 		STA	HCOUNT+TIM_BACKUP
    3      FALSE        	#IFDEF EOL_USER
    5                 + 	#ELSE
    6 048A:A9 18      + 		lda #$98&%01111111
    7                 + 	#ENDIF
    8 048C:8D 01 FD   + 		STA	HCOUNT+TIM_CONTROLA
    9 048F:A9 68      + 		LDA	#$68
   10 0491:8D 08 FD   + 		STA	VCOUNT+TIM_BACKUP
   11 0494:A9 9F      + 		lda #$9F|%10000000
   12 0496:8D 09 FD   + 		STA	VCOUNT+TIM_CONTROLA
   13 0499:A9 29      + 		LDA	#$29
   14 049B:8D 93 FD   + 		STA	PBKUP
   15      FALSE        	#IFNDEF	EOF_USER
   17                 + 	#ENDIF
   18                 + 
    2                 + 
  141                   	INITEOF
    1 049E:20 ** **   + 		JSR	InitEOF
    2                 + 
  142                   	INITSUZY
    1 04A1:A9 F3      + 		LDA	#$F3
    2 04A3:8D 83 FC   + 		STA	SPRINIT
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page    4
                        sys.src                         18:23:55  

    3 04A6:A9 7F      + 		LDA	#$7F
    4 04A8:8D 28 FC   + 		STA	HSIZOFFL
    5 04AB:8D 2A FC   + 		STA	VSIZOFFL
    6 04AE:A9 01      + 		LDA	#$01
    7 04B0:8D 90 FC   + 		STA	SUZYBUSEN
    8 04B3:9C 90 FD   + 		STZ	SDONEACK
    9                 + 
  143                   	SETDBUF	Buffer1,Buffer2
    1 04B6:A9 **      + 		LDA	#<Buffer1
    2 04B8:8D ** **   + 		STA	RenderBuffer
    3 04BB:A9 **      + 		LDA	#>Buffer1
    4 04BD:8D ** **   + 		STA	RenderBuffer+1
    5 04C0:A9 **      + 		LDA	#<Buffer2
    6 04C2:8D ** **   + 		STA	DisplayBuffer
    7 04C5:A9 **      + 		LDA	#>Buffer2
    8 04C7:8D ** **   + 		STA	DisplayBuffer+1
    9 04CA:9C ** **   + 		STZ	DisplayFlags
   10                 + 
  144 04CD:58           	CLI
  145                   
  146 04CE:20 ** **     	jsr clear.screen	; prevent garbage on screen while se
  147 04D1:20 ** **     	jsr black.screen
  148                   ;	DISPLAY_ON
  149                   
  150                   ; clear stretch and tilt
  151 04D4:A2 03        	ldx #3
  152 04D6:             .02
  153 04D6:9E 1C FC     	stz $fc1c,x
  154 04D9:CA           	dex
  155 04DA:10 FA        	bpl .02
  156                   
  157 04DC:20 ** **     	jsr clear.screen
  158      TRUE         	#ifdef MULTIPLAYER
  159 04DF:20 ** **     	jsr init.comlynx
  160                   
  161                   ;wait for all fingers to lift from all buttons
  162 04E2:             .33
  163 04E2:20 ** **     	jsr delay
  164 04E5:A2 00        	ldx #0
  165 04E7:             .34
  166 04E7:DA           	phx
  167 04E8:20 ** **     	jsr get.controls
  168 04EB:FA           	plx
  169 04EC:B5 1B        	lda control.level,x
  170 04EE:D0 F2        	bne .33
  171 04F0:E8           	inx
  172 04F1:E4 19        	cpx number.of.players
  173 04F3:D0 F2        	bne .34
  174                   	#else
  181                   	#endif
  182                   
  183                   
  184                   
  185                   
  186 04F5:4C ** **     	jmp game.start		;enter actual game
  187                   
  188                   
  189                   ; SYSTEM FUNCTIONS 
  190                   
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page    5
                        sys.src                         18:23:55  

  191                   ; ---------------------- game.frame ------------------
  192                   ; call this after all game logic is done and all sprit
  193                   ; this does the comlynx overhead, does the screen buff
  194                   ; does the pause/flip/restart/music on-off overhead, a
  195                   ; it will return with a new, blank screen (cleared to 
  196 04F8:             game.frame
  197 04F8:E6 0C        	inc count	;this is used by the system and the game (i
  198 04FA:20 ** **     	jsr show.score		;display the score
  199 04FD:20 ** **     	jsr do.screen		;display the screen
  200 0500:20 ** **     	jsr fade		;color scene fade operation
  201 0503:20 ** **     	jsr check.controls	;process pause/options
  202      TRUE         	#ifdef SCREEN_CLEAR
  203 0506:20 ** **     	jsr clear.screen	;clear screen for the next go-around
  204                   	#else
  215                   	#endif
  216 0509:60           	rts
  217                   
  218                   
  219                   
  220                   ; ---------------- do.sprite -------------
  221                   ; display a sprite list
  222                   ; call with x,y pointing to start of sprite list (high
  223 050A:             do.sprite
  224 050A:86 09        	stx tmp+1
  225 050C:84 08        	sty tmp
  226                   	RESPRITE tmp,1
    1      TRUE       + 		#IF	1 <> 0
    2 050E:A5 08      + 		  LDA	tmp
    3 0510:8D 10 FC   + 		  STA	SCBNEXTL
    4 0513:A5 09      + 		  LDA	tmp+1
    5 0515:8D 11 FC   + 		  STA	SCBNEXTH
    6                   		#ELSE
   11                 + 		#ENDIF
   12 0518:9C 90 FD   + 		STZ	SDONEACK
   13 051B:A9 01      + 		LDA	#$01
   14 051D:8D 91 FC   + 		STA	SPRGO
   15                   		WAITSUZY
    1      0520       + WAITSUZY.000F1	.= *
    2 0520:A9 01      + 		lda #SUZY_SPACE
    3 0522:0C F9 FF   + 		tsb MAPCTL		
    4 0525:9C 91 FD   + 		STZ	CPUSLEEP
    5 0528:1C F9 FF   + 		trb MAPCTL		
    6 052B:AD 92 FC   + 		LDA	SPRSYS		
    7 052E:4A         + 		LSR	A		
    8 052F:B0 EF      + 		BCS	WAITSUZY.000F1		
    9 0531:9C 90 FD   + 		STZ	SDONEACK
   10                 + 
   16                 + 
  227 0534:60           	rts
  228                   
  229                   ; --------------- clear.screen -------------
  230                   ; clears screen to all pixel #0
  231 0535:             clear.screen
  232 0535:9C 04 FC     	stz HOFFL
  233 0538:9C 05 FC     	stz HOFFH
  234 053B:9C 06 FC     	stz VOFFL
  235 053E:9C 07 FC     	stz VOFFH
  236                   	SPRITES black,0
    1      FALSE        		#IF	0 <> 0
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page    6
                        sys.src                         18:23:55  

    6                 + 		#ELSE
    7 0541:A9 **      + 		  LDA	#<black
    8 0543:8D 10 FC   + 		  STA	SCBNEXTL
    9 0546:A9 **      + 		  LDA	#>black
   10 0548:8D 11 FC   + 		  STA	SCBNEXTH
   11                 + 		#ENDIF
   12 054B:AD ** **   + 		LDA	RenderBuffer
   13 054E:8D 08 FC   + 		STA	VIDBASL
   14 0551:AD ** **   + 		LDA	RenderBuffer+1
   15 0554:8D 09 FC   + 		STA	VIDBASH
   16 0557:9C 90 FD   + 		STZ	SDONEACK
   17 055A:A9 01      + 		LDA	#$01
   18 055C:8D 91 FC   + 		STA	SPRGO
   19                   		WAITSUZY
    1      055F       + WAITSUZY.00111	.= *
    2 055F:A9 01      + 		lda #SUZY_SPACE
    3 0561:0C F9 FF   + 		tsb MAPCTL		
    4 0564:9C 91 FD   + 		STZ	CPUSLEEP
    5 0567:1C F9 FF   + 		trb MAPCTL		
    6 056A:AD 92 FC   + 		LDA	SPRSYS		
    7 056D:4A         + 		LSR	A		
    8 056E:B0 EF      + 		BCS	WAITSUZY.00111		
    9 0570:9C 90 FD   + 		STZ	SDONEACK
   10                 + 
   20                 + 
  237 0573:A5 0F        	lda hscroll
  238 0575:A4 10        	ldy hscroll+1
  239                   	HOFF16
    1 0577:8D 04 FC   + 		STA	HOFFL
    2 057A:8C 05 FC   + 		STY	HOFFH
    3                 + 
  240 057D:A5 0D        	lda vscroll
  241 057F:A4 0E        	ldy vscroll+1
  242                   	VOFF16
    1 0581:8D 06 FC   + 		STA	VOFFL
    2 0584:8C 07 FC   + 		STY	VOFFH
    3                 + 
  243 0587:60           	rts
  244                   
  245                   ; ---- SCREEN DISPLAY ----
  246                   
  247 0588:             do.screen
  248                   	DBUF_DISPLAY
    1 0588:08         + 		PHP
    2 0589:78         + 		SEI
    3 058A:AD ** **   + 		LDA	RenderBuffer
    4 058D:AE ** **   + 		ldx	DisplayBuffer
    5 0590:8D ** **   + 		STA	DisplayBuffer
    6 0593:8E ** **   + 		stx	RenderBuffer
    7 0596:AD ** **   + 		LDA	RenderBuffer+1
    8 0599:AE ** **   + 		ldx	DisplayBuffer+1
    9 059C:8D ** **   + 		STA	DisplayBuffer+1
   10 059F:8E ** **   + 		stx	RenderBuffer+1
   11 05A2:28         + 		PLP
   12                 + 
  249 05A3:A2 04        	ldx #FRAME_RATE
  250 05A5:86 08        	stx tmp
  251 05A7:             wait.for.more.frames
  252                   	WAITEOF
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page    7
                        sys.src                         18:23:55  

    1 05A7:A9 **      + 		LDA	#DISPLAY_EOFFLAG
    2 05A9:1C ** **   + 		TRB	DisplayFlags
    3      05AC       + systemp		.=	*
    4 05AC:2C ** **   + 		BIT	DisplayFlags
    5 05AF:F0 FB      + 		BEQ	systemp
    6                 + 
  253 05B1:AD ** **     	lda DisplayFrameCount
  254 05B4:C5 08        	cmp tmp
  255 05B6:90 EF        	bcc wait.for.more.frames
  256 05B8:9C ** **     	stz DisplayFrameCount
  257 05BB:A5 11        	lda new.colors
  258 05BD:F0 **        	beq no.screen
  259                   	RGB16 old.colors.rgb
    1 05BF:A9 **      + 		LDA	#<old.colors.rgb
    2 05C1:85 00      + 		STA	sysptr
    3 05C3:A9 **      + 		LDA	#>old.colors.rgb
    4 05C5:85 01      + 		STA	sysptr+1
    5 05C7:A0 1F      + 		LDY	#31
    6 05C9:B1 00      + 		LDA	(sysptr),Y
    7 05CB:99 A0 FD   + 		STA	GREEN0,Y
    8 05CE:88         + 		DEY
    9 05CF:10 F8      + 		BPL	*-6
   10                 + 
  260 05D1:64 11        	stz new.colors
  261 05D3:             no.screen
  262                   
  263                   ; warning - this is used as a null interrupt
  264 05D3:             MyReturn
  265 05D3:60           	rts
  266                   
  267                   ;one frame delay (for use in check.controls
  268 05D4:             delay
  269 05D4:A2 04        	ldx #FRAME_RATE
  270 05D6:86 08        	stx tmp
  271 05D8:             continue.delay
  272                   	WAITEOF
    1 05D8:A9 **      + 		LDA	#DISPLAY_EOFFLAG
    2 05DA:1C ** **   + 		TRB	DisplayFlags
    3      05DD       + systemp		.=	*
    4 05DD:2C ** **   + 		BIT	DisplayFlags
    5 05E0:F0 FB      + 		BEQ	systemp
    6                 + 
  273 05E2:AD ** **     	lda DisplayFrameCount
  274 05E5:C5 08        	cmp tmp
  275 05E7:90 EF        	bcc continue.delay
  276 05E9:9C ** **     	stz DisplayFrameCount
  277 05EC:60           	rts
  278                   
  279                   
  280                   
  281      TRUE         	#ifdef MULTIPLAYER
  282                   
  283                   ;----------------- check.controls --------------
  284                   
  285                   ; control button processing: pause/restart/flip
  286                   
  287 05ED:             check.controls.pause.loop
  288 05ED:20 D4 05     	jsr delay
  289                   
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page    8
                        sys.src                         18:23:55  

  290                   ;entry point
  291 05F0:             check.controls
  292 05F0:             check.controls.players
  293 05F0:20 ** **     	jsr get.controls	;get joystic/control info for next f
  294 05F3:A2 00        	ldx #0
  295 05F5:             check.controls.player.loop
  296                   ;set the timers
  297 05F5:B5 1F        	lda control.edge,x
  298 05F7:29 F0        	and #$f0
  299 05F9:C9 F0        	cmp #$f0
  300 05FB:D0 **        	bne .00
  301 05FD:A9 03        	lda #DEBOUNCE
  302 05FF:95 2B        	sta pause.timer,x
  303 0601:             .00
  304 0601:B5 1F        	lda control.edge,x
  305 0603:29 04        	and #OPTION2_BUTTON
  306 0605:F0 **        	beq .01
  307 0607:A9 03        	lda #DEBOUNCE
  308 0609:95 2F        	sta opt2.timer,x
  309 060B:             .01
  310                   ;1st flip check
  311 060B:B5 1F        	lda control.edge,x
  312 060D:29 04        	and #OPTION2_BUTTON
  313 060F:F0 **        	beq .02
  314 0611:B5 1B        	lda control.level,x
  315 0613:29 F0        	and #$f0
  316 0615:C9 F0        	cmp #$f0
  317 0617:D0 **        	bne .02
  318 0619:DA           	phx
  319 061A:20 ** **     	jsr do.flip
  320 061D:FA           	plx
  321 061E:             .02
  322                   ;reset check
  323 061E:B5 1B        	lda control.level,x
  324 0620:29 F8        	and #OPTION1_BUTTON+$f0
  325 0622:C9 F8        	cmp #OPTION1_BUTTON+$f0
  326 0624:D0 **        	bne .03
  327 0626:4C ** **     	jmp do.reset
  328 0629:             .03
  329                   ;2nd flip check
  330 0629:B5 1B        	lda control.level,x
  331 062B:29 04        	and #OPTION2_BUTTON
  332 062D:F0 **        	beq .04
  333 062F:B5 1F        	lda control.edge,x
  334 0631:29 F0        	and #$f0
  335 0633:C9 F0        	cmp #$f0
  336 0635:D0 **        	bne .04
  337 0637:B5 1F        	lda control.edge,x	;this prevents double flip if in s
  338 0639:29 04        	and #OPTION2_BUTTON
  339 063B:D0 **        	bne .04
  340 063D:DA           	phx
  341 063E:20 ** **     	jsr do.flip
  342 0641:FA           	plx
  343 0642:             .04
  344                   ;check pause timeout
  345 0642:B5 2B        	lda pause.timer,x
  346 0644:F0 **        	beq .05
  347 0646:D6 2B        	dec pause.timer,x
  348 0648:D0 **        	bne .05
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page    9
                        sys.src                         18:23:55  

  349 064A:DA           	phx
  350 064B:20 ** **     	jsr toggle.pause
  351 064E:FA           	plx
  352 064F:             .05
  353                   ;check option2 timeout
  354 064F:B5 2F        	lda opt2.timer,x
  355 0651:F0 **        	beq .06
  356 0653:D6 2F        	dec opt2.timer,x
  357 0655:D0 **        	bne .06
  358      TRUE         	#ifdef MUSIC_TOGGLE
  359 0657:DA           	phx
  360 0658:20 ** **     	jsr toggle.music
  361 065B:FA           	plx
  362                   	#else
  366                   	#endif
  367 065C:             .06
  368 065C:E8           	inx
  369 065D:E4 19        	cpx number.of.players
  370 065F:D0 94        	bne check.controls.player.loop
  371 0661:A5 33        	lda pause.flag
  372 0663:D0 88        	bne check.controls.pause.loop
  373 0665:60           	rts
  374                   
  375      TRUE         	#ifdef MUSIC_TOGGLE
  376 0666:             toggle.music
  377 0666:E4 1A        	cpx my.player
  378 0668:D0 **        	bne .00
  379                   	MUTE
    1 066A:20 ** **   + 	JSR Mute
    2                 + 
  380 066D:AD ** **     	lda Mute_flag
  381 0670:85 34        	sta quiet
  382 0672:             .00
  383 0672:60           	rts
  384                   	#endif
  385                   
  386 0673:             do.flip
  387 0673:74 2B        	stz pause.timer,x
  388 0675:74 2F        	stz opt2.timer,x
  389 0677:E4 1A        	cpx my.player
  390 0679:D0 **        	bne .00
  391                   	FLIP
    1 067B:AD ** **   + 		LDA	DISPCTL_RAM
    2 067E:49 02      + 		EOR	#DISP_FLIP
    3 0680:8D ** **   + 		STA	DISPCTL_RAM
    4 0683:AD ** **   + 		LDA	SPRSYS_RAM
    5 0686:49 08      + 		EOR	#LEFTHAND
    6 0688:8D ** **   + 		STA	SPRSYS_RAM
    7 068B:8D 92 FC   + 		STA	SPRSYS
    8                 + 
  392 068E:             .00
  393 068E:60           	rts
  394                   
  395                   ;updates level, edge, control.level and control.edge
  396                   ;called once per frame, packs pause into joystick fiel
  397                   ;this packing is done for the sake of comlynx (one byt
  398                   ;this is called by the system, the game gets info from
  399                   ;control.edge
  400                   ;the game should never actually see the pause mode, so
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   10
                        sys.src                         18:23:55  

  401                   ;take it into account
  402 068F:             get.controls
  403                   	GETJOY			;get joystick info from hardware
    1 068F:AD B0 FC   + 	  LDA JOYSTICK
    2                 + 
  404 0692:85 08        	sta tmp
  405                   	GETSWITCH		;get pause button
    1 0694:AD B1 FC   + 	  LDA SWITCHES
    2                 + 
  406 0697:29 01        	and #PAUSE_SWITCH
  407 0699:F0 **        	beq .01
  408 069B:A5 08        	lda tmp			;all 1's in joystick means pause
  409 069D:09 F0        	ora #$f0
  410 069F:85 08        	sta tmp
  411 06A1:             .01
  412 06A1:A5 08        	lda tmp
  413 06A3:A6 1A        	ldx my.player
  414 06A5:9D ** **     	sta messages,x
  415                   
  416                   ; do the comlynx calls here: exchange control info wit
  417 06A8:20 ** **     	jsr wait.comlynx
  418                   
  419 06AB:A2 00        	ldx #0
  420 06AD:             another.player
  421 06AD:BD ** **     	lda messages,x			;get new joystick info
  422                   
  423                   ;massage for use by sys controls
  424 06B0:48           	pha
  425 06B1:29 F0        	and #$f0
  426 06B3:C9 F0        	cmp #$f0
  427 06B5:F0 **        	beq .10
  428 06B7:68           	pla
  429 06B8:29 0F        	and #$0f
  430 06BA:80 **        	bra .11
  431 06BC:             .10
  432 06BC:68           	pla
  433 06BD:             .11
  434 06BD:A8           	tay
  435 06BE:55 1B        	eor control.level,x	;check for any changes
  436 06C0:94 1B        	sty control.level,x	;store new joystick info
  437 06C2:35 1B        	and control.level,x	;mask for leading edge only
  438 06C4:95 1F        	sta control.edge,x	;store to edge buffer
  439                   
  440 06C6:BD ** **     	lda messages,x
  441                   ;massage for use by game
  442 06C9:48           	pha
  443 06CA:29 F0        	and #$f0
  444 06CC:C9 F0        	cmp #$f0
  445 06CE:D0 **        	bne .00
  446 06D0:68           	pla
  447 06D1:29 0F        	and #$0f
  448 06D3:80 **        	bra .01
  449 06D5:             .00
  450 06D5:68           	pla
  451 06D6:             .01
  452      FALSE        	#ifndef MUSIC_TOGGLE
  454                   	#endif
  455 06D6:A8           	tay
  456 06D7:55 23        	eor level,x	;check for any changes
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   11
                        sys.src                         18:23:55  

  457 06D9:94 23        	sty level,x	;store new joystick info
  458 06DB:35 23        	and level,x	;mask for leading edge only
  459 06DD:95 27        	sta edge,x	;store to edge buffer
  460 06DF:E8           	inx
  461 06E0:E4 19        	cpx number.of.players
  462 06E2:D0 C9        	bne another.player
  463 06E4:60           	rts
  464                   
  465                   
  466      TRUE         	#ifdef FAKE_COMLYNX
  467      001F         ORNERY	.eq $1f		;not ornery (no pauses, resets)
  468                   ;ORNERY	.eq $3f		;very ornery (resets, pauses, etc.)
  469 06E5:             wait.comlynx
  470 06E5:20 ** **     	jsr random
  471 06E8:C9 46        	cmp #70
  472 06EA:B0 **        	bcs nfc
  473 06EC:20 ** **     	jsr random
  474 06EF:29 1F        	and #ORNERY
  475 06F1:AA           	tax
  476 06F2:BD ** **     	lda fake.com.tab,x
  477 06F5:85 08        	sta tmp
  478 06F7:20 ** **     	jsr random
  479 06FA:29 03        	and #3
  480 06FC:C5 1A        	cmp my.player
  481 06FE:F0 **        	beq nfc
  482 0700:AA           	tax
  483 0701:A5 08        	lda tmp
  484 0703:9D ** **     	sta messages,x	
  485 0706:             nfc
  486 0706:60           	rts
  487                   
  488 0707:             fake.com.tab
  489 0707:10 20 40 80  	.by $10,$20,$40,$80,$50,$60,$90,$a0
  489      50 60 90 A0  
  489                   
  490 070F:10 20 40 80  	.by $10,$20,$40,$80,$50,$60,$90,$a0
  490      50 60 90 A0  
  490                   
  491 0717:10 20 40 80  	.by $10,$20,$40,$80,$50,$60,$90,$a0
  491      50 60 90 A0  
  491                   
  492 071F:00 00 00 00  	.by $00,$00,$00,$00,$00,$00,$00,$00
  492      00 00 00 00  
  492                   
  493 0727:00 00 00 00  	.by $00,$00,$00,$00,$00,$00,$00,$00
  493      00 00 00 00  
  493                   
  494 072F:00 00 00 00  	.by $00,$00,$00,$00,$00,$00,$00,$00
  494      00 00 00 00  
  494                   
  495 0737:00 00 00 00  	.by $00,$00,$00,$00,$01,$02,$03,$04
  495      01 02 03 04  
  495                   
  496 073F:08 04 04 0C  	.by $08,$04,$04,$0c,$f4,$f0,$f8,$fc
  496      F4 F0 F8 FC  
  496                   
  497                   
  498 0747:             init.comlynx
  499 0747:A9 04        	lda #MAX_PLAYERS
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   12
                        sys.src                         18:23:55  

  500 0749:85 19        	sta number.of.players
  501 074B:A9 02        	lda #2
  502 074D:85 1A        	sta my.player
  503 074F:60           	rts
  504                   
  505                   	#else
  510                   	#endif
  511                   
  512                   
  513                   
  514                   
  515                   
  516                   	#else ;of ifdef MULTIPLAYER
  670                   	#endif ;of else for ifdef MULTIPLAYER
  671                   
  672                   
  673                   
  674 0750:             toggle.pause
  675 0750:A5 33        	lda pause.flag
  676 0752:49 FF        	eor #$ff
  677 0754:85 33        	sta pause.flag
  678 0756:D0 **        	bne show.paused
  679                   
  680 0758:             clear.paused
  681      TRUE         	#ifdef MUSIC_TOGGLE
  682 0758:A5 34        	lda quiet
  683 075A:D0 **        	bne .00
  684 075C:AD ** **     	lda Mute_flag
  685 075F:F0 **        	beq .00
  686                   	MUTE
    1 0761:20 ** **   + 	JSR Mute
    2                 + 
  687 0764:             .00
  688                   	#else
  690                   	#endif
  691 0764:AD ** **     	lda pause.save.1
  692 0767:8D AC FD     	sta GREENC		;save old screen colors
  693 076A:AD ** **     	lda pause.save.2
  694 076D:8D BC FD     	sta BLUEREDC
  695 0770:AD ** **     	lda pause.save.3
  696 0773:8D B8 FD     	sta BLUERED8
  697 0776:AD ** **     	lda pause.save.4
  698 0779:8D A8 FD     	sta GREEN8
  699 077C:60           	rts
  700                   	
  701 077D:             show.paused
  702      TRUE         	#ifdef MUSIC_TOGGLE
  703 077D:AD ** **     	lda Mute_flag
  704 0780:D0 **        	bne .00
  705                   	MUTE
    1 0782:20 ** **   + 	JSR Mute
    2                 + 
  706 0785:             .00
  707                   	#else
  709                   	#endif
  710 0785:AD AC FD     	lda GREENC		;save old screen colors
  711 0788:8D ** **     	sta pause.save.1
  712 078B:AD BC FD     	lda BLUEREDC
  713 078E:8D ** **     	sta pause.save.2
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   13
                        sys.src                         18:23:55  

  714 0791:AD B8 FD     	lda BLUERED8
  715 0794:8D ** **     	sta pause.save.3
  716 0797:AD A8 FD     	lda GREEN8
  717 079A:8D ** **     	sta pause.save.4
  718 079D:A9 FF        	lda #$ff		;make message white on black
  719 079F:8D AC FD     	sta GREENC
  720 07A2:8D BC FD     	sta BLUEREDC
  721 07A5:9C A8 FD     	stz GREEN8
  722 07A8:9C B8 FD     	stz BLUERED8
  723                   ; reset screen offsets to center "Paused"
  724 07AB:9C 04 FC     	stz HOFFL
  725 07AE:9C 05 FC     	stz HOFFH
  726 07B1:9C 06 FC     	stz VOFFL
  727 07B4:9C 07 FC     	stz VOFFH
  728                   ; display the "Paused Message"
  729                   	DBUF_DISPLAY
    1 07B7:08         + 		PHP
    2 07B8:78         + 		SEI
    3 07B9:AD ** **   + 		LDA	RenderBuffer
    4 07BC:AE ** **   + 		ldx	DisplayBuffer
    5 07BF:8D ** **   + 		STA	DisplayBuffer
    6 07C2:8E ** **   + 		stx	RenderBuffer
    7 07C5:AD ** **   + 		LDA	RenderBuffer+1
    8 07C8:AE ** **   + 		ldx	DisplayBuffer+1
    9 07CB:8D ** **   + 		STA	DisplayBuffer+1
   10 07CE:8E ** **   + 		stx	RenderBuffer+1
   11 07D1:28         + 		PLP
   12                 + 
  730                   	SPRITES paused.scb,0
    1      FALSE        		#IF	0 <> 0
    6                 + 		#ELSE
    7 07D2:A9 **      + 		  LDA	#<paused.scb
    8 07D4:8D 10 FC   + 		  STA	SCBNEXTL
    9 07D7:A9 **      + 		  LDA	#>paused.scb
   10 07D9:8D 11 FC   + 		  STA	SCBNEXTH
   11                 + 		#ENDIF
   12 07DC:AD ** **   + 		LDA	RenderBuffer
   13 07DF:8D 08 FC   + 		STA	VIDBASL
   14 07E2:AD ** **   + 		LDA	RenderBuffer+1
   15 07E5:8D 09 FC   + 		STA	VIDBASH
   16 07E8:9C 90 FD   + 		STZ	SDONEACK
   17 07EB:A9 01      + 		LDA	#$01
   18 07ED:8D 91 FC   + 		STA	SPRGO
   19                   		WAITSUZY
    1      07F0       + WAITSUZY.00201	.= *
    2 07F0:A9 01      + 		lda #SUZY_SPACE
    3 07F2:0C F9 FF   + 		tsb MAPCTL		
    4 07F5:9C 91 FD   + 		STZ	CPUSLEEP
    5 07F8:1C F9 FF   + 		trb MAPCTL		
    6 07FB:AD 92 FC   + 		LDA	SPRSYS		
    7 07FE:4A         + 		LSR	A		
    8 07FF:B0 EF      + 		BCS	WAITSUZY.00201		
    9 0801:9C 90 FD   + 		STZ	SDONEACK
   10                 + 
   20                 + 
  731                   	DBUF_DISPLAY
    1 0804:08         + 		PHP
    2 0805:78         + 		SEI
    3 0806:AD ** **   + 		LDA	RenderBuffer
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   14
                        sys.src                         18:23:55  

    4 0809:AE ** **   + 		ldx	DisplayBuffer
    5 080C:8D ** **   + 		STA	DisplayBuffer
    6 080F:8E ** **   + 		stx	RenderBuffer
    7 0812:AD ** **   + 		LDA	RenderBuffer+1
    8 0815:AE ** **   + 		ldx	DisplayBuffer+1
    9 0818:8D ** **   + 		STA	DisplayBuffer+1
   10 081B:8E ** **   + 		stx	RenderBuffer+1
   11 081E:28         + 		PLP
   12                 + 
  732 081F:60           	rts
  733                   
  734 0820:00           pause.save.1	.by 0
  735 0821:00           pause.save.2	.by 0
  736 0822:00           pause.save.3	.by 0
  737 0823:00           pause.save.4	.by 0
  738                   
  739                   ; wait for awhile & cold boot
  740 0824:             do.reset
  741                   	STOPMUSIC		;music off
    1 0824:20 ** **   + 	JSR StopMusic
    2                 + 
  742 0827:20 35 05     	jsr clear.screen
  743 082A:20 ** **     	jsr black.screen
  744 082D:A2 3C        	ldx #60
  745 082F:86 08        	stx tmp
  746 0831:             .00
  747                   	WAITEOF
    1 0831:A9 **      + 		LDA	#DISPLAY_EOFFLAG
    2 0833:1C ** **   + 		TRB	DisplayFlags
    3      0836       + systemp		.=	*
    4 0836:2C ** **   + 		BIT	DisplayFlags
    5 0839:F0 FB      + 		BEQ	systemp
    6                 + 
  748 083B:AD ** **     	lda DisplayFrameCount
  749 083E:C5 08        	cmp tmp
  750 0840:90 EF        	bcc .00
  751 0842:4C 00 04     	jmp cold.start
  752                   
  753                   
  754                   
  755                   
  756                   
  757                   
  758      TRUE         	#ifdef CHEAP_PAUSED
  759                   ; this is the cheap version of paused
  760 0845:             paused.scb
  761 0845:45           	.by TWO_PER_PIXEL+NONCOLL_SPRITE
  762 0846:10           	.by RELOAD_HV
  763 0847:00           	.by 0
  764 0848:00 00 00 00  	.wo 0,paused.data,32,38
  764      20 00 26 00  
  764                   
  765 0850:00 04 00 04  	.wo $400,$400		;expand to big message
  765                   
  766 0854:08 C0        	.by $08,$c0		;the rest of the palette doesn't matter
  767                   
  768 0856:             paused.data
  769                   ; Handy Sprite Image Data
  770                   ; Bits per Pixel = 2
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   15
                        sys.src                         18:23:55  

  771                   ; Next data is down-right
  772 0856:03 7A 84     	.BYTE	$03,$7a,$84
  773 0859:09 C3 53 53  	.BYTE	$09,$c3,$53,$53,$f9,$9a,$9a,$9a,$50
  773      F9 9A 9A 9A  
  773      50           
  774 0862:09 C3 33 33  	.BYTE	$09,$c3,$33,$33,$f9,$99,$59,$59,$90
  774      F9 99 59 59  
  774      90           
  775 086B:09 C3 53 53  	.BYTE	$09,$c3,$53,$53,$f9,$9a,$9a,$59,$90
  775      F9 9A 9A 59  
  775      90           
  776 0874:09 C3 2B 33  	.BYTE	$09,$c3,$2b,$33,$f9,$95,$99,$59,$90
  776      F9 95 99 59  
  776      90           
  777 087D:09 C3 2B 33  	.BYTE	$09,$c3,$2b,$33,$fa,$9a,$9a,$9a,$50
  777      FA 9A 9A 9A  
  777      50           
  778 0886:03 7A 84     	.BYTE	$03,$7a,$84
  779 0889:00           	.BYTE	$00
  780                   ; 52 total image bytes
  781                   	#else
  851                   	#endif
  852                   
  853                   
  854                   
  855                   
  856                   
  857                   
  858                   
  859                   ; ------------------ start.tune -------------------
  860                   ; Starts playing tune
  861                   ; x high byte of music address
  862                   ; a low byte of music address
  863                   ; y tune poke (some timing magic)
  864                   
  865 088A:             start.tune
  866 088A:5A           	phy
  867                   	PLAYMUSIC
    1 088B:20 ** **   + 	JSR PlayMusic
    2                 + 
  868 088E:7A           	ply
  869 088F:8C 18 FD     	sty TIMER6
  870 0892:60           	rts
  871                   
  872                   
  873                   ; ---------------- black.screen -------------
  874                   ; clears screen to black (no fade), but does not draw 
  875 0893:             black.screen
  876 0893:A2 1F        	ldx #32-1
  877 0895:             .00
  878 0895:9E ** **     	stz new.colors.rgb,x
  879 0898:9E ** **     	stz old.colors.rgb,x
  880 089B:CA           	dex
  881 089C:10 F7        	bpl .00
  882                   	WAITEOF
    1 089E:A9 **      + 		LDA	#DISPLAY_EOFFLAG
    2 08A0:1C ** **   + 		TRB	DisplayFlags
    3      08A3       + systemp		.=	*
    4 08A3:2C ** **   + 		BIT	DisplayFlags
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   16
                        sys.src                         18:23:55  

    5 08A6:F0 FB      + 		BEQ	systemp
    6                 + 
  883                   	RGB16 old.colors.rgb
    1 08A8:A9 **      + 		LDA	#<old.colors.rgb
    2 08AA:85 00      + 		STA	sysptr
    3 08AC:A9 **      + 		LDA	#>old.colors.rgb
    4 08AE:85 01      + 		STA	sysptr+1
    5 08B0:A0 1F      + 		LDY	#31
    6 08B2:B1 00      + 		LDA	(sysptr),Y
    7 08B4:99 A0 FD   + 		STA	GREEN0,Y
    8 08B7:88         + 		DEY
    9 08B8:10 F8      + 		BPL	*-6
   10                 + 
  884 08BA:A9 01        	lda #1
  885 08BC:85 11        	sta new.colors
  886 08BE:60           	rts
  887                   
  888                   ; --------------- fade.to.black -------------
  889                   ; initiates fade to all black operation
  890 08BF:             fade.to.black
  891 08BF:A9 00        	lda #0
  892                   ; warning! fall through to set.colors
  893                   
  894                   
  895                   ; --------------- set.colors ----------------
  896                   ; set color palette from table
  897                   ; note that this initiates a fade from the current pal
  898                   ; color set number in accum
  899 08C1:             set.colors
  900 08C1:0A           	asl
  901 08C2:AA           	tax
  902 08C3:BD ** **     	lda color.pnts,x
  903 08C6:85 08        	sta tmp
  904 08C8:BD ** **     	lda color.pnts+1,x
  905 08CB:85 09        	sta tmp+1
  906 08CD:A0 1F        	ldy #32-1
  907 08CF:84 12        	sty fading	;non-zero
  908 08D1:             .00
  909 08D1:B1 08        	lda (tmp),y
  910 08D3:99 ** **     	sta new.colors.rgb,y
  911 08D6:88           	dey
  912 08D7:10 F8        	bpl .00
  913 08D9:60           	rts
  914                   
  915                   ; this is called by the system to fade to different co
  916 08DA:             fade
  917 08DA:A5 13        	lda slow.fade	;set to $ff to fade slowly
  918 08DC:10 **        	bpl .00
  919 08DE:A5 0C        	lda count
  920 08E0:29 07        	and #7
  921 08E2:F0 **        	beq .00
  922 08E4:60           	rts
  923 08E5:             .00
  924 08E5:A5 12        	lda fading
  925 08E7:F0 **        	beq done.fade
  926 08E9:64 12        	stz fading
  927 08EB:A0 01        	ldy #1
  928 08ED:A2 0F        	ldx #15
  929 08EF:             fade.1
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   17
                        sys.src                         18:23:55  

  930 08EF:BD ** **     	lda new.colors.g,x
  931 08F2:29 0F        	and #$f
  932 08F4:85 08        	sta tmp
  933 08F6:BD ** **     	lda old.colors.g,x
  934 08F9:20 ** **     	jsr fader
  935 08FC:9D ** **     	sta old.colors.g,x
  936                   
  937 08FF:BD ** **     	lda new.colors.br,x
  938 0902:29 0F        	and #$f
  939 0904:85 08        	sta tmp
  940 0906:BD ** **     	lda old.colors.br,x
  941 0909:20 ** **     	jsr fader
  942 090C:85 09        	sta tmp+1
  943                   
  944 090E:BD ** **     	lda new.colors.br,x
  945 0911:4A           	lsr
  946 0912:4A           	lsr
  947 0913:4A           	lsr
  948 0914:4A           	lsr
  949 0915:29 0F        	and #$f
  950 0917:85 08        	sta tmp
  951 0919:BD ** **     	lda old.colors.br,x
  952 091C:4A           	lsr
  953 091D:4A           	lsr
  954 091E:4A           	lsr
  955 091F:4A           	lsr
  956 0920:20 ** **     	jsr fader
  957 0923:0A           	asl
  958 0924:0A           	asl
  959 0925:0A           	asl
  960 0926:0A           	asl
  961 0927:29 F0        	and #$f0
  962 0929:05 09        	ora tmp+1
  963 092B:9D ** **     	sta old.colors.br,x
  964 092E:CA           	dex
  965 092F:10 BE        	bpl fade.1
  966 0931:A9 01        	lda #1
  967 0933:85 11        	sta new.colors
  968 0935:             done.fade
  969 0935:60           	rts
  970                   
  971 0936:             fader
  972 0936:29 0F        	and #$f			;trim current fade
  973 0938:C5 08        	cmp tmp			;compare with target
  974 093A:F0 **        	beq fader.2		;done
  975 093C:B0 **        	bcs fader.1		;don't go past target
  976 093E:1A           	ina
  977 093F:29 0F        	and #$f
  978 0941:84 12        	sty fading		;y is non-zero
  979 0943:60           	rts
  980 0944:             fader.1
  981 0944:3A           	dea
  982 0945:84 12        	sty fading		;y is non-zero
  983 0947:             fader.2
  984 0947:60           	rts
  985                   
  986                   
  987      00FF         num		.eq $ff
  988      0008         dig.wid		.eq 8
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   18
                        sys.src                         18:23:55  

  989      0050         scpos		.eq 160-{SCORE_SIZE*2*dig.wid}
  990                   
  991                   ; this is called by the system to display the score
  992                   ; the score is right justified in the upper right corn
  993                   ; leading zeros are trimmed, and a score of all 0 prod
  994                   
  995 0948:             show.score
  996 0948:9C 04 FC     	stz HOFFL		;clear scrolling
  997 094B:9C 05 FC     	stz HOFFH
  998 094E:9C 06 FC     	stz VOFFL
  999 0951:9C 07 FC     	stz VOFFH
 1000 0954:64 08        	stz tmp			;blank leading zeros
 1001 0956:A9 50        	lda #scpos
 1002 0958:8D ** **     	sta score.scb+7
 1003                   
 1004 095B:A2 04        	ldx #SCORE_SIZE-1
 1005 095D:             show.score.loop
 1006 095D:B5 14        	lda score,x
 1007 095F:20 ** **     	jsr show.score.byte
 1008 0962:CA           	dex
 1009 0963:10 F8        	bpl show.score.loop
 1010 0965:60           	rts
 1011                   
 1012 0966:             show.score.byte
 1013 0966:DA           	phx
 1014 0967:48           	pha
 1015 0968:4A           	lsr
 1016 0969:4A           	lsr
 1017 096A:4A           	lsr
 1018 096B:4A           	lsr
 1019 096C:20 ** **     	jsr show.score.nib
 1020 096F:68           	pla
 1021 0970:29 0F        	and #$f
 1022 0972:20 ** **     	jsr show.score.nib
 1023 0975:FA           	plx
 1024 0976:60           	rts
 1025                   
 1026 0977:             show.score.nib
 1027 0977:A6 08        	ldx tmp
 1028 0979:D0 **        	bne score.nib.1
 1029 097B:C9 00        	cmp #0
 1030 097D:D0 **        	bne score.nib.1
 1031 097F:             clear.score.nib
 1032 097F:A9 0A        	lda #10			;blank leading zeros
 1033 0981:80 **        	bra score.nib.2
 1034 0983:             score.nib.1
 1035 0983:A2 01        	ldx #1
 1036 0985:86 08        	stx tmp
 1037 0987:             score.nib.2
 1038 0987:AA           	tax
 1039 0988:BD ** **     	lda num.tab.lo,x
 1040 098B:8D ** **     	sta score.scb+5
 1041 098E:BD ** **     	lda num.tab.hi,x
 1042 0991:8D ** **     	sta score.scb+6
 1043                   
 1044                   	RESPRITE score.scb,0
    1      FALSE        		#IF	0 <> 0
    6                 + 		#ELSE
    7 0994:A9 **      + 		  LDA	#<score.scb
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   19
                        sys.src                         18:23:55  

    8 0996:8D 10 FC   + 		  STA	SCBNEXTL
    9 0999:A9 **      + 		  LDA	#>score.scb
   10 099B:8D 11 FC   + 		  STA	SCBNEXTH
   11                 + 		#ENDIF
   12 099E:9C 90 FD   + 		STZ	SDONEACK
   13 09A1:A9 01      + 		LDA	#$01
   14 09A3:8D 91 FC   + 		STA	SPRGO
   15                   		WAITSUZY
    1      09A6       + WAITSUZY.00281	.= *
    2 09A6:A9 01      + 		lda #SUZY_SPACE
    3 09A8:0C F9 FF   + 		tsb MAPCTL		
    4 09AB:9C 91 FD   + 		STZ	CPUSLEEP
    5 09AE:1C F9 FF   + 		trb MAPCTL		
    6 09B1:AD 92 FC   + 		LDA	SPRSYS		
    7 09B4:4A         + 		LSR	A		
    8 09B5:B0 EF      + 		BCS	WAITSUZY.00281		
    9 09B7:9C 90 FD   + 		STZ	SDONEACK
   10                 + 
   16                 + 
 1045 09BA:AD ** **     	lda score.scb+7
 1046 09BD:18           	clc
 1047 09BE:69 08        	adc #dig.wid
 1048 09C0:8D ** **     	sta score.scb+7
 1049 09C3:60           	rts
 1050                   
 1051 09C4:             score.scb
 1052 09C4:45           	.by TWO_PER_PIXEL+NONCOLL_SPRITE
 1053 09C5:30           	.by RELOAD_HVST
 1054 09C6:00           	.by 0
 1055 09C7:00 ** ** **  	.wo 0,num0.data
 1055                   
 1056 09CB:00 00 02 00  	.wo 0,2
 1056                   
 1057 09CF:00 01        	.wo $0100
 1058 09D1:00 01        	.wo $0100
 1059 09D3:00 00 00 00  	.wo 0,0
 1059                   
 1060 09D7:08 C0        	.by $08,$c0
 1061                   
 1062                   
 1063 09D9:             num0.data
 1064                   
 1065                   ; Handy Sprite Image Data
 1066                   ; Bits per Pixel = 2
 1067                   ; Next data is down-right
 1068 09D9:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1068                   
 1069 09DD:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1069      00           
 1070 09E2:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1070      68 20 00     
 1071 09E9:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1071      68 20 00     
 1072 09F0:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1072      68 20 00     
 1073 09F7:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1073      68 20 00     
 1074 09FE:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1074      68 20 00     
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   20
                        sys.src                         18:23:55  

 1075 0A05:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1075      00           
 1076 0A0A:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1076                   
 1077 0A0E:00           	.BYTE	$00
 1078                   ; 54 total image bytes
 1079 0A0F:             num1.data
 1080                   
 1081                   ; Handy Sprite Image Data
 1082                   ; Bits per Pixel = 2
 1083                   ; Next data is down-right
 1084 0A0F:04 08 34 00  	.BYTE	$04,$08,$34,$00
 1084                   
 1085 0A13:06 80 14 34  	.BYTE	$06,$80,$14,$34,$10,$00
 1085      10 00        
 1086 0A19:05 88 8A 82  	.BYTE	$05,$88,$8a,$82,$00
 1086      00           
 1087 0A1E:06 80 14 34  	.BYTE	$06,$80,$14,$34,$10,$00
 1087      10 00        
 1088 0A24:06 09 04 34  	.BYTE	$06,$09,$04,$34,$10,$00
 1088      10 00        
 1089 0A2A:06 09 04 34  	.BYTE	$06,$09,$04,$34,$10,$00
 1089      10 00        
 1090 0A30:05 12 18 48  	.BYTE	$05,$12,$18,$48,$00
 1090      00           
 1091 0A35:05 82 5A 08  	.BYTE	$05,$82,$5a,$08,$00
 1091      00           
 1092 0A3A:03 3A 00     	.BYTE	$03,$3a,$00
 1093 0A3D:00           	.BYTE	$00
 1094                   ; 47 total image bytes
 1095                   
 1096 0A3E:             num2.data
 1097                   
 1098                   ; Handy Sprite Image Data
 1099                   ; Bits per Pixel = 2
 1100                   ; Next data is down-right
 1101 0A3E:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1101                   
 1102 0A42:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1102      00           
 1103 0A47:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1103      68 20 00     
 1104 0A4E:05 22 1A 08  	.BYTE	$05,$22,$1a,$08,$00
 1104      00           
 1105 0A53:06 80 14 50  	.BYTE	$06,$80,$14,$50,$50,$00
 1105      50 00        
 1106 0A59:05 0A 18 48  	.BYTE	$05,$0a,$18,$48,$00
 1106      00           
 1107 0A5E:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1107      68 20 00     
 1108 0A65:05 82 5A 08  	.BYTE	$05,$82,$5a,$08,$00
 1108      00           
 1109 0A6A:03 3A 00     	.BYTE	$03,$3a,$00
 1110 0A6D:00           	.BYTE	$00
 1111                   ; 48 total image bytes
 1112 0A6E:             num3.data
 1113                   
 1114                   ; Handy Sprite Image Data
 1115                   ; Bits per Pixel = 2
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   21
                        sys.src                         18:23:55  

 1116                   ; Next data is down-right
 1117 0A6E:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1117                   
 1118 0A72:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1118      00           
 1119 0A77:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1119      68 20 00     
 1120 0A7E:05 22 1A 08  	.BYTE	$05,$22,$1a,$08,$00
 1120      00           
 1121 0A83:06 09 04 54  	.BYTE	$06,$09,$04,$54,$10,$00
 1121      10 00        
 1122 0A89:05 22 1A 08  	.BYTE	$05,$22,$1a,$08,$00
 1122      00           
 1123 0A8E:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1123      68 20 00     
 1124 0A95:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1124      00           
 1125 0A9A:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1125                   
 1126 0A9E:00           	.BYTE	$00
 1127                   ; 49 total image bytes
 1128 0A9F:             num4.data
 1129                   
 1130                   ; Handy Sprite Image Data
 1131                   ; Bits per Pixel = 2
 1132                   ; Next data is down-right
 1133 0A9F:04 10 44 00  	.BYTE	$04,$10,$44,$00
 1133                   
 1134 0AA3:06 08 14 54  	.BYTE	$06,$08,$14,$54,$10,$00
 1134      10 00        
 1135 0AA9:06 80 14 74  	.BYTE	$06,$80,$14,$74,$10,$00
 1135      10 00        
 1136 0AAF:07 0A 1A 08  	.BYTE	$07,$0a,$1a,$08,$68,$20,$00
 1136      68 20 00     
 1137 0AB6:07 82 18 28  	.BYTE	$07,$82,$18,$28,$60,$a0,$00
 1137      60 A0 00     
 1138 0ABD:05 82 6A 08  	.BYTE	$05,$82,$6a,$08,$00
 1138      00           
 1139 0AC2:05 22 18 28  	.BYTE	$05,$22,$18,$28,$00
 1139      00           
 1140 0AC7:06 11 04 74  	.BYTE	$06,$11,$04,$74,$10,$00
 1140      10 00        
 1141 0ACD:04 10 54 00  	.BYTE	$04,$10,$54,$00
 1141                   
 1142 0AD1:00           	.BYTE	$00
 1143                   ; 51 total image bytes
 1144 0AD2:             num5.data
 1145                   
 1146                   ; Handy Sprite Image Data
 1147                   ; Bits per Pixel = 2
 1148                   ; Next data is down-right
 1149 0AD2:03 3A 00     	.BYTE	$03,$3a,$00
 1150 0AD5:05 82 5A 08  	.BYTE	$05,$82,$5a,$08,$00
 1150      00           
 1151 0ADA:05 82 18 88  	.BYTE	$05,$82,$18,$88,$00
 1151      00           
 1152 0ADF:05 82 48 28  	.BYTE	$05,$82,$48,$28,$00
 1152      00           
 1153 0AE4:05 22 1A 08  	.BYTE	$05,$22,$1a,$08,$00
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   22
                        sys.src                         18:23:55  

 1153      00           
 1154 0AE9:06 80 34 34  	.BYTE	$06,$80,$34,$34,$10,$00
 1154      10 00        
 1155 0AEF:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1155      68 20 00     
 1156 0AF6:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1156      00           
 1157 0AFB:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1157                   
 1158 0AFF:00           	.BYTE	$00
 1159                   ; 46 total image bytes
 1160                   
 1161 0B00:             num6.data
 1162                   
 1163                   ; Handy Sprite Image Data
 1164                   ; Bits per Pixel = 2
 1165                   ; Next data is down-right
 1166 0B00:04 08 44 00  	.BYTE	$04,$08,$44,$00
 1166                   
 1167 0B04:06 80 14 54  	.BYTE	$06,$80,$14,$54,$10,$00
 1167      10 00        
 1168 0B0A:05 0A 18 48  	.BYTE	$05,$0a,$18,$48,$00
 1168      00           
 1169 0B0F:05 82 18 48  	.BYTE	$05,$82,$18,$48,$00
 1169      00           
 1170 0B14:05 82 4A 08  	.BYTE	$05,$82,$4a,$08,$00
 1170      00           
 1171 0B19:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1171      68 20 00     
 1172 0B20:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1172      68 20 00     
 1173 0B27:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1173      00           
 1174 0B2C:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1174                   
 1175 0B30:00           	.BYTE	$00
 1176                   ; 49 total image bytes
 1177                   
 1178 0B31:             num7.data
 1179                   
 1180                   ; Handy Sprite Image Data
 1181                   ; Bits per Pixel = 2
 1182                   ; Next data is down-right
 1183 0B31:03 3A 00     	.BYTE	$03,$3a,$00
 1184 0B34:05 82 5A 08  	.BYTE	$05,$82,$5a,$08,$00
 1184      00           
 1185 0B39:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1185      68 20 00     
 1186 0B40:05 22 1A 08  	.BYTE	$05,$22,$1a,$08,$00
 1186      00           
 1187 0B45:06 08 14 30  	.BYTE	$06,$08,$14,$30,$50,$00
 1187      50 00        
 1188 0B4B:06 09 04 30  	.BYTE	$06,$09,$04,$30,$50,$00
 1188      50 00        
 1189 0B51:06 09 04 34  	.BYTE	$06,$09,$04,$34,$10,$00
 1189      10 00        
 1190 0B57:06 09 04 34  	.BYTE	$06,$09,$04,$34,$10,$00
 1190      10 00        
 1191 0B5D:04 08 34 00  	.BYTE	$04,$08,$34,$00
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   23
                        sys.src                         18:23:55  

 1191                   
 1192 0B61:00           	.BYTE	$00
 1193                   ; 49 total image bytes
 1194                   
 1195 0B62:             num8.data
 1196                   
 1197                   ; Handy Sprite Image Data
 1198                   ; Bits per Pixel = 2
 1199                   ; Next data is down-right
 1200 0B62:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1200                   
 1201 0B66:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1201      00           
 1202 0B6B:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1202      68 20 00     
 1203 0B72:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1203      68 20 00     
 1204 0B79:05 88 8E 82  	.BYTE	$05,$88,$8e,$82,$00
 1204      00           
 1205 0B7E:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1205      68 20 00     
 1206 0B85:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1206      68 20 00     
 1207 0B8C:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1207      00           
 1208 0B91:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1208                   
 1209 0B95:00           	.BYTE	$00
 1210                   ; 52 total image bytes
 1211                   
 1212 0B96:             num9.data
 1213                   
 1214                   ; Handy Sprite Image Data
 1215                   ; Bits per Pixel = 2
 1216                   ; Next data is down-right
 1217 0B96:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1217                   
 1218 0B9A:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1218      00           
 1219 0B9F:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1219      68 20 00     
 1220 0BA6:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1220      68 20 00     
 1221 0BAD:05 0A 4A 08  	.BYTE	$05,$0a,$4a,$08,$00
 1221      00           
 1222 0BB2:06 80 34 34  	.BYTE	$06,$80,$34,$34,$10,$00
 1222      10 00        
 1223 0BB8:06 08 14 30  	.BYTE	$06,$08,$14,$30,$50,$00
 1223      50 00        
 1224 0BBE:05 88 8A 0A  	.BYTE	$05,$88,$8a,$0a,$00
 1224      00           
 1225 0BC3:04 80 44 00  	.BYTE	$04,$80,$44,$00
 1225                   
 1226 0BC7:00           	.BYTE	$00
 1227                   ; 50 total image bytes
 1228 0BC8:             nada.data
 1229 0BC8:00 00 00 00  	.by 0,0,0,0
 1229                   
 1230                   
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   24
                        sys.src                         18:23:55  

 1231 0BCC:             num.tab.lo
 1232 0BCC:D9 0F 3E 6E  	.by <num0.data,<num1.data,<num2.data,<num3.data,<num4
 1232      9F           
 1233 0BD1:D2 00 31 62  	.by <num5.data,<num6.data,<num7.data,<num8.data,<num9
 1233      96           
 1234 0BD6:C8           	.by <nada.data
 1235                   
 1236 0BD7:             num.tab.hi
 1237 0BD7:09 0A 0A 0A  	.by >num0.data,>num1.data,>num2.data,>num3.data,>num4
 1237      0A           
 1238 0BDC:0A 0B 0B 0B  	.by >num5.data,>num6.data,>num7.data,>num8.data,>num9
 1238      0B           
 1239 0BE1:0B           	.by >nada.data
 1240                   
 1241                   
 1242                   
 1243                   
 1244                   
 1245                   ; ---------------- start.sound ----------------
 1246                   ; sound effect rountine
 1247                   ; makes sound based on the value in A
 1248 0BE2:             start.sound
 1249 0BE2:AA           	tax
 1250 0BE3:BC ** **     	ldy sound.pri,x
 1251 0BE6:BD ** **     	lda sound.hi,x
 1252 0BE9:48           	pha
 1253 0BEA:BD ** **     	lda sound.lo,x
 1254 0BED:FA           	plx
 1255                   	PLAYHSFX
    1 0BEE:20 ** **   + 		JSR	StartHSFX
    2                 + 
 1256 0BF1:60           	rts
 1257                   
 1258                   
 1259                   ; ------------- random -------------
 1260                   ; random number generator
 1261                   ; returns with number in Acc (does not affect other re
 1262                   ; (sequence of 64K numbers)
 1263 0BF2:             random
 1264 0BF2:5A           	phy
 1265 0BF3:A4 06        	ldy random.ndx
 1266 0BF5:B9 F2 0B     	lda random,y
 1267 0BF8:59 00 04     	eor cold.start,y	;some place in code
 1268 0BFB:45 06        	eor random.ndx
 1269 0BFD:E6 06        	inc random.ndx
 1270 0BFF:D0 **        	bne .00
 1271 0C01:E6 07        	inc random.ndx+1
 1272 0C03:             .00
 1273 0C03:45 07        	eor random.ndx+1
 1274 0C05:7A           	ply
 1275 0C06:60           	rts
 1276                   
 1277                   
 1278                   
 1279                   ;----------------- add.score ------------------------
 1280                   ; add to score
 1281                   ; enter with BCD value ($00 to $99) in Acc
 1282 0C07:             add.score
 1283 0C07:A2 00        	ldx #0
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   25
                        sys.src                         18:23:55  

 1284                   ; note: falls through to add.big.score
 1285                   
 1286                   
 1287                   
 1288                   ;----------------- add.big.score ---------------------
 1289                   ; enter here to add large numbers to score
 1290                   ; enter with BCD value ($00 to $99) in Acc
 1291                   ; Reg X should contain the exponent: 1=times100, 2=tim
 1292 0C09:             add.big.score
 1293 0C09:F8           	sed
 1294 0C0A:18           	clc
 1295 0C0B:65 14        	adc score
 1296 0C0D:85 14        	sta score
 1297 0C0F:90 **        	bcc done.score
 1298 0C11:             add.score.1
 1299 0C11:08           	php
 1300 0C12:E8           	inx
 1301 0C13:E0 05        	cpx #SCORE_SIZE		; prevents fatal type wrap-around
 1302 0C15:F0 **        	beq done.score.1
 1303 0C17:28           	plp
 1304 0C18:B5 14        	lda score,x
 1305 0C1A:69 00        	adc #0
 1306 0C1C:95 14        	sta score,x
 1307 0C1E:B0 F1        	bcs add.score.1
 1308 0C20:             done.score
 1309 0C20:D8           	cld	
 1310 0C21:60           	rts
 1311 0C22:             done.score.1
 1312 0C22:28           	plp
 1313 0C23:D8           	cld
 1314 0C24:60           	rts
 1315                   
 1316 0C25:             black.Data
 1317                   ; Handy Sprite Image Data
 1318                   ; Bits per Pixel = 1
 1319                   ; Next data is down-right
 1320 0C25:02 08        	.BYTE	$02,$08
 1321 0C27:02 08        	.BYTE	$02,$08
 1322 0C29:00           	.BYTE	$00
 1323                   ; 5 total image bytes
 1324 0C2A:             black
 1325                   ; Handy Sprite
 1326 0C2A:01           	.BYTE	ONE_PER_PIXEL+BACKNONCOLL_SPRITE ; Control 0
 1327 0C2B:30           	.BYTE	RELOAD_HVST ; Control 1
 1328 0C2C:00           	.BYTE	$00 ; Control 2
 1329 0C2D:00 00        	.WORD	$0000	; Next Sprite
 1330 0C2F:25 0C        	.WORD	black.Data	; ImageData
 1331 0C31:00 00        	.WORD	0	; HPos
 1332 0C33:00 00        	.WORD	0	; VPos
 1333 0C35:00 50        	.WORD	80*256	; HSize
 1334 0C37:00 33        	.WORD	51*256	; VSize
 1335 0C39:00 00        	.WORD	$0000	; Stretch
 1336 0C3B:00 00        	.WORD	$0000	; Tilt
 1337                   	; Palette
 1338 0C3D:00           	.BYTE	$00
 1339                   
 1340                   
 1341 0C3E:             beg.sys
 1342                   ; system code source includes
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   26
                        sys.src                         18:23:55  

 1343                   	.in 6502:src/sysdata.src
    1                   ; Tuesday 27-Mar-90 10:58:04
    2                   * === sysdata.src ====================================
    3                   * 
    4                   * System Data Allocations  --  the 6502 Side of Handy
    5                   * 
    6                   * Copyright (c) 1988,1990 Epyx, Inc.
    7                   * All Rights Reserved
    8                   * CONFIDENTIAL and PROPRIETARY
    9                   * 
   10                   * Date		Name		Description
   11                   * ---------	--------------	---------------------------
   12                   * 27-Mar-90	SHL		Removed BufferAddrL, BufferAddrH
   13                   * 22-Mar-90	SHL		Added INTSET_RAM shadow for IRQs
   14                   * 9-Feb-90	SHL		Removed Apple emulation compatibility
   15                   * 30 May 89	-RJ		Added IODAT_RAM
   16                   * 24 May 89	-RJ		Added AUTO_TIMEOUT_USER support code
   17                   * 20 Apr 89	-RJ		Added IODIR_RAM
   18                   * 19 Apr 89	-RJ		Moved DisplayFrameCount to display.sr
   19                   * 20 Mar 89	-RJ		Added DisplayFrameCount
   20                   * 13 Feb 89	-RJ		Added DisplayBuffer
   21                   * 26 Jan 88	-RJ		Ended Interruptus
   22                   * 24 Dec 88	-RJ		Added Interruptus
   23                   * 22 Dec 88	-RJ		Added DISPCTL_RAM, RenderBuffer, 
   24                   *				BufferAddrL/H, and DisplayFlags with its defs
   25                   *				Added note about .ORGing to non-zpage
   26                   * Early 88	=RJ Mical=	Created this file!
   27                   * 
   28                   * ====================================================
   29                   
   30                   
   31                   * NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE
   32                   * 
   33                   * This file should be included before any of the 6502:
   34                   * 
   35                   * Note that you should .ORG to a non-zero page address
   36                   * this file.  This is because this file includes data 
   37                   * don't need to be in zero-page memory.
   38                   * 
   39                   * NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE
   40                   
   41                   
   42                   * Here are the declarations of the local copies of wri
   43                   * (and read-doesn't-equal-write registers such as SPRS
   44                   * Whenever you want to make a change to one of the har
   45                   * that's write-only, you should read from this RAM cop
   46                   * and then write the value out to both the RAM copy an
   47 0C3E:             SPRSYS_RAM	.DS 1
   48 0C3F:             DISPCTL_RAM	.DS 1
   49 0C40:             IODAT_RAM	.DS 1
   50 0C41:             IODIR_RAM	.DS 1
   51                   
   52                   
   53                   * Display buffer pointers for use by the system displa
   54 0C42:             RenderBuffer	.DS 2
   55 0C44:             DisplayBuffer	.DS 2
   56                   
   57                   * Shadow of INTSET used in IRQ handler
   58 0C46:             INTSET_RAM	.DS 1
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   27
                        6502:src/sysdata.src            18:23:55  

   59                   
   60                   
   61      FALSE        	#IFDEF AUTO_TIMEOUT_USER
   63                   	#ENDIF
   64                   
   65                   
   66                   * The DisplayFlags field is a field that may enjoy mul
   67                   * read-modify-write operations peformed by both interr
   68                   * Because of this, any code must make sure that interr
   69                   * beginning a read-modify-write cycle, or use the TSB/
   70 0C47:             DisplayFlags	.DS	1
   71                   * Here's the definitions of DisplayFlags
   72      0080         DISPLAY_EOFFLAG		.EQ $80	; Set every EOF
   73      0040         DISPLAY_EOLFLAG		.EQ $40	; Set every EOL
   74                   
   75                   
   76                   
 1344                   	.in 6502:src/hsfx.src
    1                   ; Tue Sep 18 17:43:53 1990
    2                   * === hsfx.src =======================================
    3                   *
    4                   * Handy Sound Effects Driver  --  Handy Software
    5                   *
    6                   * Confidential and Proprietary
    7                   * Copyright (C) 1989, Epyx, Inc.
    8                   *
    9                   * Date		Name		Description
   10                   * ---------	--------------	---------------------------
   11                   * 04-May-90	SHL		If not integrated, voice bias reset o
   12                   *				channel.  If integrating, voice bias ramped to
   13                   *				zero.  No longer tries to play sounds if voice
   14                   *				owned by someone else.
   15                   * 19-Apr-90	SHL		AllocAudio and GrabAudio routines now
   16                   *				inly if GRABAUDIO_USER is set.
   17                   *				General code tightening and cleanup.
   18                   *				Moved top_of_loop0,1 variables to hsfx.var .
   19                   *				Moved hsfx_temp to zero page.
   20                   * 18-Apr-90	SHL		InitHSFX now zeroes all HSFX variable
   21                   *				FreeAudio now zeroes bias on stopped channel
   22                   * 01-Apr-90	SHL & G Colgate	Added USER_HSFX switch and
   23                   * 26-Mar-90	SHL		Removed PHA, PHX instructions from hs
   24                   *				Changed driver exit to match new IRQ handler
   25                   * 6 Oct 89	SHL		Modified driver to catch dropped frame
   26                   *				Modified START_DISABLE and END_DISABLE macros
   27                   *				to use the new flag audio_lockout
   28                   * 14 Sep 89	SJ		Fix to register clear in StartHSFX
   29                   * 5 Sept 89	SJ		Changed public calls to lock out just 
   30                   * 31 Aug 89	SJ		Changed code to use HSFX_CHANNELCOUNT 
   31                   *				Made variables relocatable in HSFX.var
   32                   *				User programs now must include HSFX.var also.
   33                   *				Tightened up key frame loop in update_frame.
   34                   * 30 Aug 89	Stephen Jungels	Clear launch_channel flag 
   35                   *				Simplified channel killing code.
   36                   *				Modified grunt main loops.
   37                   *				Changed ResetHSFX to call FreeAudio.
   38                   * 11 Aug 89	-RJ		Restore I flag at end of int. driver 
   39                   *				clearing audio_interruptus
   40                   * 1 June 89	-RJ		Added some pre-CES bullet-proofing to
   41                   *				channel number in FreeAudio and GrabAudio
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   28
                        6502:src/hsfx.src               18:23:55  

   42                   * 1 June 89	SHL		Moved hsfx_driver core to hsfx_driver
   43                   *				called by both hsfx_driver and hmusic_driver
   44                   *				allowing SEPARATE_HMUSIC_HSFX to work
   45                   * 31 May 89	SHL		Added the required 5th element to Cha
   46                   * 13 May 89	-RJ		Added SEPARATE_HMUSIC_HSFX support
   47                   * 11 May 89	-RJ		FrameClock and FramePreload are chang
   48                   *				AudioClock and AudioPreload.  These are now
   49                   *				set using AUDIO_CLOCK_MASK and AUDIO_PRELOAD.
   50                   *				Removed HFIX1 references.  Made InitHSFX
   51                   *				always disable interrupts
   52                   * 1 May 89	-RJ		Changed all IntTable references to sys
   53                   *				which is defined now in the sys.mac file
   54                   * 30 Apr 89	-RJ		Got rid of old CES_SLOWCLOCK stuff
   55                   * 5 Apr 89	-RJ		Added audio_interruptus.  The hsfx dri
   56                   *				interrupt code now clears interrupt disable
   57                   *				as soon as its taken steps to prevent
   58                   *				reentrancy, thereby allowing other more
   59                   *				important interrupts to be processed.
   60                   * 22 Mar 89	-RJ		Moved declaration of audio_ptr into t
   61                   *				Changed order of steps in ResetHSFX.
   62                   *				Added cancellation of launch_channel in Reset.
   63                   *				Tightened code in calc_next_audio
   64                   * 21 Mar 89	-RJ		Changed name of effect_in_use to Chan
   65                   *				By request, changed name of temp to hsfx_temp.
   66                   *				Tightened up loop in ResetHSFX
   67                   * 20 Mar 89	-RJ		Merged RG's changes into this file, a
   68                   *				many comments, general cleanup
   69                   * 19 Mar 89	-RJ		Added many calls to HFIX1 macros as n
   70                   * Feb 89	RG		Tightened code, folded music into HSFX
   71                   * 4 Jan 89	=RJ Mical=	Stripped out sample program, cha
   72                   *				to match harddefs.i
   73                   *				Added AUDIO_TIMER definition and more
   74                   * Late 88	RG Goudy	Created this file!
   75                   *
   76                   * ====================================================
   77                   
   78                   
   79                   
   80                   
   81      TRUE            #IFNDEF START_DISABLE
   82                   
   83      0001         AUDIO_DISABLE	.EQU	1
   84                   ; Define AUDIO_DISABLE to disable audio interrupts *on
   85                   ; routines.  Undefine AUDIO_DISABLE to lock out *all* 
   86                   
   87                   	#MACRO START_DISABLE
   88 MACRO             		#IFDEF AUDIO_DISABLE
   89 MACRO             		 INC	audio_lockout
   90 MACRO             		#ELSE
   91 MACRO             		 PHP
   92 MACRO             		 SEI
   93 MACRO             		#ENDIF
   94                   	#ENDM	; START_DISABLE
   95                   
   96                   	#MACRO END_DISABLE
   97 MACRO             		#IFDEF AUDIO_DISABLE
   98 MACRO             		 DEC	audio_lockout
   99 MACRO             		#ELSE
  100 MACRO             		 PLP
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   29
                        6502:src/hsfx.src               18:23:55  

  101 MACRO             		#ENDIF
  102                   	#ENDM	; END_DISABLE
  103                   
  104                   
  105                      #ENDIF	; OF IFNDEF START_DISABLE
  106                   
  107                   
  108                   
  109                   		BEGIN_ZPAGE
    1      0C48       + TEMPORG	  .= *
    2 0C48:           + 	  .ORG NEXTZPG
    3                 + 
  110 0035:             audio_ptr	.DS 2		; grab some zero page variables
  111 0037:             hsfx_temp	.DS 1
  112                   		END_ZPAGE
    1      0038       + NEXTZPG	  .= *
    2      FALSE        	  #IF NEXTZPG > $0100
    4                 + 	  #ENDIF
    5 0038:           + 	  .ORG TEMPORG
    6                 + 
  113                   
  114                   
  115                   
  116                   * If HMUSIC is out there and if the programmer hasn't 
  117                   * SEPARATE_HMUSIC_HSFX then define hsfxSysCancel, whic
  118                   * little more than a subroutine call for HMUSIC
  119      TRUE         	#IFDEF HANDYMUSIC
  120      TRUE         	  #IFNDEF SEPARATE_HMUSIC_HSFX
  121      0001         hsfxSysCancel	.EQU	1
  122                   	  #ENDIF
  123                   	#ENDIF
  124                   
  125                   
  126                   
  127 0C48:             InitHSFX
  128                   * ====================================================
  129                   * Sound Effects Driver Initialization
  130                   * You should call this routine only once, during the i
  131                   * portion of your code
  132                   * Warning from RG:  if you muck with it and it doesn't
  133                   * (yes, straight to bed with no dinner).
  134                   *
  135                   * If you are using the Handy music driver you are supp
  136                   * the audio system by calling InitMusic.  InitMusic ca
  137                   * aren't required to call both.
  138                   
  139                   
  140      FALSE         #IFNDEF hsfxSysCancel
  148                    #ENDIF
  149                   
  150 0C48:A9 9E        	  lda #AUDIO_CLOCK_MASK+ENABLE_INT+ENABLE_RELOAD+ENAB
  151 0C4A:A0 40        	  ldy #AUDIO_PRELOAD
  152 0C4C:8D 19 FD     	  sta TIMER0+{AUDIO_TIMER*4}+TIM_CONTROLA
  153 0C4F:8C 18 FD     	  sty TIMER0+{AUDIO_TIMER*4}+TIM_BACKUP
  154                   
  155      FALSE         #IFNDEF hsfxSysCancel
  157                    #ENDIF
  158                   
  159                   * ... and intentionally fall into ResetHSFX
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   30
                        6502:src/hsfx.src               18:23:55  

  160                   
  161                   
  162                   
  163 0C52:             ResetHSFX
  164                   * ====================================================
  165                   * This routine turns off the audio channels and clears
  166                   * usage of all the channels.  You can call this routin
  167                   * whenever you like, as often as you like.
  168                   
  169                   * Warning:  this code is fallen into from above
  170                   
  171 0C52:08           	 php
  172 0C53:78           	  sei
  173                   
  174 0C54:A2 **        	  ldx #HSFXVarEnd-HSFXVarStart	; clear all HSFX varia
  175 0C56:9E ** **     .00	    stz HSFXVarStart-1,x
  176 0C59:CA           	    dex
  177 0C5A:D0 FA        	   bne .00
  178                   
  179 0C5C:A2 03        	  ldx #HSFX_CHANNELCOUNT-1	; free each audio channel
  180 0C5E:20 ** **     .10	    jsr FreeAudio
  181 0C61:CA           	    dex
  182 0C62:10 FA        	   bpl .10
  183                   
  184 0C64:28           	 plp
  185 0C65:60           	rts
  186                   
  187                   
  188 0C66:             StartHSFX
  189                   * ====================================================
  190                   * The StartHSFX routine is called to add a sound effec
  191                   * Call with the address of your HSFX table in A,X (low
  192                   * with the priority of this sound effect in Y.
  193                   *
  194                   * If your sound effect is successfully added, carry is
  195                   * has the audio channel number of your sound effect.  
  196                   * couldn't be added, carry is set on return and X will
  197                   * Channel 4 is a mock HSFX channel, the priority of wh
  198                   * ChannelInUse) will always be zero and therefore will
  199                   * priority of a sound effect submitted to StartHSFX.  
  200                   * convenience of being able to check at a later time w
  201                   * sound effect is still active without requiring the o
  202                   * whether the call to StartHSFX succeeded or failed in
  203                   *
  204                   * On return:
  205                   *    carry clear = success
  206                   *      carry set = failure
  207                   *              X = channel number (0 - 3) of sound eff
  208                   
  209                   
  210                   	START_DISABLE	; disable sound IRQs
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0C66:EE ** **   + 		 INC	audio_lockout
    3                   		#ELSE
    6                 + 		#ENDIF
    7                 + 
  211                   
  212 0C69:85 35        	sta audio_ptr		; hsfx table address lsb
  213 0C6B:86 36        	stx audio_ptr+1		; hsfx table address msb
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   31
                        6502:src/hsfx.src               18:23:55  

  214                   
  215 0C6D:20 ** **     	jsr find_lesser_channel
  216 0C70:B0 **        	bcs .00
  217                   
  218 0C72:A2 04        	ldx #HSFX_CHANNELCOUNT	; Return mock channel number
  219                   
  220                   	END_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0C74:CE ** **   + 		 DEC	audio_lockout
    3                   		#ELSE
    5                 + 		#ENDIF
    6                 + 
  221                   
  222 0C77:38           	sec			; Return result:  no channel available
  223 0C78:60           	rts
  224                   
  225                   
  226 0C79:9D ** **     .00	sta ChannelInUse,x	; Store priority of this channe
  227 0C7C:A5 35        	lda audio_ptr
  228 0C7E:9D ** **     	sta hsfx_basel,x
  229 0C81:A5 36        	lda audio_ptr+1
  230 0C83:9D ** **     	sta hsfx_baseh,x
  231                   
  232 0C86:8A           	txa			; Clear accumulators & interpolators
  233 0C87:18           	clc
  234 0C88:69 3C        	adc #HSFX_CHANNELCOUNT*{HSFX_REGSIZE*HSFX_REGCOUNT-1}
  235 0C8A:38           	sec
  236 0C8B:AA           .11	  tax
  237 0C8C:9E ** **     	  stz freql,x
  238 0C8F:E9 04        	  sbc #HSFX_CHANNELCOUNT
  239 0C91:B0 F8        	 bcs .11		; X comes out of loop with correct index
  240                   
  241 0C93:20 ** **     	jsr update_frame	; read in first key frame
  242 0C96:20 ** **     	jsr calc_next_audio	; set up for first hardware load
  243                   
  244 0C99:A9 80        	lda #$80		; set signal to start sound effect
  245 0C9B:9D ** **     	sta launch_channel,x
  246                   
  247                   	END_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0C9E:CE ** **   + 		 DEC	audio_lockout
    3                   		#ELSE
    5                 + 		#ENDIF
    6                 + 
  248                   
  249 0CA1:18           	clc			; tell caller that channel was gotten
  250 0CA2:60           	rts
  251                   
  252                   
  253                   
  254 0CA3:             StopHSFX
  255                   * ====================================================
  256                   * This routine is called to remove a sound effect from
  257                   * Call with the priority of the sound effect to stop i
  258                   *
  259                   * On return:
  260                   *    A, X and Y are trashed
  261                   *    carry clear = a sound effect with this priority w
  262                   *    carry set = no sound effect with this priority wa
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   32
                        6502:src/hsfx.src               18:23:55  

  263                   
  264                   
  265                   	START_DISABLE		; kill sound IRQs
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0CA3:EE ** **   + 		 INC	audio_lockout
    3                   		#ELSE
    6                 + 		#ENDIF
    7                 + 
  266                   
  267 0CA6:98           	tya
  268 0CA7:A2 04        	ldx #HSFX_CHANNELCOUNT
  269                   
  270 0CA9:CA           .11	  dex
  271 0CAA:30 **        	  bmi .20
  272 0CAC:DD ** **     	  cmp ChannelInUse,x
  273 0CAF:D0 F8        	 bne .11
  274                   
  275 0CB1:20 ** **     	jsr freeChannelX	 ; found channel with desired priori
  276                   
  277                   	END_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0CB4:CE ** **   + 		 DEC	audio_lockout
    3                   		#ELSE
    5                 + 		#ENDIF
    6                 + 
  278 0CB7:18           	clc
  279 0CB8:60           	rts
  280                   
  281                   .20	END_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0CB9:CE ** **   + 		 DEC	audio_lockout
    3                   		#ELSE
    5                 + 		#ENDIF
    6                 + 
  282 0CBC:38           	sec
  283 0CBD:60           	rts
  284                   
  285                   
  286                   
  287 0CBE:             FreeAudio
  288                   * ====================================================
  289                   * This routine is called to free an audio channel that
  290                   * using AllocAudio or GrabAudio.  It's used also by th
  291                   * free up the channel at the end of a note.
  292                   *
  293                   * Call with the channel number that you want to free i
  294                   *
  295                   * On return:
  296                   *    carry wil be clear, which equals success
  297                   
  298      FALSE         #IFDEF SOUND_DEBUG
  303                    #ENDIF
  304                   
  305                   
  306                   	START_DISABLE	; kill sound IRQs
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0CBE:EE ** **   + 		 INC	audio_lockout
    3                   		#ELSE
    6                 + 		#ENDIF
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   33
                        6502:src/hsfx.src               18:23:55  

    7                 + 
  307                   
  308 0CC1:20 ** **     	jsr freeChannelX
  309                   
  310                   	END_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0CC4:CE ** **   + 		 DEC	audio_lockout
    3                   		#ELSE
    5                 + 		#ENDIF
    6                 + 
  311 0CC7:18           	clc
  312 0CC8:60           	rts
  313                   
  314                   
  315                   
  316      FALSE         #IFDEF GRABAUDIO_USER
  367                    #ENDIF ; of #IFDEF GRABAUDIO_USER
  368                   
  369                   
  370                   
  371                   * find_lesser_channel and freeChannelX don't affect th
  372                   
  373                   
  374 0CC9:             find_lesser_channel
  375                   * ====================================================
  376                   * The find_lesser_channel routine feels through the pr
  377                   * channels, looking for one that's the most less than 
  378                   * priority of interest.
  379                   *
  380                   * On entry:  the priority to beat is in Y
  381                   * On exit:  The lowest priority channel number is retu
  382                   *	of the channel is less than or equal to request	then
  383                   
  384      TRUE          #IF HSFX_CHANNELCOUNT>1
  385                   
  386 0CC9:5A           	phy
  387                   
  388 0CCA:A2 03        	ldx #HSFX_CHANNELCOUNT-1
  389 0CCC:A0 02        	ldy #HSFX_CHANNELCOUNT-2
  390 0CCE:BD ** **     .40	  lda ChannelInUse,x
  391 0CD1:D9 ** **     	  cmp ChannelInUse,y
  392 0CD4:90 **        	  blt .41		; Branch if x-priority is less than y-prio
  393 0CD6:98           	  tya		; else copy y to x
  394 0CD7:AA           	  tax
  395 0CD8:88           .41	  dey
  396 0CD9:10 F3        	 bpl .40
  397                   
  398 0CDB:68           	pla	
  399                   
  400                    #ELSE
  405                    #ENDIF
  406                   
  407 0CDC:DD ** **     	cmp ChannelInUse,x	; compare with lowest priority cha
  408                   
  409 0CDF:60           	rts
  410                   
  411                   
  412                   
  413 0CE0:             freeChannelX
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   34
                        6502:src/hsfx.src               18:23:55  

  414                   * ====================================================
  415                   * Here, X has the index of the channel to be freed
  416 0CE0:A9 00        	lda #0
  417                   
  418 0CE2:             killChannelX
  419 0CE2:9D ** **     	sta ChannelInUse,x		; either free or grab channel
  420                   
  421 0CE5:9E ** **     	stz launch_channel,x		; make sure we zero launch flag
  422 0CE8:BC ** **     	ldy audio_offsets,x
  423 0CEB:B9 25 FD     	lda AUDIO0+AUD_CONTROL,y
  424 0CEE:29 20        	and #ENABLE_INTEGRATE
  425 0CF0:99 25 FD     	sta AUDIO0+AUD_CONTROL,y	; kill channel
  426 0CF3:D0 **        	bne .90
  427 0CF5:99 22 FD     	sta AUDIO0+AUD_OUTPUT,y	; reset volume (DC bias) if n
  428 0CF8:60           .90	rts
  429                   
  430                   
  431                   
  432                   
  433                   
  434                   
  435                   
  436                   * ====================================================
  437                   * ====                    ============================
  438                   * ====   Interrupt Code   ============================
  439                   * ====                    ============================
  440                   * ====================================================
  441                   
  442                   
  443      FALSE         #IFNDEF hsfxSysCancel
  481                    #ENDIF ; of IFNDEF hsfxSysCancel
  482                   
  483                   
  484                   
  485                   
  486                   
  487 0CF9:             hsfx_driver_grunt
  488                   * ====================================================
  489                   * Here's the actual HSFX interrupt code
  490                   * The audio driver turns itself into "low-priority" in
  491                   * enabling interrupts as soon as it has protected itse
  492                   * reentered.  This will allow more important (especial
  493                   * interrupt routines to wrest control away from audio 
  494                   
  495      FALSE         #IFDEF USER_HSFX
  497                    #ENDIF
  498                   
  499                   * Lay our hands on the hardware of each active channel
  500                   * (although note that this loop won't actually start t
  501                   * for the channel if the timer isn't already running. 
  502                   * in the launch_channel loop below).
  503                   
  504 0CF9:A2 03        	ldx #HSFX_CHANNELCOUNT-1
  505                   
  506 0CFB:BC ** **     .00	  ldy audio_offsets,x
  507 0CFE:BD ** **     	  lda ChannelInUse,x	; Is this an active channel?
  508 0D01:D0 **        	  bne .02
  509 0D03:B9 22 FD     	  lda AUDIO0+AUD_OUTPUT,y	; not active, ramp volume t
  510 0D06:F0 **        	  beq .01
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   35
                        6502:src/hsfx.src               18:23:55  

  511 0D08:10 **        	  bpl .03
  512 0D0A:1A           	  inc a
  513 0D0B:1A           	  inc a
  514 0D0C:3A           .03	  dec a
  515 0D0D:99 22 FD     	  sta AUDIO0+AUD_OUTPUT,y
  516 0D10:80 **        	  bra .01
  517                   
  518 0D12:C9 FF        .02	  cmp #HSFX_NOCHANNEL	; does someone else own this
  519 0D14:F0 **        	  beq .01
  520                   
  521 0D16:BD ** **     .10	  lda volumeh,x
  522 0D19:99 20 FD     	  sta AUDIO0+AUD_VOLCNTRL,y	; Volume
  523                   
  524 0D1C:BD ** **     	  lda preload_temp,x
  525 0D1F:99 24 FD     	  sta AUDIO0+AUD_BACKUP,y	; Frequency lsb
  526                   
  527 0D22:BD ** **     	  lda data_temp,x
  528 0D25:99 21 FD     	  sta AUDIO0+AUD_FEEDBACK,y	; Update feedback
  529                   
  530 0D28:BD ** **     	  lda flagsl,x
  531 0D2B:29 04        	  and #SHIFT_ALWAYS		; Store shifter value always?
  532 0D2D:D0 **        	  bne .20			; Branch if yes
  533 0D2F:1E ** **     	  asl shift_flag,x		; Store new shifter this time onl
  534 0D32:90 **        	  bcc .22			; Branch if no
  535                   
  536 0D34:B9 27 FD     .20	  lda AUDIO0+AUD_OTHER,y	; Do masking as needed
  537 0D37:29 0F        	  and #$f
  538 0D39:1D ** **     	  ora shift_temp,x
  539 0D3C:99 27 FD     	  sta AUDIO0+AUD_OTHER,y
  540                   
  541 0D3F:BD ** **     	  lda shiftl,x
  542 0D42:99 23 FD     	  sta AUDIO0+AUD_SHIFT,y
  543                   
  544 0D45:B9 25 FD     .22	  lda AUDIO0+AUD_CONTROL,y	; patch in new control 
  545 0D48:29 58        	  and #ENABLE_COUNT+ENABLE_RELOAD+RESET_DONE
  546 0D4A:1D ** **     	  ora clock_temp,x
  547 0D4D:99 25 FD     	  sta AUDIO0+AUD_CONTROL,y
  548                   
  549 0D50:CA           .01	  dex
  550 0D51:10 A8        	 bpl .00
  551                   
  552                   ;	jmp launch_channels		; fall through
  553                   
  554                   
  555                   * If two notes start with the same frequency they shou
  556                   * at very close to the same time to prevent them from 
  557                   * 180 degrees out of phase with each other.  Being out
  558                   * them to cancel each other out; we know this from exp
  559                   * notes should be launched as close together as possib
  560                   * avoid the out-of-phase cancellation problem.  This l
  561                   * and the overhead of the additional loop is well wort
  562                   
  563 0D53:             launch_channels
  564 0D53:78           	sei
  565 0D54:A2 03        	ldx #HSFX_CHANNELCOUNT-1
  566                   
  567 0D56:             launch_next_channel
  568 0D56:BD ** **     .00	  lda launch_channel,x		; Launch this channel?
  569 0D59:F0 **        	  beq .01			; Branch if not
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   36
                        6502:src/hsfx.src               18:23:55  

  570 0D5B:9E ** **     	  stz launch_channel,x		; finished launching
  571                   
  572 0D5E:BC ** **     	  ldy audio_offsets,x
  573 0D61:B9 24 FD     	  lda AUDIO0+AUD_BACKUP,y	; Frequency lsb
  574 0D64:99 26 FD     	  sta AUDIO0+AUD_COUNTER,y	; Copy prevents phase erro
  575                   
  576 0D67:B9 25 FD     	  lda AUDIO0+AUD_CONTROL,y	; Start audio timer
  577 0D6A:09 18        	  ora #ENABLE_RELOAD+ENABLE_COUNT
  578 0D6C:99 25 FD     	  sta AUDIO0+AUD_CONTROL,y
  579                   
  580 0D6F:CA           .01	  dex
  581 0D70:10 E4        	 bpl .00
  582                   
  583                   * Advance the HSFX values of each active channel
  584                   
  585 0D72:             advance_channels
  586 0D72:58           	cli
  587 0D73:A2 03        	ldx #HSFX_CHANNELCOUNT-1
  588                   
  589 0D75:BD ** **     .00	  lda ChannelInUse,x	; Is this an active channel?
  590 0D78:F0 **        	  beq .01		; skip if not
  591 0D7A:C9 FF        	  cmp #HSFX_NOCHANNEL	; do we own this channel?
  592 0D7C:F0 **        	  beq .01
  593 0D7E:BD ** **     	  lda current_framel,x	; Do we match next key frame e
  594 0D81:DD ** **     	  cmp next_keyframel,x
  595 0D84:D0 **        	  bne .10		; ... no, do interpolation only
  596 0D86:BD ** **     	  lda current_frameh,x
  597 0D89:DD ** **     	  cmp next_keyframeh,x
  598 0D8C:D0 **        	  bne .10		; ... no, do interpolation only
  599 0D8E:20 ** **     	  jsr update_frame	; It's time to do something differ
  600 0D91:80 **        	  bra .20		; First time, don't interpolate
  601                   
  602                   * Add the interpolators to the accumulators
  603                   
  604 0D93:DA           .10	   phx
  605                   
  606 0D94:18           .11	    clc
  607 0D95:BD ** **     	    lda freq_interpl,x
  608 0D98:7D ** **     	    adc freql,x
  609 0D9B:9D ** **     	    sta freql,x
  610 0D9E:BD ** **     	    lda freq_interph,x
  611 0DA1:7D ** **     	    adc freqh,x
  612 0DA4:9D ** **     	    sta freqh,x
  613                   
  614                   	    ; Bump x to next accumulator-interpolator pair
  615                   
  616      TRUE          #IF HSFX_REGSIZE*HSFX_CHANNELCOUNT > 4
  617 0DA7:8A           	    txa
  618 0DA8:18           	    clc
  619 0DA9:69 08        	    adc #HSFX_REGSIZE*HSFX_CHANNELCOUNT
  620 0DAB:AA           	    tax
  621                    #ELSE
  625                    #ENDIF
  626                   
  627                   ; Has index overshot into accumulator-interpolator pai
  628 0DAC:E0 20        	    cpx #HSFX_CHANNELCOUNT*HSFX_REGSIZE*HSFX_ACCUMCOU
  629 0DAE:90 E4        	    bcc .11		; Branch if not
  630 0DB0:FA           	   plx
  631                   
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   37
                        6502:src/hsfx.src               18:23:55  

  632 0DB1:20 ** **     .20	  jsr calc_next_audio	; Prepare data for hardware 
  633                   
  634 0DB4:CA           .01	  dex
  635 0DB5:10 BE        	 bpl .00
  636                   
  637 0DB7:60           	rts
  638                   
  639                   
  640                   
  641                   
  642 0DB8:             update_frame
  643                   * ====================================================
  644                   * Updates an HSFX channel's arrays based on the keyfra
  645                   * pointed to by hsfx_basel,h.
  646                   *
  647                   * On entry:
  648                   *   x = HSFX channel number
  649                   *   hsfx_basel,x points to low flag byte of current fr
  650                   *
  651                   * On exit:
  652                   *   accumulators & interpolators pre-loaded
  653                   *   next_keyframel,h set to frame number for next keyf
  654                   *   hsfx_basel,x points to low flag byte of next frame
  655                   *   This routine trashes A and Y, leaves X intact
  656                   
  657 0DB8:BD ** **     	lda hsfx_basel,x	; Set up indirect pointer
  658 0DBB:85 35        	sta audio_ptr
  659 0DBD:BD ** **     	lda hsfx_baseh,x
  660 0DC0:85 36        	sta audio_ptr+1
  661 0DC2:             loop_frame
  662 0DC2:A0 01        	  ldy #1
  663                   
  664 0DC4:B2 35        	  lda (audio_ptr)	; this is where current_frame gets 
  665 0DC6:9D ** **     	  sta current_framel,x	; when a sound is started.
  666 0DC9:B1 35        	  lda (audio_ptr),y
  667 0DCB:9D ** **     	  sta current_frameh,x
  668                   
  669 0DCE:C8           	  iny
  670 0DCF:B1 35        	  lda (audio_ptr),y	; Find out what to do this time
  671 0DD1:9D ** **     	  sta flagsl,x
  672 0DD4:C8           	  iny
  673 0DD5:B1 35        	  lda (audio_ptr),y
  674 0DD7:9D ** **     	  sta flagsh,x
  675 0DDA:C8           	  iny
  676                   
  677 0DDB:0E ** **     	  asl top_of_loop0	; Returning to the top of a loop?
  678 0DDE:B0 **        	  bcs stuff0		; Yes, don't reload count byte
  679 0DE0:BD ** **     	  lda flagsh,x
  680 0DE3:29 40        	  and #>NEXT0		; At the bottom of an inner loop?
  681 0DE5:F0 **        	  beq next0_done	; Branch if not
  682 0DE7:BD ** **     	  lda loop_count0,x	; Infinite loop?
  683 0DEA:F0 **        	  beq infinite0		; Yes, don't count
  684 0DEC:DE ** **     	  dec loop_count0,x	; Not infinite, so are we done?
  685 0DEF:F0 **        	  beq next0_done	; Branch if yes.
  686 0DF1:             infinite0
  687 0DF1:BD ** **     	  lda loop_adrl0,x	; Reload pointer to top of loop
  688 0DF4:85 35        	  sta audio_ptr
  689 0DF6:BD ** **     	  lda loop_adrh0,x
  690 0DF9:85 36        	  sta audio_ptr+1
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   38
                        6502:src/hsfx.src               18:23:55  

  691 0DFB:A9 80        	  lda #$80		; Set 'skip loading count' flag
  692 0DFD:8D ** **     	  sta top_of_loop0
  693 0E00:80 C0        	 bra loop_frame		; Go do top of loop
  694                   
  695                   
  696 0E02:             next0_done
  697                   
  698 0E02:BD ** **     	  lda flagsh,x
  699 0E05:29 80        	  and #>LOOP0		; Starting an inner loop?
  700 0E07:F0 **        	  beq no_loop0		; Branch if not
  701 0E09:A5 35        	  lda audio_ptr		; else save this table pointer value
  702 0E0B:9D ** **     	  sta loop_adrl0,x
  703 0E0E:A5 36        	  lda audio_ptr+1
  704 0E10:9D ** **     	  sta loop_adrh0,x
  705 0E13:B1 35        	  lda (audio_ptr),y	; Get # of loops to do
  706 0E15:9D ** **     	  sta loop_count0,x
  707 0E18:             stuff0
  708 0E18:C8           	  iny
  709 0E19:             no_loop0
  710                   
  711 0E19:0E ** **     	  asl top_of_loop1	; Returning to the top of a loop?
  712 0E1C:B0 **        	  bcs stuff1		; Yes, don't reload count byte
  713 0E1E:BD ** **     	  lda flagsh,x
  714 0E21:29 10        	  and #>NEXT1		; At the bottom of an outer loop?
  715 0E23:F0 **        	  beq next1_done	; Branch if not
  716 0E25:BD ** **     	  lda loop_count1,x	; Infinite loop?
  717 0E28:F0 **        	  beq infinite1		; Yes, so don't count
  718 0E2A:DE ** **     	  dec loop_count1,x	; Not infinite, so are we done?
  719 0E2D:F0 **        	  beq next1_done	; Branch if yes
  720 0E2F:             infinite1
  721 0E2F:BD ** **     	  lda loop_adrl1,x	; Reload pointer to top of loop
  722 0E32:85 35        	  sta audio_ptr
  723 0E34:BD ** **     	  lda loop_adrh1,x
  724 0E37:85 36        	  sta audio_ptr+1
  725 0E39:A9 80        	  lda #$80		; Set 'skip loading count' flag
  726 0E3B:8D ** **     	  sta top_of_loop1
  727 0E3E:4C C2 0D     	 jmp loop_frame		; Go do top of loop
  728                   
  729                   
  730 0E41:             next1_done
  731 0E41:BD ** **     	lda flagsh,x
  732 0E44:29 20        	and #>LOOP1		; Are we starting an outer loop?
  733 0E46:F0 **        	beq no_loop1		; Branch if not
  734 0E48:A5 35        	lda audio_ptr		; Save this table pointer value
  735 0E4A:9D ** **     	sta loop_adrl1,x
  736 0E4D:A5 36        	lda audio_ptr+1
  737 0E4F:9D ** **     	sta loop_adrh1,x
  738 0E52:B1 35        	lda (audio_ptr),y	; Get # of loops to do
  739 0E54:9D ** **     	sta loop_count1,x
  740 0E57:             stuff1
  741 0E57:C8           	iny
  742                   
  743 0E58:             no_loop1		; now load appropriate accumulator/interpola
  744                   
  745                   			; The following piece of code takes the center 8 bi
  746                   			; from the middle of flagsl,h and puts them in orde
  747                   			; into hsfx_temp
  748 0E58:BD ** **     	lda flagsl,x	; Get a temporary copy of this channel's
  749 0E5B:0A           	asl a
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   39
                        6502:src/hsfx.src               18:23:55  

  750 0E5C:5D ** **     	eor flagsh,x	; smush together upper flagsl bits + low
  751 0E5F:29 E0        	and #$e0
  752 0E61:5D ** **     	eor flagsh,x
  753 0E64:2A           	rol a		; bring flagsh bits to the top
  754 0E65:2A           	rol a
  755 0E66:2A           	rol a
  756 0E67:2A           	rol a
  757 0E68:85 37        	sta hsfx_temp
  758                   
  759 0E6A:DA           	 phx		; Stash the channel number
  760                   
  761                   			; NOTE: the BPL at top of the loop depends on the
  762                   			; ROL instruction above, and the ASL below
  763 0E6B:10 **        .22	    bpl .33		; copy key frame data for each flag b
  764 0E6D:B1 35        	    lda (audio_ptr),y	; get new value
  765 0E6F:9D ** **     	    sta freql,x		; this presumes specific array order
  766 0E72:C8           	    iny
  767 0E73:B1 35        	    lda (audio_ptr),y
  768 0E75:9D ** **     	    sta freqh,x
  769 0E78:C8           	    iny
  770 0E79:             .33
  771      TRUE          #IF HSFX_REGSIZE*HSFX_CHANNELCOUNT > 4
  772 0E79:18           	    clc
  773 0E7A:8A           	    txa	 ; Offset X to next accumulator/interpolator 
  774 0E7B:69 08        	    adc #HSFX_REGSIZE*HSFX_CHANNELCOUNT
  775 0E7D:AA           	    tax
  776                    #ELSE
  780                    #ENDIF
  781 0E7E:06 37        	    asl hsfx_temp	; stop when no more flags are set
  782 0E80:D0 E9        	   bne .22
  783                   
  784 0E82:FA           	 plx	; Restore the channel number
  785                   
  786 0E83:BD ** **     	lda flagsh,x
  787 0E86:29 04        	and #>SHIFT_ACCUM	; New absolute_shifter?
  788 0E88:F0 **        	beq .55		;no
  789 0E8A:A9 80        	lda #$80
  790 0E8C:9D ** **     .55	sta shift_flag,x	; Set 'store once' flag
  791                   
  792 0E8F:BD ** **     	lda flagsl,x
  793 0E92:29 08        	and #INTEGRATE		; This is a 'force on/off' flag
  794 0E94:0A           	asl a			; Move into pos for hardware register
  795 0E95:0A           	asl a
  796 0E96:9D ** **     	sta integrate,x
  797                   
  798 0E99:BD ** **     	lda flagsl,x
  799 0E9C:29 01        	and #END_OF_EFFECT	; Are we at end of this effect?
  800 0E9E:D0 **        	bne end_of_effect
  801                   
  802                   	; Advance hsfx_basel,h to point to next key frame ent
  803 0EA0:98           	tya
  804 0EA1:18           	clc
  805 0EA2:65 35        	adc audio_ptr
  806 0EA4:9D ** **     	sta hsfx_basel,x
  807 0EA7:A9 00        	lda #0
  808 0EA9:65 36        	adc audio_ptr+1
  809 0EAB:9D ** **     	sta hsfx_baseh,x
  810                   
  811 0EAE:B1 35        	lda (audio_ptr),y	;get next key frames' frame #
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   40
                        6502:src/hsfx.src               18:23:55  

  812 0EB0:9D ** **     	sta next_keyframel,x
  813 0EB3:C8           	iny
  814 0EB4:B1 35        	lda (audio_ptr),y
  815 0EB6:9D ** **     	sta next_keyframeh,x
  816                   
  817 0EB9:60           	rts			;end of key frame entry
  818                   
  819                   
  820 0EBA:             end_of_effect
  821 0EBA:4C E0 0C     	jmp freeChannelX
  822                   
  823                   
  824                   
  825                   
  826 0EBD:             calc_next_audio
  827                   * ====================================================
  828                   * This routuine converts the channel's accumulators in
  829                   * designed for easy hardware loading.  This is done be
  830                   * audio frame, so that at the start of the audio frame
  831                   * values can be picked up and jammed into the audio re
  832                   * delay, thereby creating purer sounds.
  833                   *
  834                   * This routine trashes A and Y, leaves X intact
  835                   
  836                   
  837                   * Select the clock by normalizing the frequency accumu
  838                   * (the algorithm and proof is actually a rather hairy 
  839 0EBD:A0 07        	ldy #7
  840 0EBF:BD ** **     	lda freql,x
  841 0EC2:85 37        	sta hsfx_temp
  842 0EC4:BD ** **     	lda freqh,x
  843                   
  844 0EC7:06 37        .00	  asl hsfx_temp
  845 0EC9:2A           	  rol a
  846 0ECA:88           	  dey
  847 0ECB:B0 **        	  bcs .01
  848 0ECD:D0 F8        	 bne .00
  849                   
  850 0ECF:6A           .01	ror a
  851                   
  852 0ED0:             end_freq
  853 0ED0:9D ** **     	sta preload_temp,x
  854 0ED3:98           	tya
  855 0ED4:9D ** **     	sta clock_temp,x
  856                   
  857                   
  858                   * Preset the 12-bit shifter values
  859 0ED7:BD ** **     	lda shifth,x
  860 0EDA:0A           	asl a
  861 0EDB:0A           	asl a
  862 0EDC:0A           	asl a
  863 0EDD:0A           	asl a
  864 0EDE:9D ** **     	sta shift_temp,x
  865                   
  866                   * Preset the lower 8 feedback enables
  867 0EE1:BD ** **     	lda feedbackl,x
  868 0EE4:0A           	asl
  869 0EE5:85 37        	sta hsfx_temp
  870 0EE7:BD ** **     	lda feedbackh,x
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   41
                        6502:src/hsfx.src               18:23:55  

  871 0EEA:2A           	rol a
  872 0EEB:06 37        	asl hsfx_temp
  873 0EED:2A           	rol a
  874 0EEE:06 37        	asl hsfx_temp
  875 0EF0:2A           	rol a
  876 0EF1:06 37        	asl hsfx_temp
  877 0EF3:2A           	rol a
  878 0EF4:C9 80        	cmp #$80		; sec if high bit set
  879 0EF6:5D ** **     	eor feedbackh,x		; merge in top two bits of feedbackh
  880 0EF9:29 3F        	and #$3f
  881 0EFB:5D ** **     	eor feedbackh,x
  882 0EFE:9D ** **     	sta data_temp,x
  883                   
  884                   * Grab the other feedback enable, or'ing it into the o
  885 0F01:A9 00        	lda #0
  886 0F03:6A           	ror a			; bring carry into top bit
  887 0F04:1D ** **     	ora integrate,x		; OR with integration
  888 0F07:1D ** **     	ora clock_temp,x	; OR in with clock
  889 0F0A:9D ** **     	sta clock_temp,x
  890                   
  891                   
  892                   * Increment this sound effect's current frame counter
  893 0F0D:FE ** **     	inc current_framel,x
  894 0F10:D0 **        	bne .11
  895 0F12:FE ** **     	inc current_frameh,x
  896                   
  897 0F15:60           .11	rts
  898                   
  899                   
  900                   
  901                   
  902                   
  903                   * === ================================================
  904                   * ===               ==================================
  905                   * ===      Data     ==================================
  906                   * ===               ==================================
  907                   * === ================================================
  908                   
  909                   
  910 0F16:00 08 10 18  audio_offsets	.by $00,$08,$10,$18 ; Offsets into the h
  910                   
  911                   
  912                   
 1345                   	.in 6502:src/hmusic.src
    1                   ; Tue Sep 18 17:44:11 1990
    2                   * == hmusic.src ======================================
    3                   *
    4                   * Handy Music Driver  --  Handy Software
    5                   *
    6                   * Confidential and Proprietary
    7                   * Copyright (C) 1989, Epyx, Inc.
    8                   *
    9                   * Date		Name		Description
   10                   * ---------	--------------	---------------------------
   11                   * 24-Apr-90	SHL		PlayMusic and AddMusic now kill any n
   12                   *				sound effects played by previous song
   13                   *				Minor code tightening
   14                   *				ring0_flag and ring1_flag arrays replaced by
   15                   *				ring_flag array
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   42
                        6502:src/hmusic.src             18:23:55  

   16                   * 18-Apr-90	SHL		InitHMusic now zeroes all HMUSIC vari
   17                   *				Rests now don't play a 1MHz tone
   18                   *				HMUSIC_DEFAULT_PRIORITY added to give music
   19                   *				a default priority level
   20                   * 26-Mar-90	SHL		Removed PHA, PHX from hmusic_driver
   21                   *				Changed driver exit to match new IRQ handler
   22                   * 6 Oct 89	SHL		Modified driver to catch dropped frame
   23                   * 11 Sept 89	SJ		Used song header offset definitions
   24                   *				Fixed variable initialization and moved vars
   25                   *				out of ROM
   26                   *				Kill a voice's note only if it has a defined
   27                   *				HSFX channel
   28                   *				Fixed handling of muted state
   29                   * 5 Sept 89	Stephen Jungels	Changed most public calls 
   30                   *				audio interrupts, not all interrupts
   31                   * 11 Aug 89	-RJ		Restore I flag at end of int. driver 
   32                   *				clearing audio_interruptus
   33                   * 13 Jul 89	RG		Added PLP to StartVoice return
   34                   * 16 Jun 89	-RJ		Reset Mute_flag in InitHMusic
   35                   *  8 Jun 89	Greg Omi	Added Mute function
   36                   *  1 Jun 89	Steve Landrum	Changed HMUSIC call into HSF
   37                   *				to hsfx_driver_grunt
   38                   * 31 May 89	-RJ		Removed ChannelInUse from this file
   39                   *  1 May 89	-RJ		Changed all IntTable references to sy
   40                   *				which is defined now in the sys.mac file
   41                   * 18 Apr 89	-RJ		Added PlayMusic
   42                   * 17 Apr 89	-RJ		Changed AddVoice to StartVoice
   43                   * 11 Apr 89	-RJ		Tightened up ESCAPE code a bit, got r
   44                   *				infinites, using loop count of 0 for same
   45                   *  9 Apr 89	-RJ		StopMusic and StopVoice disable inter
   46                   *				Added lots more comments while bug-hunting,
   47                   *				fixed many little bugs while bug-hunting.
   48                   *				skip_inner and _outer now not arrays, and
   49                   *				renamed to did_inner and _outer.  Changed
   50                   *				StopHSFX calls to FreeAudio.  mflagsl,h
   51                   *				now not arrays.  ignore_RING now not array and
   52                   *				renamed to did_ring_end
   53                   *  7 Apr 89	-RJ		Put in a deadbolt JSR StopHSFX once a
   54                   *				supposed to end.  Solves gating overshot errors
   55                   *  6 Apr 89	-RJ		The setNewVoice routine nows clears s
   56                   *				ring arrays for that voice.  Also, both
   57                   *				ring_return levels now share common code.
   58                   *  5 Apr 89	-RJ		Added audio_interruptus, now music in
   59                   *				code safely clears interrupt disable while
   60                   *				it's working, allowing other interrupts to
   61                   *				run without risking reentrancy
   62                   *  4 Apr 89	-RJ		InitMusic zeroes out VoiceInUse array
   63                   *  3 Apr 89	-RJ		Disable interrupts before setting Use
   64                   * 25 Mar 89	-RJ		Made mods too numerous to itemize.  M
   65                   *				significant:  StartMusic calls AddVoice;
   66                   *				AddVoice expects arg of song table voice index;
   67                   *				ClearUser calls into SetUser; StopMusic calls
   68                   *				StopVoice.  Altogether about 200 bytes smaller.
   69                   * 24 Mar 89	-RJ		Made countless changes, including:  r
   70                   *				technique for calling user programs, grouping
   71                   *				all reassignments of audioptr at top of mloop
   72                   * 23 Mar 89	-RJ		Changed AddVoice routine to expect th
   73                   *				voice number in A
   74                   * 22 Mar 89	-RJ		Changed name of voice_in_use to Voice
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   43
                        6502:src/hmusic.src             18:23:55  

   75                   * 21 Mar 89	-RJ Mical-	Added comments, name changes, t
   76                   *				in preparation for first release
   77                   * 24 Jan 89	RG Goudy	Created this file!
   78                   *
   79                   *=====================================================
   80                   
   81                   
   82                   ; Changes to do:
   83                   
   84                   
   85                   ; Major Bugs
   86                   
   87                   ; hspl dumps a direct copy of the muslist into the voi
   88                   ; it also sets a field to the total number of voices a
   89                   ; need.  HSPL should sort the voice offsets so that ma
   90                   ; come first, and the field should be set to the numbe
   91                   ; which we do need to know.
   92                   
   93                   ;The ADSR keyframes for each channel don't have to eat
   94                   ;Write a build ADSR routine that fills in the necessar
   95                   ;Define the ADSR keyframe flags using HSFX.i const def
   96                   
   97                   
   98                   		BEGIN_ZPAGE
    1      0F1A       + TEMPORG	  .= *
    2 0F1A:           + 	  .ORG NEXTZPG
    3                 + 
   99 0038:             frequency_ptr	.DS 2
  100 003A:             duration_ptr	.DS 2
  101 003C:             voiceoffsets_ptr .DS 2
  102                   		END_ZPAGE
    1      003E       + NEXTZPG	  .= *
    2      FALSE        	  #IF NEXTZPG > $0100
    4                 + 	  #ENDIF
    5 003E:           + 	  .ORG TEMPORG
    6                 + 
  103                   
  104                   
  105                   
  106 0F1A:             InitHMusic
  107                   * ====================================================
  108                   * Call this routine to initialize the music driver.  T
  109                   * initializes the HSFX driver.
  110                   
  111 0F1A:08           	 php		; Disable IRQs before writing to the vector tab
  112 0F1B:78           	  sei
  113                   
  114 0F1C:20 48 0C     	  jsr InitHSFX				; Init sound effects driver
  115                   
  116 0F1F:A2 **        	  ldx #HMusicVarEnd-HMusicVarStart	; zero all music v
  117 0F21:9E ** **     .10	    stz HMusicVarStart-1,x
  118 0F24:CA           	    dex
  119 0F25:D0 FA        	   bne .10
  120                   
  121 0F27:A9 **        	  lda #<hmusic_driver			; link into IRQ vector table
  122 0F29:8D ** **     	  sta sysIntTable+{AUDIO_TIMER*2}
  123 0F2C:A9 **        	  lda #>hmusic_driver
  124 0F2E:8D ** **     	  sta sysIntTable+{AUDIO_TIMER*2}+1
  125                   
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   44
                        6502:src/hmusic.src             18:23:55  

  126 0F31:28           	 plp
  127                   
  128 0F32:60           	rts
  129                   
  130                   
  131                   
  132 0F33:             PlayMusic
  133                   * ====================================================
  134                   * The PlayMusic routine initializes the specified song
  135                   * pointers to the offsets of the first 4 voices.  Then
  136                   *
  137                   * On entry:  the address of a song table is in A,X (lo
  138                   * On exit:  X has the highest instance number assigned
  139                   *           song doesn't specify any initial voices th
  140                   
  141                   	START_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0F33:EE ** **   + 		 INC	audio_lockout
    3                   		#ELSE
    6                 + 		#ENDIF
    7                 + 
  142                   
  143 0F36:20 ** **     	jsr setUpMusicPtrs
  144                   
  145 0F39:A9 00        	lda #0			; Zero out the 4 voice indices
  146 0F3B:A0 07        	ldy #SONG_STARTUPVOICE3+1
  147 0F3D:91 35        .0a	  sta (audio_ptr),Y
  148 0F3F:88           	  dey
  149 0F40:10 FB        	 bpl .0a
  150                   
  151 0F42:A0 08        	ldy #SONG_MAINVOICES		; Get total number of available
  152 0F44:B1 35        	lda (audio_ptr),Y
  153 0F46:C9 05        	cmp #HMUSIC_CHANNELCOUNT+1
  154 0F48:90 **        	blt .10
  155 0F4A:A9 04        	lda #HMUSIC_CHANNELCOUNT	; Clip to maximum
  156 0F4C:0A           .10	asl				; Turn this into an index for moving
  157 0F4D:3A           	dec				; that many 2-byte offsets
  158 0F4E:A8           	tay
  159 0F4F:B1 3C        .20	  lda (voiceoffsets_ptr),Y	; Copy the first n voic
  160 0F51:91 35        	  sta (audio_ptr),Y		; table's play-voice array
  161 0F53:88           	  dey
  162 0F54:10 F9        	 bpl	.20
  163                   
  164 0F56:80 **        	bra addMusicEntry	; branch into middle of AddMusic
  165                   
  166                   
  167                   
  168 0F58:             AddMusic
  169                   * ====================================================
  170                   * The AddMusic routine performs two functions:  it ins
  171                   * song data table into the hmusic driver, and if the s
  172                   * any voices that should start playing immediately (ty
  173                   * AddMusic launches those voices.
  174                   *
  175                   * Each voice launched by AddMusic (if any) gets a uniq
  176                   * in ascending order, starting from 0.
  177                   *
  178                   * If another song is playing when this routine is call
  179                   * the previous song are completely removed.
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   45
                        6502:src/hmusic.src             18:23:55  

  180                   *
  181                   * This routine sets up the hmusic variable hmusic_base
  182                   * of the hmusic routines and interrupt code to referen
  183                   *
  184                   * On entry:  the address of a song table is in A,X (lo
  185                   * On exit:  X has the highest instance number assigned
  186                   *           song doesn't specify any initial voices th
  187                   
  188                   	START_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0F58:EE ** **   + 		 INC	audio_lockout
    3                   		#ELSE
    6                 + 		#ENDIF
    7                 + 
  189                   
  190 0F5B:20 ** **     	jsr setUpMusicPtrs
  191                   
  192 0F5E:             addMusicEntry
  193                   
  194 0F5E:9C ** **     	stz instance		; Unique ID for referencing voices
  195                   
  196 0F61:A9 6A        	lda #HMUSIC_DEFAULT_PRIORITY+{{HMUSIC_CHANNELCOUNT-1}
  197 0F63:8D ** **     	sta voice0		; initialize default priorities
  198      TRUE          #IF HMUSIC_CHANNELCOUNT>1
  199 0F66:A9 68        	lda #HMUSIC_DEFAULT_PRIORITY+{{HMUSIC_CHANNELCOUNT-2}
  200 0F68:8D ** **     	sta voice1
  201                    #ENDIF
  202      TRUE          #IF HMUSIC_CHANNELCOUNT>2
  203 0F6B:A9 66        	lda #HMUSIC_DEFAULT_PRIORITY+{{HMUSIC_CHANNELCOUNT-3}
  204 0F6D:8D ** **     	sta voice2
  205                    #ENDIF
  206      TRUE          #IF HMUSIC_CHANNELCOUNT>3
  207 0F70:A9 64        	lda #HMUSIC_DEFAULT_PRIORITY+{{HMUSIC_CHANNELCOUNT-4}
  208 0F72:8D ** **     	sta voice3
  209                    #ENDIF
  210                   
  211                   	;-- For each of the initial voices (if any), load up 
  212                   	;-- hmusic voice arrays using the song table data
  213                   
  214 0F75:A2 03        	ldx #HMUSIC_CHANNELCOUNT-1	; Voice index
  215 0F77:A0 00        	ldy #0				; Song table index
  216                   
  217 0F79:9E ** **     .05	  stz VoiceInUse,x		; Start by presuming no voice
  218 0F7C:9E ** **     	  stz SFX_to_cancel,x		; Wipe out MSFX calls
  219 0F7F:A9 04        	  lda #HSFX_CHANNELCOUNT	; Set this voice to no chann
  220 0F81:9D ** **     	  sta VoiceHSFXChannel,x
  221                   
  222 0F84:B1 35        	  lda (audio_ptr),y		; Get offset of individual voice
  223 0F86:C8           	  iny
  224 0F87:9D ** **     	  sta voicedata_ptrl,x
  225 0F8A:B1 35        	  lda (audio_ptr),y
  226 0F8C:C8           	  iny
  227 0F8D:9D ** **     	  sta voicedata_ptrh,x
  228 0F90:1D ** **     	  ora voicedata_ptrl,x	; Was offset zero?
  229 0F93:F0 **        	  beq .09			; If so, voice not specified
  230 0F95:20 ** **     	  jsr setNewVoice		; else set up to launch new voice
  231                   
  232 0F98:CA           .09	  dex		; Next voice
  233 0F99:10 DE        	 bpl .05	; Branch if another to do
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   46
                        6502:src/hmusic.src             18:23:55  

  234                   
  235 0F9B:             voiceReturn
  236 0F9B:AE ** **     	ldx instance		; Return highest number assigned
  237 0F9E:CA           	dex
  238                   
  239                   	END_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0F9F:CE ** **   + 		 DEC	audio_lockout
    3                   		#ELSE
    5                 + 		#ENDIF
    6                 + 
  240                   
  241 0FA2:18           	clc			; Return with success
  242 0FA3:60           	rts
  243                   
  244                   
  245                   
  246                   
  247 0FA4:             setUpMusicPtrs
  248 0FA4:48           	 pha
  249 0FA5:DA           	   phx
  250 0FA6:20 ** **     	    jsr stopAllVoices
  251 0FA9:FA           	   plx
  252 0FAA:68           	 pla
  253                   
  254 0FAB:85 35        	sta audio_ptr		; Set up pointers to copy the voice of
  255 0FAD:8D ** **     	sta hmusic_base
  256 0FB0:86 36        	stx audio_ptr+1
  257 0FB2:8E ** **     	stx hmusic_base+1
  258                   
  259 0FB5:18           	clc
  260 0FB6:69 09        	adc #<SONG_VOICEFX_OFFSETS
  261 0FB8:85 3C        	sta voiceoffsets_ptr
  262 0FBA:8A           	txa
  263 0FBB:69 00        	adc #>SONG_VOICEFX_OFFSETS
  264 0FBD:85 3D        	sta voiceoffsets_ptr+1
  265                   
  266 0FBF:60           	rts
  267                   
  268                   
  269                   
  270                   
  271                   
  272 0FC0:             setNewVoice
  273                   * ====================================================
  274                   * Set up to launch a new voice.
  275                   *
  276                   * On entry:
  277                   *    - voicedata_ptrl,h has the song table offset of t
  278                   *    - X has the voice channel number
  279                   * On exit:
  280                   *    - A is trashed
  281                   *    - voicedata_ptrl,h points to the actual address o
  282                   *    - Everything is set up for hmusic to launch the n
  283                   
  284                   
  285 0FC0:18           	clc		; Turn the voice data offset into a voice data p
  286 0FC1:AD ** **     	lda hmusic_base
  287 0FC4:7D ** **     	adc voicedata_ptrl,x
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   47
                        6502:src/hmusic.src             18:23:55  

  288 0FC7:9D ** **     	sta voicedata_ptrl,x
  289 0FCA:AD ** **     	lda hmusic_base+1
  290 0FCD:7D ** **     	adc voicedata_ptrh,x
  291 0FD0:9D ** **     	sta voicedata_ptrh,x
  292                   
  293 0FD3:FE ** **     	inc VoiceInUse,x	; set VoiceInUse non-zero
  294                   
  295 0FD6:9E ** **     	stz voice_endframel,x	; Set voice frame to 0, frames 
  296 0FD9:9E ** **     	stz voice_endframeh,x	;  Fool the hmusic driver into 
  297 0FDC:A9 FF        	lda #$ff		;   it's time to load the "next" (actually 
  298 0FDE:9D ** **     	sta frames_alivel,x	;    first) data for this voice
  299 0FE1:9D ** **     	sta frames_aliveh,x
  300                   
  301 0FE4:AD ** **     	lda instance		; This voice gets the next instance num
  302 0FE7:9D ** **     	sta VoiceInstance,x
  303 0FEA:EE ** **     	inc instance		; Bump instance number for next voice
  304                   
  305 0FED:9E ** **     	stz ring_flag,x		; Zero out any ring state
  306                   ;	stz ring1_flag,x
  307                   
  308 0FF0:9E ** **     	stz restore_ds,x	; Zero the decay/sustain restore fla
  309                   
  310 0FF3:             musicReturn			; This RTS is referenced several times
  311 0FF3:60           	rts
  312                   
  313                   
  314                   
  315      FALSE         #IFDEF STARTVOICE_USER
  361                    #ENDIF ; of #IFDEF STARTVOICE_USER
  362                   
  363                   
  364                   
  365                   
  366      TRUE          #IFDEF STOPMUSIC_USER
  367 0FF4:             StopMusic
  368                   * ====================================================
  369                   * StopMusic immediately stops and silences all current
  370                   * voices.
  371                   *
  372                   * After the voices are stopped, the HMUSIC voice chann
  373                   * and the HSFX audio channels used by the voices are a
  374                   *
  375                   * This routine doesn't disturb the song in the hmusic 
  376                   * this routine, subseuent calls to StartVoice can be m
  377                   *
  378                   * Note:  the effects of this routine occur immediately
  379                   * next audio interrupt.
  380                   
  381                   	 START_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0FF4:EE ** **   + 		 INC	audio_lockout
    3                   		#ELSE
    6                 + 		#ENDIF
    7                 + 
  382                   
  383 0FF7:20 ** **     	  jsr stopAllVoices
  384                   
  385                   	 END_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   48
                        6502:src/hmusic.src             18:23:55  

    2 0FFA:CE ** **   + 		 DEC	audio_lockout
    3                   		#ELSE
    5                 + 		#ENDIF
    6                 + 
  386                   
  387 0FFD:60           	rts
  388                    #ENDIF ; of #IFDEF STOPMUSIC_USER
  389                   
  390                   
  391                   
  392 0FFE:             stopAllVoices
  393                   * ====================================================
  394                   * stopAllVoices immediately stops and silences all cur
  395                   * voices.
  396                   *
  397                   * After the voices are stopped, the HMUSIC voice chann
  398                   * and the HSFX audio channels used by the voices are a
  399                   *
  400                   * This routine doesn't disturb the song in the hmusic 
  401                   * this routine, subseuent calls to StartVoice can be m
  402                   *
  403                   * Note:  the effects of this routine occur immediately
  404                   * next audio interrupt.
  405                   
  406 0FFE:A2 03        	ldx #HMUSIC_CHANNELCOUNT-1
  407 1000:DA           .10	   phx
  408 1001:20 ** **     	    jsr stopVoiceX
  409 1004:FA           	   plx
  410 1005:CA           	  dex
  411 1006:10 F8        	 bpl .10
  412                   
  413 1008:60           	rts
  414                   
  415                   
  416      FALSE         #IFDEF STOPVOICE_USER
  450                    #ENDIF ; of #IFDEF STOPVOICE_USER
  451                   
  452                   
  453                   
  454 1009:             stopVoiceX
  455 1009:BD ** **     	lda VoiceInUse,x	; is voice already stopped?
  456 100C:D0 **        	bne .00
  457 100E:60           	rts
  458                   
  459 100F:9E ** **     .00	stz VoiceInUse,x	; Remove from music queue
  460                   
  461 1012:             muteVoiceX
  462 1012:BC ** **     	ldy voice_offsets,x	; Get offset to this voice's data
  463 1015:B9 ** **     	lda voice0,y		; Get the priority of this voice
  464 1018:1D ** **     	ora SFX_to_cancel,x	; or the sound effect being playe
  465 101B:A8           .10	tay
  466 101C:4C A3 0C     	jmp StopHSFX		; Tell HSFX to kill current note/MSFX
  467                   
  468                   
  469                   
  470      FALSE         #IFDEF USERCALLS_USER
  508                    #ENDIF ; of #IFDEF USERCALLS_USER
  509                   
  510                   
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   49
                        6502:src/hmusic.src             18:23:55  

  511                   
  512      TRUE          #IFDEF MUTE_USER
  513 101F:             Mute
  514                   * ====================================================
  515                   * Turns off music but keeps playing silently
  516                   * toggles every time called
  517                   
  518 101F:48           	 pha
  519 1020:AD ** **     	  lda Mute_flag
  520 1023:49 FF        	  eor #$ff
  521 1025:8D ** **     	  sta Mute_flag
  522 1028:F0 **        	  beq .30
  523 102A:DA           	   phx
  524 102B:5A           	     phy
  525 102C:A2 03        	      ldx #HMUSIC_CHANNELCOUNT-1
  526                   
  527 102E:BC ** **     .10		ldy VoiceInUse,x	; Is this voice active?
  528 1031:F0 **        		beq .20			; Branch if not active
  529 1033:DA           		 phx
  530 1034:20 12 10     		  jsr muteVoiceX	; Tell HSFX to kill current note/MS
  531 1037:FA           		 plx
  532 1038:CA           .20		dex			; Try next voice
  533 1039:10 F3        	       bpl .10			; Branch if there's more to try
  534                   
  535 103B:7A           	     ply
  536 103C:FA           	   plx
  537                   
  538 103D:68           .30	 pla
  539 103E:60           	rts
  540                   
  541                    #ENDIF	; of #IFDEF MUTE_USER
  542                   
  543                   
  544                   
  545                   * === ================================================
  546                   * ===                     ============================
  547                   * ===    Interrupt Code   ============================
  548                   * ===                     ============================
  549                   * === ================================================
  550                   
  551                   
  552                   
  553 103F:             hmusic_driver
  554                   * ====================================================
  555                   * Here's the hmusic driver interrupt code
  556                   * If you *have* to understand what this code does, goo
  557                   *
  558                   * The audio driver turns itself into "low-priority" in
  559                   * enabling interrupts as soon as it has protected itse
  560                   * reentered.  This will allow more important (especial
  561                   * interrupt routines to wrest control away from audio 
  562                   
  563                   	;-- Test if this is a music interrupt re-entering
  564                   	;-- If audio_interruptus is zero, this is a top-level
  565                   	;-- into the interrupt code so it's safe to proceed. 
  566                   	;-- if audio_interruptus isn't zero we're re-entering
  567                   	;-- got so pushed so deep in the queue that another a
  568                   	;-- interrupt occurred!  It's not safe to re-enter, s
  569                   	;-- (causing the audio to skip a beat, it's true).
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   50
                        6502:src/hmusic.src             18:23:55  

  570 103F:EE ** **     	inc audio_dropout	; count frame
  571 1042:AD ** **     	lda audio_lockout	; are we being locked out?
  572 1045:D0 **        	bne .12
  573 1047:AD ** **     	lda audio_interruptus	; are we interrupting ourself?
  574 104A:F0 **        	beq .10
  575 104C:EE ** **     .12	inc audio_dropout	; count frames we've dropped
  576                   
  577 104F:FA           	plx			; exit IRQ
  578 1050:68           	pla
  579 1051:40           	rti
  580                   
  581 1052:EE ** **     .10	inc audio_interruptus	; Mark that we are here
  582 1055:58           	cli			; and let other interrupts run
  583                   
  584 1056:             hmusic_interrupt_core
  585 1056:5A           	 phy
  586                   
  587      FALSE         #IFDEF	USERCALLS_USER
  589                    #ENDIF
  590                   
  591                   * For each active voice, check if we need to start the
  592                   * note's volume has fallen to zero
  593                   
  594 1057:A2 03        	  ldx #HMUSIC_CHANNELCOUNT-1	; Loop for voices
  595 1059:             voiceLoop
  596 1059:BD ** **     	    lda VoiceInUse,x	; Voice active?
  597 105C:F0 **        	    beq voiceLoopEnd	; Branch if not
  598                   
  599 105E:FE ** **     	    inc frames_alivel,x	; increment number of frames 
  600 1061:D0 **        	    bne .18
  601 1063:FE ** **     	    inc frames_aliveh,x
  602                   
  603 1066:BD ** **     .18	    lda frames_alivel,x		; is it time to get a new
  604 1069:DD ** **     	    cmp voice_endframel,x
  605 106C:D0 **        	    bne .17
  606 106E:BD ** **     	    lda frames_aliveh,x
  607 1071:DD ** **     	    cmp voice_endframeh,x
  608 1074:D0 **        	    bne .17
  609                   
  610 1076:BD ** **     	    lda VoiceHSFXChannel,x	; Get this voice's HSFX ch
  611 1079:C9 04        	    cmp #HSFX_CHANNELCOUNT	; does this voice have a c
  612 107B:B0 **        	    bcs .cd
  613 107D:DA           	     phx
  614 107E:BC ** **     	      ldy voice_offsets,x	; Get offset to this voice'
  615 1081:AA           	      tax
  616 1082:B9 ** **     	      lda voice0,y		; See if this voice still has cha
  617 1085:DD ** **     	      cmp ChannelInUse,x
  618 1088:D0 **        	      bne .ce
  619 108A:20 E0 0C     	      jsr freeChannelX		; free the channel
  620 108D:FA           .ce	     plx
  621                   
  622 108E:20 ** **     .cd	    jsr getNextData	; Load next note data
  623 1091:9E ** **     	    stz frames_alivel,x	; Reset the number of frames 
  624 1094:9E ** **     	    stz frames_aliveh,x
  625 1097:80 **        	    bra voiceLoopEnd
  626                   
  627 1099:BC ** **     .17	    ldy voice_offsets,x		; Get offset of voice's k
  628 109C:BD ** **     	    lda frames_alivel,x		; Are we in release stage?
  629 109F:D9 ** **     	    cmp releaseframe_v0,y
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   51
                        6502:src/hmusic.src             18:23:55  

  630 10A2:BD ** **     	    lda frames_aliveh,x
  631 10A5:F9 ** **     	    sbc releaseframe_v0+1,y
  632 10A8:90 **        	    bcc voiceLoopEnd
  633                   
  634 10AA:BD ** **     .22	    lda VoiceHSFXChannel,x	; Get HSFX channel of t
  635 10AD:C9 04        	    cmp #HSFX_CHANNELCOUNT	; ignore if this voice has
  636 10AF:B0 **        	    bcs voiceLoopEnd
  637 10B1:DA           	     phx
  638 10B2:AA           	      tax
  639 10B3:B9 ** **     	      lda voice0,y		; See if we still own channel
  640 10B6:DD ** **     	      cmp ChannelInUse,x
  641 10B9:D0 **        	      bne .29
  642 10BB:BD ** **     	      lda volumel,x		; check for volume close to zero
  643 10BE:D9 ** **     	      cmp releaseframe_v0+8,y
  644 10C1:BD ** **     	      lda volumeh,x
  645 10C4:F0 **        	      beq .27
  646 10C6:F9 ** **     	      sbc releaseframe_v0+9,y
  647 10C9:90 **        	      bcc .29
  648                   
  649 10CB:20 E0 0C     .27	      jsr freeChannelX		; close enough to zero, ki
  650                   
  651 10CE:FA           .29	     plx
  652                   
  653 10CF:             voiceLoopEnd	;-- Process the next channel
  654 10CF:CA           	    dex
  655 10D0:10 87        	   bpl voiceLoop
  656                   
  657 10D2:             .10
  658                   * Check each of the voices.  If it's at the start of a
  659                   * launch the note's pre-calculated HSFX sound effect k
  660                   
  661 10D2:A2 03        	  ldx #HMUSIC_CHANNELCOUNT-1
  662 10D4:             voiceLaunchLoop
  663 10D4:1E ** **     	    asl new_note,x	; Top bit of new_note set?
  664 10D7:90 **        	    bcc .c0		; Branch if not
  665                   
  666      TRUE          #IFDEF MUTE_USER
  667 10D9:2C ** **     	    bit Mute_flag	; Is the mute flag set?
  668 10DC:30 **        	    bmi .c0		; Branch if negative to mute
  669                    #ENDIF
  670                   
  671 10DE:DA           	     phx		; Launch new keyframe set for new note
  672 10DF:BC ** **     	      ldy voice_offsets,x	; Get offset to this voice'
  673 10E2:B9 ** **     	      lda voice0,y		; Get the priority of this voice
  674 10E5:A8           	      tay			; Copy the priority for StartHSFX
  675                   
  676 10E6:BD ** **     	      lda voice_offsets,x	; Get offset to this voice'
  677 10E9:18           	      clc			; Add address of first keyframe
  678 10EA:69 **        	      adc #<attackframe_v0
  679 10EC:A2 **        	      ldx #>attackframe_v0	; Get high byte into X
  680 10EE:90 **        	      bcc .b8
  681 10F0:E8           	      inx
  682 10F1:20 66 0C     .b8	      jsr StartHSFX		; Start this note "sound effe
  683 10F4:8A           	      txa			; Grab copy of channel
  684 10F5:FA           	     plx
  685 10F6:9D ** **     	    sta VoiceHSFXChannel,x	; Save copy of this voice'
  686                   
  687 10F9:CA           .c0	    dex
  688 10FA:10 D8        	   bpl voiceLaunchLoop
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   52
                        6502:src/hmusic.src             18:23:55  

  689                   
  690                   
  691      FALSE         #IFDEF	USERCALLS_USER
  700                    #ENDIF	; of #IFDEF USERCALLS_USER
  701                   
  702 10FC:20 F9 0C     	  jsr hsfx_driver_grunt	; Call HSFX driver
  703                   
  704 10FF:7A           	 ply
  705                   
  706 1100:CE ** **     	dec audio_dropout	; count off frame
  707 1103:F0 **        	beq .00
  708 1105:4C 56 10     	jmp hmusic_interrupt_core	; catch dropped frames
  709                   
  710 1108:9C ** **     .00	stz audio_interruptus	; reset flag so we know it's
  711 110B:FA           	plx			; exit IRQ
  712 110C:68           	pla
  713 110D:40           	rti
  714                   
  715                   
  716                   
  717 110E:             getNextData
  718                   * ====================================================
  719                   * Load up the data for the voice's next note.  This in
  720                   * or more CFW's until an honest note is found which is
  721                   * HSFX keyframes.
  722                   *
  723                   * On entry:  X has the voice channel number
  724 110E:BC ** **     	ldy voice_offsets,x	; Get offset to this voice's data
  725                   
  726 1111:1E ** **     	asl restore_ds,x	; Should we restore the decay and su
  727 1114:90 **        	bcc .10
  728                   
  729 1116:BD ** **     	lda save_decayl,x	; Restore time to start decay
  730 1119:99 ** **     	sta decayframe_v0,y
  731 111C:BD ** **     	lda save_decayh,x
  732 111F:99 ** **     	sta decayframe_v0+1,y
  733 1122:BD ** **     	lda save_sustainl,x	; Restore time to start sustain
  734 1125:99 ** **     	sta sustainframe_v0,y
  735 1128:BD ** **     	lda save_sustainh,x
  736 112B:99 ** **     	sta sustainframe_v0+1,y
  737                   
  738 112E:9C ** **     .10	stz did_innernext	; Reset loop skip flags
  739 1131:9C ** **     	stz did_outernext
  740 1134:9C ** **     	stz did_ring_end	; Reset ring end flag
  741                   
  742                   	;-- Check if there's an HSFX currently playing for th
  743 1137:BD ** **     	lda SFX_to_cancel,x	; Maybe active.  Got a cancel sta
  744 113A:F0 **        	beq mloop_frame		; If not, then skip
  745                   
  746                   	;-- There's currently an HSFX for this voice.  Kill i
  747 113C:99 ** **     	sta voice0,y		; Restore music priority from stash
  748 113F:A8           	tay			; and specifically stop sfx
  749 1140:DA           	 phx
  750 1141:20 A3 0C     	  jsr StopHSFX
  751 1144:FA           	 plx
  752 1145:9E ** **     	stz SFX_to_cancel,x	; Set sfx as stopped (clear stash
  753                   
  754                   
  755 1148:             mloop_frame
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   53
                        6502:src/hmusic.src             18:23:55  

  756                   * Here, we process the next block of data in the note 
  757 1148:BD ** **     	  lda voicedata_ptrl,x	; Get a z-page pointer to voic
  758 114B:85 35        	  sta audio_ptr
  759 114D:BD ** **     	  lda voicedata_ptrh,x
  760 1150:85 36        	  sta audio_ptr+1
  761                   
  762 1152:B2 35        	  lda (audio_ptr)		; Find out what to do this time
  763 1154:30 **        	  bmi do_CFW		; If high bit clear, this is a note
  764 1156:4C ** **     	  jmp do_note		; else this is a CFW
  765                   
  766                   
  767                   
  768 1159:             do_CFW
  769                   * ----------------------------------------------------
  770                   * Next note table entry is a Command Flags Word (not a
  771                   
  772 1159:8D ** **     	  sta hmflagsl		; Grab a copy of these new command fl
  773 115C:A0 01        	  ldy #1		; Y will be the voice data index
  774 115E:B1 35        	  lda (audio_ptr),y
  775 1160:8D ** **     	  sta hmflagsh
  776 1163:C8           	  iny
  777                   
  778                   * --- Rings ---
  779 1164:AD ** **     	  lda hmflagsh		; is RING flag set?
  780 1167:29 08        	  and #>RING
  781 1169:F0 **        	  beq ring_considered	; Branch if not RING
  782                   
  783 116B:4E ** **     	  lsr did_ring_end	; Did we loop to the CFW that sent
  784 116E:B0 **        	  bcs post_ring		; Branch if returning to ring starte
  785                   
  786 1170:BD ** **     	  lda ring_flag,x	; Are we already doing level 0 ring
  787 1173:F0 **        	  beq first_RING
  788                   
  789 1175:A5 35        	  lda audio_ptr		; Nested ring, do level '1'
  790 1177:9D ** **     	  sta ring1_returnl,x	: Stash the current note table
  791 117A:A5 36        	  lda audio_ptr+1	; pointer as our return location
  792 117C:9D ** **     	  sta ring1_returnh,x	; at end of ring 1
  793                   
  794 117F:A9 02        	  lda #2
  795 1181:9D ** **     	  sta ring_flag,x	; Mark RING1 as active
  796 1184:80 **        	  bra new_RING		; and go set up this new ring
  797                   
  798 1186:             first_RING			; We've got the start of a level 0 ring
  799 1186:A5 35        	  lda audio_ptr		: Stash the current note table
  800 1188:9D ** **     	  sta ring0_returnl,x	; pointer as our return locatio
  801 118B:A5 36        	  lda audio_ptr+1	; at end of ring 0
  802 118D:9D ** **     	  sta ring0_returnh,x
  803                   
  804 1190:FE ** **     	  inc ring_flag,x	; Mark RING0 as active
  805                   
  806 1193:             new_RING			; Set up the pointers to handle this new ri
  807 1193:B1 35        	  lda (audio_ptr),y	; Get voice index
  808 1195:0A           	  asl a			; Change to word index
  809 1196:A8           	  tay
  810                   ;	  clc	; true from above
  811 1197:B1 3C        	  lda (voiceoffsets_ptr),y ; Get offset of voice data
  812 1199:6D ** **     	  adc hmusic_base	; and use it to create new voice da
  813 119C:9D ** **     	  sta voicedata_ptrl,x
  814 119F:C8           	  iny
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   54
                        6502:src/hmusic.src             18:23:55  

  815 11A0:B1 3C        	  lda (voiceoffsets_ptr),y
  816 11A2:6D ** **     	  adc hmusic_base+1
  817 11A5:9D ** **     	  sta voicedata_ptrh,x
  818                   
  819 11A8:4C 48 11     	 jmp mloop_frame	; Take it from the top with voice's 
  820                   
  821 11AB:             post_ring	;-- Just returned from the ring, so ignore i
  822 11AB:C8           	iny			; Skip ring index byte
  823                   
  824                   
  825 11AC:             ring_considered	;-- Done thinking about rings for now
  826                   
  827                   
  828                   * --- Loops ---
  829                   
  830                   ; Inner loop - bottom
  831                   
  832 11AC:AD ** **     	  lda did_innernext	; Did we get here after processin
  833 11AF:0D ** **     	  ora did_outernext	; either an inner or outer NEXT?
  834 11B2:D0 **        	  bne mnext0_done	; If so, skip processing NEXTs
  835                   
  836 11B4:AD ** **     	  lda hmflagsh
  837 11B7:29 10        	  and #>NEXT1		; At the bottom of an inner loop?
  838 11B9:F0 **        	  beq mnext1_done	; No
  839                   
  840 11BB:BD ** **     	  lda mloop_count1,x	; Infinite loop?
  841 11BE:F0 **        	  beq takeloop1		; Yes, don't count
  842 11C0:DE ** **     	  dec mloop_count1,x	; No, are we done?
  843 11C3:F0 **        	  beq mnext1_done	; Yes, go check next flag
  844                   
  845 11C5:             takeloop1
  846 11C5:BD ** **     	  lda mloop_adrl1,x	; Reload pointer to top of loop
  847 11C8:9D ** **     	  sta voicedata_ptrl,x
  848 11CB:BD ** **     	  lda mloop_adrh1,x
  849 11CE:9D ** **     	  sta voicedata_ptrh,x
  850 11D1:EE ** **     	  inc did_innernext	; Set to skip LOOP1 we'll find th
  851 11D4:4C 48 11     	 jmp mloop_frame	; and go do top of loop
  852 11D7:             mnext1_done
  853                   
  854                   
  855                   
  856                   ; Outer loop - bottom
  857                   ;;;	  lda did_innernext	; Did we get here after proces
  858                   ;;;	  ora did_outernext	; either an inner or outer NEX
  859                   ;;;	  bne mnext0_done	; If so, skip processing outer N
  860                   
  861 11D7:AD ** **     	  lda hmflagsh
  862 11DA:29 40        	  and #>NEXT0		; Are we at the bottom of an outer loo
  863 11DC:F0 **        	  beq mnext0_done	; Branch if not
  864                   
  865 11DE:BD ** **     	  lda mloop_count0,x	; Infinite loop?
  866 11E1:F0 **        	  beq takeloop0		; Yes, don't count
  867 11E3:DE ** **     	  dec mloop_count0,x	; No, are we done?
  868 11E6:F0 **        	  beq mnext0_done	; Yes, go check next flag
  869                   
  870 11E8:             takeloop0	;-- Loop back to the top of the outer loop
  871 11E8:BD ** **     	  lda mloop_adrl0,x	; Reload pointer to top of loop
  872 11EB:9D ** **     	  sta voicedata_ptrl,x
  873 11EE:BD ** **     	  lda mloop_adrh0,x
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   55
                        6502:src/hmusic.src             18:23:55  

  874 11F1:9D ** **     	  sta voicedata_ptrh,x
  875 11F4:EE ** **     	  inc did_outernext	; Set to skip LOOP0 we'll find th
  876 11F7:4C 48 11     	 jmp mloop_frame	; and go do top of loop
  877 11FA:             mnext0_done
  878                   
  879                   
  880                   
  881                   ; Outer loop stuff - top
  882 11FA:AD ** **     	  lda hmflagsh
  883 11FD:29 80        	  and #>LOOP0		; Are we starting an outer loop?
  884 11FF:F0 **        	  beq mloop0_considered	; Branch if not
  885                   
  886 1201:AD ** **     	  lda did_innernext	; Did we get here after processin
  887 1204:0D ** **     	  ora did_outernext	; either an inner or outer NEXT?
  888 1207:D0 **        	  bne mstuff0		; If so, skip processing outer LOOP0
  889                   
  890 1209:A5 35        	  lda audio_ptr		; Stash current data pointer
  891 120B:9D ** **     	  sta mloop_adrl0,x
  892 120E:A5 36        	  lda audio_ptr+1
  893 1210:9D ** **     	  sta mloop_adrh0,x
  894 1213:B1 35        	  lda (audio_ptr),y	; Get # of loops to do
  895 1215:9D ** **     	  sta mloop_count0,x	; (if 0, infinite loop!)
  896 1218:             mstuff0
  897 1218:C8           	  iny			; Bump index past loop count
  898                   
  899 1219:             mloop0_considered
  900                   
  901                   
  902                   
  903                   ; Inner loop - top
  904 1219:AD ** **     	  lda hmflagsh
  905 121C:29 20        	  and #>LOOP1		; Are we starting an inner loop?
  906 121E:F0 **        	  beq mloop1_considered	; Branch if not
  907                   
  908 1220:AD ** **     	  lda did_innernext	; If we've done an inner loop NEX
  909 1223:D0 **        	  bne mstuff1		; then skip processing this loop start
  910                   
  911 1225:A5 35        	  lda audio_ptr		; Stash current data pointer
  912 1227:9D ** **     	  sta mloop_adrl1,x
  913 122A:A5 36        	  lda audio_ptr+1
  914 122C:9D ** **     	  sta mloop_adrh1,x
  915 122F:B1 35        	  lda (audio_ptr),y	; Get # of loops to do
  916 1231:9D ** **     	  sta mloop_count1,x	; (if 0, infinite loop!)
  917 1234:             mstuff1
  918 1234:C8           	  iny			; Bump index past loop count
  919                   
  920 1235:             mloop1_considered
  921                   
  922                   
  923                   * --- Gating ---
  924                   
  925 1235:AD ** **     	  lda hmflagsh
  926 1238:29 03        	  and #>ASD+AGD		; Either ASD or ADG gate value?
  927 123A:F0 **        	  beq asd_agd_considered	; Branch if not
  928                   
  929 123C:9D ** **     	  sta gating,x		; Save new gating flags
  930 123F:B1 35        	  lda (audio_ptr),y	; and get new gating value
  931 1241:9D ** **     	  sta gatel,x
  932 1244:C8           	  iny
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   56
                        6502:src/hmusic.src             18:23:55  

  933 1245:B1 35        	  lda (audio_ptr),y
  934 1247:9D ** **     	  sta gateh,x
  935 124A:C8           	  iny
  936                   
  937 124B:             asd_agd_considered
  938                   
  939                   
  940                   * --- Music HSFX ---
  941 124B:AD ** **     	  lda hmflagsl
  942 124E:29 20        	  and #MSFX		; Should this voice be a sound effect?
  943 1250:F0 **        	  beq msfx_considered	; Branch if not
  944                   
  945 1252:DA           	   phx
  946 1253:5A           	     phy
  947                   
  948 1254:BC ** **     	      ldy voice_offsets,x	; Get offset to this voice'
  949 1257:B9 ** **     	      lda voice0,y		; Get this voice's current priori
  950 125A:9D ** **     	      sta SFX_to_cancel,x	; Save for killing effect l
  951 125D:85 37        	      sta hsfx_temp
  952 125F:A9 00        	      lda #0			; Temporarily set this note's priority
  953 1261:99 ** **     	      sta voice0,y		; to 0 to prevent HSFX conflict
  954                   
  955      TRUE         	#IFDEF MUTE_USER
  956 1264:2C ** **     	      bit Mute_flag		; Is the mute flag set?
  957 1267:30 **        	      bmi .b9			; Branch if negative to mute
  958                   	#ENDIF
  959                   
  960 1269:7A           	     ply			; Restore argument index
  961 126A:5A           	     phy
  962 126B:B1 35        	      lda (audio_ptr),y	; Get index into SFX offset t
  963 126D:0A           	      asl a			; Make it a word index
  964 126E:A8           	      tay
  965 126F:B1 3C        	      lda (voiceoffsets_ptr),y ; Get offset of first 
  966 1271:18           	      clc
  967 1272:6D ** **     	      adc hmusic_base		; and create the keyframe addr
  968 1275:48           	       pha
  969 1276:C8           		iny
  970 1277:B1 3C        		lda (voiceoffsets_ptr),y
  971 1279:6D ** **     		adc hmusic_base+1
  972 127C:AA           		tax			; High byte of address
  973 127D:68           	       pla			; Low  byte of address
  974 127E:A4 37        	      ldy hsfx_temp		; Priority of voice/effect
  975 1280:20 66 0C     	      jsr StartHSFX		; Start this note "sound effect"
  976                   
  977 1283:7A           .b9	     ply
  978 1284:C8           	    iny
  979 1285:FA           	   plx
  980 1286:BD ** **     	  lda voicedata_ptrl,x	; Restore our voice data point
  981 1289:85 35        	  sta audio_ptr		; (trashed by StartHSFX)
  982 128B:BD ** **     	  lda voicedata_ptrh,x
  983 128E:85 36        	  sta audio_ptr+1
  984 1290:             msfx_considered
  985                   
  986                   
  987                   * --- User Call ---
  988 1290:AD ** **     	  lda hmflagsl
  989 1293:29 10        	  and #USER		; Some USER data to send?
  990 1295:F0 **        	  beq user_considered	; Branch if not
  991                   
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   57
                        6502:src/hmusic.src             18:23:55  

  992      FALSE        	#IFDEF	USERCALLS_USER
 1001                   	#ENDIF ; of #IFDEF USERCALLS_USER
 1002 1297:C8           	  iny
 1003                   
 1004 1298:             user_considered
 1005                   
 1006                   
 1007                   * --- Duration Table Selector ---
 1008 1298:AD ** **     	  lda hmflagsl
 1009 129B:29 08        	  and #DURATION		; New duration table?
 1010 129D:F0 **        	  beq dur_tbl_considered
 1011                   
 1012 129F:B1 35        	  lda (audio_ptr),y	; Yes, get offset to duration tab
 1013 12A1:18           	  clc
 1014 12A2:6D ** **     	  adc hmusic_base	; and convert to absolute address
 1015 12A5:9D ** **     	  sta voice_dur_ptrl,x	; and store new address of dur
 1016 12A8:C8           	  iny
 1017 12A9:B1 35        	  lda (audio_ptr),y
 1018 12AB:6D ** **     	  adc hmusic_base+1
 1019 12AE:9D ** **     	  sta voice_dur_ptrh,x
 1020 12B1:C8           	  iny
 1021                   
 1022 12B2:             dur_tbl_considered
 1023                   
 1024                   
 1025                   * --- Pitch Table Selector ---
 1026 12B2:AD ** **     	  lda hmflagsl
 1027 12B5:29 04        	  and #PITCH		; New pitch table?
 1028 12B7:F0 **        	  beq freq_tbl_considered
 1029                   
 1030 12B9:B1 35        	  lda (audio_ptr),y	; Yes, get offset to pitch table
 1031 12BB:18           	  clc
 1032 12BC:6D ** **     	  adc hmusic_base
 1033 12BF:9D ** **     	  sta voice_freq_ptrl,x	; and convert to absolute add
 1034 12C2:C8           	  iny			; and store new address of pitch table
 1035 12C3:B1 35        	  lda (audio_ptr),y
 1036 12C5:6D ** **     	  adc hmusic_base+1
 1037 12C8:9D ** **     	  sta voice_freq_ptrh,x
 1038 12CB:C8           	  iny
 1039                   
 1040 12CC:             freq_tbl_considered
 1041                   
 1042                   
 1043                   * --- Keyframe Raw Data ---
 1044                   * This is how the normal ADSR for a voice gets loaded.
 1045                   * the sound guys can slip in craazy sound effects with
 1046                   * First comes an optional byte that designates Standar
 1047                   * causes a bunch of keyframe fields to be cleared.
 1048                   * Next, escape data comes in 3 bytes:  offset into son
 1049                   * data, next two bytes are low and high data to go in 
 1050                   * Lastly the end of the escape data is designated eith
 1051                   * music note or a byte of $FF (meaning End Of Escape).
 1052                   
 1053 12CC:AD ** **     	  lda hmflagsl
 1054 12CF:29 02        	  and #ESCAPE		; Load raw data into keyframe set?
 1055 12D1:F0 **        	  beq escape_considered	; Branch if not
 1056                   
 1057 12D3:DA           	   phx
 1058 12D4:BD ** **     	    lda voice_offsets,x	; Get offset to this voice's 
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   58
                        6502:src/hmusic.src             18:23:55  

 1059 12D7:85 37        	    sta hsfx_temp
 1060                   
 1061 12D9:B1 35        	    lda (audio_ptr),y	; Get first ESCAPE argument
 1062 12DB:C9 FF        	    cmp #$ff		; Clear some seldom used locations?
 1063 12DD:D0 **        	    bne .44		; Branch if not
 1064                   
 1065 12DF:5A           	     phy	; Clear several elements in this voice's key
 1066 12E0:A0 **        	      ldy #clear_voice_end-clear_voice-1 ; Get max cl
 1067 12E2:B9 ** **     .22		lda clear_voice,y	; Create offset to the voice's 
 1068                   ;		clc	; clear from above
 1069 12E5:65 37        		adc hsfx_temp
 1070 12E7:AA           		tax
 1071 12E8:9E ** **     		stz voice0,x
 1072 12EB:9E ** **     		stz voice0+1,x
 1073 12EE:88           		dey
 1074 12EF:10 F1        	       bpl .22
 1075 12F1:7A           	     ply
 1076 12F2:C8           	    iny
 1077                   
 1078 12F3:B1 35        .44	    lda (audio_ptr),y	; get next note or ESCAPE fl
 1079 12F5:10 **        	    bpl end_escape	; High bit off = end of escape seq
 1080                   
 1081 12F7:C8           	    iny			; Advance index past this byte
 1082                   
 1083                   	    ; If byte is the special "end of escape" value th
 1084 12F8:C9 FF        	    cmp #$ff		; Note: only needed if two adjacent
 1085 12FA:F0 **        	    beq end_escape	;  CFWs - i.e.: consecutive RING
 1086                   
 1087                   	    ;-- Else this is normal escape data, so get the d
 1088                   	    ;-- store it into the keyframe and try again
 1089 12FC:29 7F        	    and #$7f		; Mask off upper bit
 1090 12FE:18           	    clc
 1091 12FF:65 37        	    adc hsfx_temp	; Add voice offset
 1092 1301:AA           	    tax
 1093 1302:B1 35        	    lda (audio_ptr),y	; Copy value
 1094 1304:9D ** **     	    sta voice0,x
 1095 1307:C8           	    iny
 1096 1308:B1 35        	    lda (audio_ptr),y
 1097 130A:9D ** **     	    sta voice0+1,x
 1098 130D:C8           	    iny
 1099 130E:80 E3        	    bra .44
 1100                   
 1101 1310:             end_escape
 1102 1310:FA           	   plx
 1103                   
 1104 1311:5A           	   phy
 1105 1312:BC ** **     	    ldy voice_offsets,x		; Get offset to this voice's
 1106 1315:B9 ** **     	    lda decayframe_v0,y		; back up decay times
 1107 1318:9D ** **     	    sta save_decayl,x
 1108 131B:B9 ** **     	    lda decayframe_v0+1,y
 1109 131E:9D ** **     	    sta save_decayh,x
 1110 1321:B9 ** **     	    lda sustainframe_v0,y	; back up sustain times
 1111 1324:9D ** **     	    sta save_sustainl,x
 1112 1327:B9 ** **     	    lda sustainframe_v0+1,y
 1113 132A:9D ** **     	    sta save_sustainh,x
 1114 132D:7A           	   ply
 1115                   
 1116                   
 1117 132E:             escape_considered
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   59
                        6502:src/hmusic.src             18:23:55  

 1118                   * --- Almost at End ---
 1119 132E:AD ** **     	  lda hmflagsl		; check for final CFW
 1120 1331:29 01        	  and #END_OF_VOICE
 1121 1333:D0 **        	  bne end_voice		; Branch if so
 1122                   
 1123 1335:98           	  tya			; skip bytes just processed
 1124 1336:18           	  clc
 1125 1337:65 35        	  adc audio_ptr
 1126 1339:9D ** **     	  sta voicedata_ptrl,x
 1127 133C:A9 00        	  lda #0
 1128 133E:65 36        	  adc audio_ptr+1
 1129 1340:9D ** **     	  sta voicedata_ptrh,x
 1130 1343:4C 48 11     	 jmp mloop_frame	; else go to top and do it all again
 1131                   
 1132                   
 1133 1346:             end_voice
 1134                   * --- End of Voice ---
 1135 1346:5E ** **     	  lsr ring_flag,x	; Is a 'RING' ending?
 1136 1349:D0 **        	  bne return_from_ring1	; Branch if RING1 ending
 1137 134B:B0 **        	  bcs return_from_ring0	; Branch if RING0 ending
 1138 134D:9E ** **     	  stz VoiceInUse,x	; else this voice is done!
 1139 1350:60           	rts			; RG sez:  Ttfn
 1140                   
 1141 1351:             return_from_ring1
 1142 1351:BD ** **     	  lda ring1_returnl,x	; Restore 'RING0' address
 1143 1354:BC ** **     	  ldy ring1_returnh,x
 1144 1357:80 **        	  bra ring_return
 1145                   
 1146 1359:             return_from_ring0
 1147 1359:BD ** **     	  lda ring0_returnl,x	; Restore main voice address
 1148 135C:BC ** **     	  ldy ring0_returnh,x
 1149                   
 1150 135F:             ring_return
 1151 135F:9D ** **     	  sta voicedata_ptrl,x	; restore CFW to return from r
 1152 1362:98           	  tya
 1153 1363:9D ** **     	  sta voicedata_ptrh,x
 1154 1366:EE ** **     	  inc did_ring_end
 1155 1369:4C 48 11     	 jmp mloop_frame
 1156                   
 1157                   
 1158                   
 1159                   
 1160 136C:             do_note
 1161                   * ----------------------------------------------------
 1162                   * Next note table entry is an actual note (not a Comma
 1163                   
 1164 136C:DA           	 phx
 1165                   
 1166 136D:29 0F        	  and #SONG_PITCHBITS	; turn note entry into frequenc
 1167 136F:0A           	  asl a			;  0dddpppp -> 000pppp0
 1168 1370:A8           	  tay
 1169                   
 1170 1371:A9 04        	  lda #HSFX_CHANNELCOUNT	; mark that we have no chann
 1171 1373:9D ** **     	  sta VoiceHSFXChannel,x
 1172                   
 1173 1376:BD ** **     	  lda voice_freq_ptrl,x		; Set up note's frequency po
 1174 1379:85 38        	  sta frequency_ptr
 1175 137B:BD ** **     	  lda voice_freq_ptrh,x
 1176 137E:85 39        	  sta frequency_ptr+1
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   60
                        6502:src/hmusic.src             18:23:55  

 1177                   
 1178 1380:BD ** **     	  lda voice_dur_ptrl,x		; Set up note's duration poin
 1179 1383:85 3A        	  sta duration_ptr
 1180 1385:BD ** **     	  lda voice_dur_ptrh,x
 1181 1388:85 3B        	  sta duration_ptr+1
 1182                   
 1183 138A:BD ** **     	  lda voice_offsets,x		; get offset to voice's HSFX k
 1184 138D:AA           	  tax
 1185                   
 1186 138E:B1 38        	  lda (frequency_ptr),y		; Load up the frequency for 
 1187 1390:9D ** **     	  sta attackfreq_v0,x
 1188 1393:C8           	  iny
 1189 1394:B1 38        	  lda (frequency_ptr),y
 1190 1396:9D ** **     	  sta attackfreq_v0+1,x
 1191 1399:1D ** **     	  ora attackfreq_v0,x		; check for zero frequency
 1192 139C:48           	   pha				; save for later
 1193                   
 1194 139D:B2 35        	    lda (audio_ptr)		; turn note entry into duration 
 1195 139F:29 70        	    and #SONG_DURATIONBITS	;  0dddpppp -> 0000ddd0
 1196 13A1:4A           	    lsr a
 1197 13A2:4A           	    lsr a
 1198 13A3:4A           	    lsr a
 1199 13A4:A8           	    tay
 1200                   
 1201 13A5:B1 3A        	    lda (duration_ptr),y	; Jam value into the end not
 1202 13A7:9D ** **     	    sta endframe_v0,x
 1203 13AA:C8           	    iny
 1204 13AB:B1 3A        	    lda (duration_ptr),y
 1205 13AD:9D ** **     	    sta endframe_v0+1,x
 1206                   
 1207 13B0:68           	   pla			; restore zero frequency check
 1208 13B1:FA           	 plx			; Restore the voice channel number
 1209                   
 1210 13B2:C9 00        	cmp #0			; test for pitch set to 0
 1211 13B4:F0 **        	beq .00
 1212                   
 1213 13B6:A9 80        	lda #$80	; if non-zero pitch, set flag marking new no
 1214 13B8:9D ** **     	sta new_note,x
 1215                   
 1216 13BB:B1 3A        .00	lda (duration_ptr),y	; save duration value for mus
 1217 13BD:9D ** **     	sta voice_endframeh,x
 1218 13C0:88           	dey
 1219 13C1:B1 3A        	lda (duration_ptr),y
 1220 13C3:9D ** **     	sta voice_endframel,x
 1221                   
 1222 13C6:BC ** **     	ldy voice_offsets,x	; Get offset to this voice's keyf
 1223 13C9:BD ** **     	lda gating,x		; Get gating flags, check for AGS or AG
 1224 13CC:29 01        	and #>AGD		; AGD?
 1225 13CE:D0 **        	bne .10			; Branch if AGD (not AGS)
 1226                   
 1227 13D0:38           	sec			; Set up AGS
 1228 13D1:BD ** **     	lda voice_endframel,x	;  (start of release = duration
 1229 13D4:FD ** **     	sbc gatel,x
 1230 13D7:99 ** **     	sta releaseframe_v0,y
 1231 13DA:BD ** **     	lda voice_endframeh,x
 1232 13DD:FD ** **     	sbc gateh,x
 1233                   ;	sta releaseframe_v0+1,y	; done below
 1234 13E0:80 **        	bra .19
 1235                   
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   61
                        6502:src/hmusic.src             18:23:55  

 1236 13E2:BD ** **     .10	lda gatel,x		; Set up AGD (start of release = gate
 1237 13E5:99 ** **     	sta releaseframe_v0,y
 1238 13E8:BD ** **     	lda gateh,x
 1239 13EB:99 ** **     .19	sta releaseframe_v0+1,y
 1240                   
 1241 13EE:B9 ** **     	lda sustainframe_v0,y	; Check that sustain starts bef
 1242 13F1:D9 ** **     	cmp releaseframe_v0,y
 1243 13F4:B9 ** **     	lda sustainframe_v0+1,y
 1244 13F7:F9 ** **     	sbc releaseframe_v0+1,y
 1245 13FA:90 **        	bcc .40
 1246                   
 1247 13FC:A9 80        	lda #$80		; Mark need to restore decay and sus
 1248 13FE:9D ** **     	sta restore_ds,x
 1249                   
 1250 1401:38           	sec			; Set sustain time to (release time - 1)
 1251 1402:B9 ** **     	lda releaseframe_v0,y
 1252 1405:E9 01        	sbc #1
 1253 1407:99 ** **     	sta sustainframe_v0,y
 1254 140A:B9 ** **     	lda releaseframe_v0+1,y
 1255 140D:E9 00        	sbc #0
 1256 140F:99 ** **     	sta sustainframe_v0+1,y
 1257                   
 1258 1412:B9 ** **     	lda decayframe_v0,y	; Check that decay starts before 
 1259 1415:D9 ** **     	cmp sustainframe_v0,y
 1260 1418:B9 ** **     	lda decayframe_v0+1,y
 1261 141B:F9 ** **     	sbc sustainframe_v0+1,y
 1262 141E:90 **        	bcc .40
 1263                   
 1264 1420:38           	sec			; Set decay time to (sustain time - 1)
 1265 1421:B9 ** **     	lda sustainframe_v0,y
 1266 1424:E9 01        	sbc #1
 1267 1426:99 ** **     	sta decayframe_v0,y
 1268 1429:B9 ** **     	lda sustainframe_v0+1,y
 1269 142C:E9 00        	sbc #0
 1270 142E:99 ** **     	sta decayframe_v0+1,y
 1271                   
 1272 1431:FE ** **     .40	inc voicedata_ptrl,x	; Point to next entry in voic
 1273 1434:D0 **        	bne .7d
 1274 1436:FE ** **     	inc voicedata_ptrh,x
 1275                   
 1276 1439:60           .7d	rts
 1277                   
 1278                   
 1279                   
 1280                   
 1281                   * === ================================================
 1282                   * ===               ==================================
 1283                   * ===      Data     ==================================
 1284                   * ===               ==================================
 1285                   * === ================================================
 1286                   
 1287                   
 1288                   
 1289                   
 1290                   * The voice_offsets describe the number of bytes betwe
 1291                   * first byte of voice 0's data and the first byte of v
 1292                   
 1293 143A:00           voice_offsets	.by 0
 1294                   
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   62
                        6502:src/hmusic.src             18:23:55  

 1295      TRUE         	#if HMUSIC_CHANNELCOUNT > 1
 1296 143B:00           		.by voice1-voice0
 1297      TRUE         	 #if HMUSIC_CHANNELCOUNT > 2
 1298 143C:00           		.by voice2-voice0
 1299      TRUE         	  #if HMUSIC_CHANNELCOUNT > 3
 1300 143D:00           		.by voice3-voice0
 1301                   	  #endif ; > 3
 1302                   	 #endif ; > 2
 1303                   	#endif ; > 1
 1304                   
 1305                   
 1306                   
 1307                   
 1308                   * NOTE:  =============================================
 1309                   * NOTE:  The position of the following note arrays is 
 1310                   * NOTE:  of the above code depends on the exact arrang
 1311                   * NOTE:  You would have to be mad to rearrange this st
 1312                   
 1313 143E:08           clear_voice	.by $08		; Attack  keyframe  shifter   acc
 1314 143F:0C           		.by $0c		; Attack  keyframe  volume    accumulator
 1315 1440:0E           		.by $0e		; Attack  keyframe  frequency interpolator
 1316 1441:10           		.by $10		; Attack  keyframe  feedback  interpolator
 1317 1442:18           		.by $18		; Decay   keyframe  frequency interpolator
 1318 1443:1A           		.by $1a		; Decay   keyframe  feedback  interpolator
 1319 1444:22           		.by $22		; Sustain keyframe  frequency interpolator
 1320 1445:24           		.by $24		; Sustain keyframe  feedback  interpolator
 1321 1446:26           		.by $26		; Sustain keyframe  volume    interpolator
 1322 1447:2C           		.by $2c		; Release keyframe  frequency interpolator
 1323 1448:2E           		.by $2e		; Release keyframe  feedback  interpolator
 1324 1449:             clear_voice_end
 1325                   
 1326                   
 1327                   * ----- HSFX flag sets ----- *
 1328                   
 1329      0F00         ALL_ACCUM	.EQU	FREQ_ACCUM+SHIFT_ACCUM+FBACK_ACCUM+VOL_
 1330      00B0         INTERP		.EQU	FREQ_INTERP+FBACK_INTERP+VOL_INTERP
 1331                   
 1332 1449:             voice0		; --- Voice 0 --------------------------------
 1333 1449:6A 00        		.wo HMUSIC_DEFAULT_PRIORITY+{{HMUSIC_CHANNELCOUNT-1}
 1334 144B:00 00        attackframe_v0	.wo 0		; === Time to start attack
 1335 144D:B0 0F        		.wo ALL_ACCUM+INTERP
 1336 144F:00 00        attackfreq_v0	.wo 0		; Frequency accumulator
 1337 1451:00 00        		.wo 0		; Shifter accumulator
 1338 1453:00 00        		.wo 0		; Feedback accumulator
 1339 1455:00 00        		.wo 0		; Volume accumulator
 1340 1457:00 00        		.wo 0		; Frequency interpolation
 1341 1459:00 00        		.wo 0		; Feedback interpolation
 1342 145B:00 00        		.wo 0		; Volume interpolation
 1343 145D:01 00        decayframe_v0	.wo 1		; === Time to start decay
 1344 145F:B0 00        		.wo INTERP
 1345 1461:00 00        		.wo 0		; Frequency interpolation
 1346 1463:00 00        		.wo 0		; Feedback interpolation
 1347 1465:00 00        		.wo 0		; Volume interpolation
 1348 1467:01 00        sustainframe_v0	.wo 1		; === Time to start sustain
 1349 1469:B0 00        		.wo INTERP
 1350 146B:00 00        		.wo 0		; Frequency interpolation
 1351 146D:00 00        		.wo 0		; Feedback interpolation
 1352 146F:00 00        		.wo 0		; Volume interpolation
 1353 1471:01 00        releaseframe_v0	.wo 1		; === Time to start release
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   63
                        6502:src/hmusic.src             18:23:55  

 1354 1473:B0 00        		.wo INTERP
 1355 1475:00 00        		.wo 0		; Frequency interpolation
 1356 1477:00 00        		.wo 0		; Feedback interpolation
 1357 1479:00 00        		.wo 0		; Volume interpolation
 1358 147B:01 00        endframe_v0	.wo 1		; End release & end effect
 1359 147D:01 00        		.wo END_OF_EFFECT
 1360 147F:             voice1		; --- Voice 1 --------------------------------
 1361      TRUE         	#IF HMUSIC_CHANNELCOUNT > 1
 1362 147F:68 00        		.wo HMUSIC_DEFAULT_PRIORITY+{{HMUSIC_CHANNELCOUNT-2}
 1363 1481:00 00        attackframe_v1	.wo 0		; === Time to start attack
 1364 1483:B0 0F        		.wo ALL_ACCUM+INTERP
 1365 1485:00 00        		.wo 0		; Frequency accumulator
 1366 1487:00 00        		.wo 0		; Shifter accumulator
 1367 1489:00 00        		.wo 0		; Feedback accumulator
 1368 148B:00 00        		.wo 0		; Volume accumulator
 1369 148D:00 00        		.wo 0		; Frequency interpolation
 1370 148F:00 00        		.wo 0		; Feedback interpolation
 1371 1491:00 00        		.wo 0		; Volume interpolation
 1372 1493:01 00        decayframe_v1	.wo 1		; === Time to start decay
 1373 1495:B0 00        		.wo INTERP
 1374 1497:00 00        		.wo 0		; Frequency interpolation
 1375 1499:00 00        		.wo 0		; Feedback interpolation
 1376 149B:00 00        		.wo 0		; Volume interpolation
 1377 149D:01 00        sustainframe_v1	.wo 1		; === Time to start sustain
 1378 149F:B0 00        		.wo INTERP
 1379 14A1:00 00        		.wo 0		; Frequency interpolation
 1380 14A3:00 00        		.wo 0		; Feedback interpolation
 1381 14A5:00 00        		.wo 0		; Volume interpolation
 1382 14A7:01 00        releaseframe_v1	.wo 1		; === Time to start release
 1383 14A9:B0 00        		.wo INTERP
 1384 14AB:00 00        		.wo 0		; Frequency interpolation
 1385 14AD:00 00        		.wo 0		; Feedback interpolation
 1386 14AF:00 00        		.wo 0		; Volume interpolation
 1387 14B1:01 00        endframe_v1	.wo 1		; End release & end effect
 1388 14B3:01 00        		.wo END_OF_EFFECT
 1389                   	#ENDIF ; of #IF HMUSIC_CHANNELCOUNT > 1
 1390 14B5:             voice2		; --- Voice 2 --------------------------------
 1391      TRUE         	#IF HMUSIC_CHANNELCOUNT > 2
 1392 14B5:66 00        		.wo HMUSIC_DEFAULT_PRIORITY+{{HMUSIC_CHANNELCOUNT-3}
 1393 14B7:00 00        attackframe_v2	.wo 0		; === Time to start attack
 1394 14B9:B0 0F        		.wo ALL_ACCUM+INTERP
 1395 14BB:00 00        		.wo 0		; Frequency accumulator
 1396 14BD:00 00        		.wo 0		; Shifter accumulator
 1397 14BF:00 00        		.wo 0		; Feedback accumulator
 1398 14C1:00 00        		.wo 0		; Volume accumulator
 1399 14C3:00 00        		.wo 0		; Frequency interpolation
 1400 14C5:00 00        		.wo 0		; Feedback interpolation
 1401 14C7:00 00        		.wo 0		; Volume interpolation
 1402 14C9:01 00        decayframe_v2	.wo 1		; === Time to start decay
 1403 14CB:B0 00        		.wo INTERP
 1404 14CD:00 00        		.wo 0		; Frequency interpolation
 1405 14CF:00 00        		.wo 0		; Feedback interpolation
 1406 14D1:00 00        		.wo 0		; Volume interpolation
 1407 14D3:01 00        sustainframe_v2	.wo 1		; === Time to start sustain
 1408 14D5:B0 00        		.wo INTERP
 1409 14D7:00 00        		.wo 0		; Frequency interpolation
 1410 14D9:00 00        		.wo 0		; Feedback interpolation
 1411 14DB:00 00        		.wo 0		; Volume interpolation
 1412 14DD:01 00        releaseframe_v2	.wo 1		; === Time to start release
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   64
                        6502:src/hmusic.src             18:23:55  

 1413 14DF:B0 00        		.wo INTERP
 1414 14E1:00 00        		.wo 0		; Frequency interpolation
 1415 14E3:00 00        		.wo 0		; Feedback interpolation
 1416 14E5:00 00        		.wo 0		; Volume interpolation
 1417 14E7:01 00        endframe_v2	.wo 1		; End release & end effect
 1418 14E9:01 00        		.wo END_OF_EFFECT
 1419                   	#ENDIF ; of #IF HMUSIC_CHANNELCOUNT > 2
 1420 14EB:             voice3		; --- Voice 3 --------------------------------
 1421      TRUE         	#IF HMUSIC_CHANNELCOUNT > 3
 1422 14EB:64 00        		.wo HMUSIC_DEFAULT_PRIORITY+{{HMUSIC_CHANNELCOUNT-4}
 1423 14ED:00 00        attackframe_v3	.wo 0		; === Time to start attack
 1424 14EF:B0 0F        		.wo ALL_ACCUM+INTERP
 1425 14F1:00 00        		.wo 0		; Frequency accumulator
 1426 14F3:00 00        		.wo 0		; Shifter accumulator
 1427 14F5:00 00        		.wo 0		; Feedback accumulator
 1428 14F7:00 00        		.wo 0		; Volume accumulator
 1429 14F9:00 00        		.wo 0		; Frequency interpolation
 1430 14FB:00 00        		.wo 0		; Feedback interpolation
 1431 14FD:00 00        		.wo 0		; Volume interpolation
 1432 14FF:01 00        decayframe_v3	.wo 1		; === Time to start decay
 1433 1501:B0 00        		.wo INTERP
 1434 1503:00 00        		.wo 0		; Frequency interpolation
 1435 1505:00 00        		.wo 0		; Feedback interpolation
 1436 1507:00 00        		.wo 0		; Volume interpolation
 1437 1509:01 00        sustainframe_v3	.wo 1		; === Time to start sustain
 1438 150B:B0 00        		.wo INTERP
 1439 150D:00 00        		.wo 0		; Frequency interpolation
 1440 150F:00 00        		.wo 0		; Feedback interpolation
 1441 1511:00 00        		.wo 0		; Volume interpolation
 1442 1513:01 00        releaseframe_v3	.wo 1		; === Time to start release
 1443 1515:B0 00        		.wo INTERP
 1444 1517:00 00        		.wo 0		; Frequency interpolation
 1445 1519:00 00        		.wo 0		; Feedback interpolation
 1446 151B:00 00        		.wo 0		; Volume interpolation
 1447 151D:01 00        endframe_v3	.wo 1		; End release & end effect
 1448 151F:01 00        		.wo END_OF_EFFECT
 1449                   	#ENDIF ; of #IF HMUSIC_CHANNELCOUNT > 3
 1450                   * NOTE:  The position of the above note arrays is very
 1451                   * NOTE:  =============================================
 1452                   
 1453                   
 1454                   
 1455                   
 1346                   ;	.in 6502:src/sprite.src
 1347                   ;	.in 6502:src/controls.src
 1348                   	.in 6502:src/sys.src
    1                   ; Tue Sep 18 17:43:25 1990
    2                   * === sys.src ========================================
    3                   *
    4                   * General System Source Code  --  Handy Software
    5                   *
    6                   * Confidential and Proprietary
    7                   * Copyright (c) 1989,1990 Epyx, Inc.
    8                   *
    9                   * Date		Name		Description
   10                   * ---------	--------------	---------------------------
   11                   * 28-Mar-90	SHL		IRQ handler quick checks for serial I
   12                   *				if SERIALPORT_USER defined now.
   13                   * 22-Mar-90	SHL		IRQ handler only touches 1 IRQ at a t
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   65
                        6502:src/sys.src                18:23:55  

   14                   *				Individual handlers need not preserve X and A
   15                   *				IRQ handlers now required to PLX PLA RTI
   16                   *				instead of RTS
   17                   *				Renamed SafeIntRts to IntReturn, which now
   18                   *				does PLX PLA RTI
   19                   * 16-Mar-90	SHL		Modified BRK detect for 1 cycle impro
   20                   *				in the case of IRQ
   21                   * 15-Mar-90	SHL		Provided faster vector to Redeye inte
   22                   *				Serial interrupts now must PLX PLA RTI to
   23                   *				exit.
   24                   * 14-Mar-90	SHL		Added SafeIntRts
   25                   *				INITINT now vectors all IRQS to SafeIntRts
   26                   *				instead of user supplied RTS
   27                   * 26-Feb-90	SHL		Minor code tightening
   28                   * 9-Feb-90	SHL		INITINT is now required before any use
   29                   *				INITEOF, INITEOL or SET_DISPLAY... macros
   30                   *				This file can now be included before user
   31                   *				calls INITINT
   32                   * 7-Feb-90	SHL		Modified BRK_USER to force Howard Brea
   33                   * 31 May 89	-RJ		Added BRK_USER support code to UserIn
   34                   *				Removed InitSys routine
   35                   * 6 Apr 89	=RJ Mical=	Created this file!
   36                   *
   37                   * ====================================================
   38                   
   39                   
   40                   * This code is called whenever a non-NMI interrupt occ
   41                   * interrupt or execution of a software BRK).
   42                   
   43 1521:             UserIntHandler
   44 1521:48           		PHA
   45 1522:DA           		PHX
   46                   
   47      FALSE        	  #IFDEF BRK_USER
   57                   	  #ENDIF ; of #IFDEF BRK_USER
   58                   
   59 1523:             hardInt
   60                   		;------	We had a hardware interrupt.
   61                   		;------	Get the interrupt flags value, reset the bit
   62 1523:AD 81 FD     		LDA INTSET		; This gets the bits
   63                   
   64      FALSE        	  #IFDEF SERIALPORT_USER
   68                   	  #ENDIF
   69                   
   70 1526:8D 46 0C     .02		STA INTSET_RAM
   71                   
   72                   		;------	For least set bit in the interrupt value,
   73                   		;------	vector to the routine
   74 1529:A2 00        		LDX #0
   75 152B:A9 01        		lda #1
   76 152D:2C 46 0C     .00		  bit INTSET_RAM
   77 1530:D0 **        		  bne jumpIntTable
   78 1532:E8           		  INX
   79 1533:E8           		  INX
   80 1534:0A           		  asl a
   81 1535:D0 F6        		 bne .00
   82 1537:             IntReturn
   83                   		;------	At end of interrupt processing, restore the
   84                   		;------	registers and return from interrupt
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   66
                        6502:src/sys.src                18:23:55  

   85                   
   86 1537:FA           		PLX
   87 1538:68           		PLA
   88 1539:40           		RTI
   89                   
   90                   
   91                   
   92                   
   93                   * The above interrupt dispatcher does a JSR to this li
   94                   * This code jumps to the particular handler.  The inte
   95                   * should end with an RTS, which will return control to
   96                   
   97 153A:             jumpIntTable
   98 153A:8D 80 FD     		sta INTRST	; clear interrupt we're processing
   99 153D:7C ** **     		JMP	(sysIntTable,X)
  100                   
  101                   
  102      FALSE        	  #IFDEF BRK_USER
  108                   	  #ENDIF ; of #IFDEF BRK_USER
  109                   
  110                   
  111                   
 1349                   	.in 6502:src/display.src
    1                   ; Tue Sep 18 17:51:17 1990
    2                   * === display.src ====================================
    3                   *
    4                   * Display and Color IO Routines --  the 6502 Side of H
    5                   *
    6                   * Copyright (C) 1988,1989,1990 Epyx, Inc.
    7                   * All Rights Reserved
    8                   * CONFIDENTIAL and PROPRIETARY
    9                   *
   10                   * Date		Name		Description
   11                   * ---------	--------------	---------------------------
   12                   * 18-Sep-90	SHL		Added code to work around RICOH bug
   13                   *				and support for the NO_RICOH_PATCH switch
   14                   * 22-Mar-90	SHL		Removed PHA PHX and PLX PLA from IRQ 
   15                   * 20-Mar-90	SHL		Removed SEI, CLI from InitDisplayer, 
   16                   *				InitEOL
   17                   * 7-Feb-90	SHL		Apple compatibility removed
   18                   *				TIMEOUT macro moved to display.mac
   19                   *				General cleanup and prettification
   20                   * 3 July 89	-RJ		The RESET_TIMEOUT logic is moved from
   21                   *				input macros to the TIMEOUT macro here
   22                   * 16 Jun 89	Peter Engelbrite Timeout constant set to 1
   23                   * 24 May 89	-RJ		Added AUTO_TIMEOUT_USER support code
   24                   * 1 May 89	-RJ		Changed all IntTable references to sys
   25                   *				which is defined now in the sys.mac file
   26                   * 20 Apr 89	-RJ		Changed DisplayFrameCount so that it'
   27                   *				included and incremented if FRAMECOUNT_UP is
   28                   *				defined, included and decremented if
   29                   *				FRAMECOUNT_DOWN is defined, else nothing.
   30                   *				Moved DisplayFrameCount to this file.
   31                   * 20 Mar 89	-RJ		Added increment of DisplayFrameCount 
   32                   *				handler that's included for EOF_USER's
   33                   * 13 Feb 89	-RJ		Added InitDisplayer routine.  Added i
   34                   *				of DISPLAY to normal EOF handler (FrameEnd).
   35                   * 12 Feb 89	-RJ		EOF and EOL code save and restore A
   36                   * 26-Dec-88	-RJ		Added EOL code
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   67
                        6502:src/display.src            18:23:55  

   37                   * 23-Dec-88	-RJ		Added EOF code
   38                   * Early 88	=RJ Mical=	Created this file!
   39                   *
   40                   * ====================================================
   41                   
   42                   
   43                   
   44                   * If either FRAMECOUNT_UP or _DOWN is defined, then de
   45      TRUE         	#IFDEF	FRAMECOUNT_UP | FRAMECOUNT_DOWN
   46 1540:             DisplayFrameCount	.DS	1
   47                   	#ENDIF
   48                   
   49                   
   50      TRUE         	#IFDEF EOF_USER
   51                   * - - - - - - - - - - - - -  - - - - - - - - - - - - -
   52                   * - - - - - - - - - - - - -  - - - - - - - - - - - - -
   53                   * - - - - - - - - - - - - -  - - - - - - - - - - - - -
   54                   	;------	If an EOF user, create the elaborate version 
   55                   	;------	end-of-frame handler
   56                   
   57 1541:             InitEOF
   58                   		;------	Copy old vector into our exit JMP instructio
   59 1541:AD ** **     		LDA	sysIntTable+{2*2}
   60 1544:8D ** **     		STA	FrameEndExit+1
   61 1547:AD ** **     		LDA	sysIntTable+{2*2}+1
   62 154A:8D ** **     		STA	FrameEndExit+2
   63                   		;------	Install our vector into the interrupt table
   64 154D:A9 **        		LDA	#<FrameEnd
   65 154F:8D ** **     		STA	sysIntTable+{2*2}
   66 1552:A9 **        		LDA	#>FrameEnd
   67 1554:8D ** **     		STA	sysIntTable+{2*2}+1
   68 1557:60           		RTS
   69                   
   70 1558:             FrameEnd
   71                   * End-of-Frame handler
   72 1558:5A           		PHY
   73                   
   74                   		;------	The TIMEOUT macro will do nothing unless
   75                   		;------ AUTO_TIMEOUT_USER has been defined in which 
   76                   		;------	system will turn off after a given amount of
   77      TRUE         	  #IFNDEF NO_RICOH_PATCH
   78 1559:AD F9 FF     		lda MAPCTL
   79 155C:48           		pha
   80 155D:09 01        		 ora #SUZY_SPACE
   81 155F:8D F9 FF     		 sta MAPCTL
   82                   		 TIMEOUT
    1                 + 
   83 1562:68           		pla
   84 1563:8D F9 FF     		sta MAPCTL
   85                   	  #ELSE
   87                   	  #ENDIF ;NDEF NO_RICOH_PATCH
   88                   
   89                   		;------	Turn on the display, and then EOF flag
   90                   ;!!! New:  invoke the DISPLAY macro here during EOF pr
   91                   		DISPLAY
    1 1566:AD 3F 0C   + 		LDA	DISPCTL_RAM
    2 1569:8D 92 FD   + 		STA	DISPCTL
    3 156C:29 02      + 		AND	#DISP_FLIP
    4 156E:F0 **      + 		BEQ	DISPLAY.003C
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   68
                        6502:src/display.src            18:23:55  

    5 1570:AD 44 0C   + 		LDA	DisplayBuffer
    6 1573:18         + 		CLC
    7 1574:69 DF      + 		ADC	#<DISPLAY_BUFSIZE-1
    8 1576:AA         + 		TAX
    9 1577:AD 45 0C   + 		LDA	DisplayBuffer+1
   10 157A:69 1F      + 		ADC	#>DISPLAY_BUFSIZE-1
   11 157C:80 **      + 		BRA	DISPLAY.003C2
   12 157E:           + DISPLAY.003C
   13 157E:AE 44 0C   + 		LDX	DisplayBuffer
   14 1581:AD 45 0C   + 		LDA	DisplayBuffer+1
   15 1584:           + DISPLAY.003C2
   16                   		DISP_AX
    1 1584:08         + 		PHP
    2 1585:78         + 		SEI
    3 1586:8E 94 FD   + 		STX	DISPADRL
    4 1589:8D 95 FD   + 		STA	DISPADRH
    5 158C:28         + 		PLP
    6                 + 
   17                 + 
   92                   
   93      TRUE         	  #IFDEF FRAMECOUNT_UP
   94                   		;------	Increment the DisplayFrameCount
   95 158D:EE 40 15     		INC	DisplayFrameCount
   96                   	  #ELSE ; put this #ELSE here to avoid both UP and DO
  104                   	  #ENDIF
  105                   
  106 1590:AD 47 0C     		LDA	DisplayFlags
  107 1593:09 80        		ORA	#DISPLAY_EOFFLAG
  108 1595:8D 47 0C     		STA	DisplayFlags
  109                   
  110 1598:7A           		PLY
  111 1599:             FrameEndExit
  112                   		;------	This vector ought to be patched by the Init 
  113 1599:4C 37 15     		JMP	IntReturn
  114                   
  115                   
  116                   	#ELSE ; of #IFDEF EOF_USER
  160                   	#ENDIF	; of #IFDEF EOF_USER
  161                   
  162                   * - - - - - - - - - - - - -  - - - - - - - - - - - - -
  163                   
  164                   
  165                   
  166                   
  167      FALSE        	#IFDEF	EOL_USER
  192                   	#ENDIF	; of #IFDEF EOL_USER
  193                   
  194                   
  195                   
  196                   
 1350                   	.in 6502:src/cart.src
    1                   ; Wednesday 18-Apr-90 08:45:32
    2                   * === cart.src =======================================
    3                   * 
    4                   * Game Cartridge I/O Routines  --  Handy Software
    5                   * 
    6                   * Confidential and Proprietary
    7                   * Copyright (C) 1989, Epyx, Inc.
    8                   * 
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   69
                        6502:src/cart.src               18:23:55  

    9                   * Date		Name		Description
   10                   * ---------	-------------	----------------------------
   11                   * 11-Apr-90	SHL		Code optimized for size and speed
   12                   *				Registers for OpenFile0 and SetCartAddress
   13                   *				arguments changed: A = cartridge page,
   14                   *				X,Y = byte offset into page
   15                   *				SetCartPage now takes argument in A reg
   16                   *				GetDirAddress routine rewritten, returns
   17                   *				arguments as expected for OPENFILE routine
   18                   *				GetDirAddressFast routine removed
   19                   *
   20                   * 26-Feb-90	SHL		Removed all references to WRITECART_U
   21                   *				Minor code tightening
   22                   * 14-Feb-90	SHL		Fixed a horrible error that turns off
   23                   *				during file reads that cross page boundaries
   24                   * 7-Feb-90	SHL		Minor math touch-up work (slightly spe
   25                   * 7-Feb-90	SHL		Fixed bug in math usage in GetDirAddre
   26                   * 1 June 89	-RJ		Vectored RESTORE_CART usage to a subr
   27                   * 15 May 89	-RJ		Made SetCartOffset use of RCART_1 int
   28                   * 20 Apr 89	=RJ Mical=	Created this file!
   29                   * 
   30                   * ====================================================
   31                   
   32                   
   33                   
   34 159C:             CartOffsetLow	.DS	1
   35      TRUE          #IF ROMPAGESIZE>256
   36 159D:             CartOffsetHigh	.DS	1
   37                    #ENDIF
   38 159E:             CartPage	.DS	1
   39 159F:             CartIOCount	.DS	2
   40      TRUE         	#IFNDEF	ROM_NODIR
   41 15A1:             CartDirectory	.DS	ROMDIR_ENTRY_SIZE
   42                   	#ENDIF
   43                   
   44                   
   45                   
   46      TRUE         	#IFNDEF	ROM_NODIR
   47                   
   48 15A9:             OpenFile0
   49                   * ****************************************************
   50                   * OpenFile0 "opens" a file by reading its directory en
   51                   * CartDirectory buffer and then setting the hardware r
   52                   * first data byte.  On entry, the cartridge address of
   53                   * is specified with the page in X and the offset in A,
   54                   * 
   55                   * ON ENTRY:
   56                   *     - A has the cartridge page of the file's directo
   57                   *     - X,Y (low,high) has the offset of the file's di
   58                   * 
   59                   * ON EXIT:
   60                   *     - A, X and Y are trashed
   61                   *     - CartPage and CartOffsetLow,High are set
   62                   *     - CartDirectory contains the a copy of the file'
   63                   *     - The cart hardware is ready to read the first b
   64                   
   65                   		;------	Set up address of the directory specified by
   66 15A9:20 ** **     		JSR SetCartAddress
   67                   
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   70
                        6502:src/cart.src               18:23:55  

   68                   		;------	Read the directory
   69 15AC:A9 09        		LDA #<{ROMDIR_ENTRY_SIZE+1}
   70 15AE:8D 9F 15     		STA CartIOCount
   71 15B1:A9 01        		LDA #>{ROMDIR_ENTRY_SIZE+$100}
   72 15B3:8D A0 15     		STA CartIOCount+1
   73 15B6:A9 A1        		LDA #<CartDirectory
   74 15B8:85 00        		STA sysptr
   75 15BA:A9 15        		LDA #>CartDirectory
   76 15BC:85 01        		STA sysptr+1
   77 15BE:20 ** **     		JSR readCart0Grunt
   78                   
   79                   		;------	Set up to read the first byte of the file
   80 15C1:AD A1 15     		LDA CartDirectory+ROMDIR_PAGE
   81 15C4:AE A2 15     		LDX CartDirectory+ROMDIR_OFFSET
   82      TRUE          #IF ROMPAGESIZE>256
   83 15C7:AC A3 15     		LDY CartDirectory+ROMDIR_OFFSET+1
   84                    #ENDIF
   85                   
   86                   * ... and fall into SetCartAddress
   87                   
   88                   	#ENDIF	; of #IFNDEF ROM_NODIR
   89                   
   90                   
   91                   
   92 15CA:             SetCartAddress
   93                   * ****************************************************
   94                   * This routine sets the cartridge ports to be ready to
   95                   * byte addressed by the page in X and the offset in A,
   96                   * 
   97                   * WARNING:  this routine is fallen into from above.
   98                   * 
   99                   * ON ENTRY:
  100                   *     - X has the page of the cartridge address
  101                   *     - A,Y (low,high) has the offset of the address
  102                   * 
  103                   * ON EXIT:
  104                   *     - A, X and Y are trashed
  105                   *     - CartPage and CartOffsetLow,High are set
  106                   *     - The cart hardware is ready to read the first b
  107                   
  108 15CA:8D 9E 15     		STA CartPage	; Save the cartridge 1 values
  109 15CD:8E 9C 15     		STX CartOffsetLow
  110      TRUE          #IF ROMPAGESIZE>256
  111 15D0:8C 9D 15     		STY CartOffsetHigh
  112                    #ENDIF
  113                   
  114 15D3:20 ** **     		JSR SetCartPage
  115                   
  116                   * ... and fall into SetCartOffset to advance the cartr
  117                   * the desired offset
  118                   
  119                   
  120                   
  121 15D6:             SetCartOffset
  122                   * ****************************************************
  123                   * This routine reads the cartridge (using port 0) unti
  124                   * advanced to the byte described by CartOffsetLow,High
  125                   * is currently at offset 0.  
  126                   * 
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   71
                        6502:src/cart.src               18:23:55  

  127                   * NOTE:  this code fallen into from above
  128                   * 
  129                   * ON ENTRY:
  130                   *     - CartOffsetLow,High has the offset
  131                   *     - Cart hardware is set to read byte 0 of the pag
  132                   * 
  133                   * ON EXIT:
  134                   *     - The cart hardware is advanced to the specified
  135                   
  136 15D6:AC 9D 15     	ldy CartOffsetHigh	; get desired offset
  137 15D9:AE 9C 15     	ldx CartOffsetLow
  138 15DC:C8           	iny			; increment for zero checking
  139 15DD:E8           	inx
  140 15DE:80 **        	bra .10
  141                   
  142 15E0:AD B2 FC     .20	    lda RCART_0		; count off bytes to advance cart
  143 15E3:CA           .10	    dex
  144 15E4:D0 FA        	   bne .20
  145 15E6:88           .30	  dey
  146 15E7:D0 F7        	 bne .20
  147                   
  148                   ;	jmp RestoreReturn	; fall through
  149                   
  150 15E9:             RestoreReturn
  151                   	RESTORE_CART
    1 15E9:AD 40 0C   + 		LDA IODAT_RAM
    2      FALSE        	  #IFDEF RAMCART_USER
    4                 + 	  #ELSE
    5 15EC:09 02      + 		ORA #CART_POWER_OFF	
    6                 + 	  #ENDIF
    7 15EE:8D 40 0C   + 		STA IODAT_RAM
    8 15F1:8D 8B FD   + 		STA IODAT
    9                 + 
  152 15F4:60           	rts
  153                   
  154                   
  155                   
  156      TRUE         	#IFNDEF	ROM_NODIR
  157                   
  158 15F5:             ReadFile0
  159                   * ****************************************************
  160                   * This routine will read an entire game cartridge file
  161                   * that the cartridge 0 port is all set up to start rea
  162                   * that sysptr points to the directory entry of the fil
  163                   * CartDirectory buffer is filled out, and that CartPag
  164                   * CartOffsetLow,High reflect the state of port 0.  
  165                   * 
  166                   * ON ENTRY:
  167                   *    - If you have specified that the file directory h
  168                   *      which specifies that the directory has a RAM de
  169                   *         If the A register is non-zero, X,Y (low,high
  170                   *         the RAM destination for the file; if A is ze
  171                   *         destination is taken from the directory entr
  172                   *    - If you have not specified that the file directo
  173                   *      field you must specify RAM destination of the f
  174                   *         X,Y (low,high) has the RAM destination for t
  175                   *    - The cartridge 0 port is all set up to read the 
  176                   * 
  177                   * ON EXIT:
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   72
                        6502:src/cart.src               18:23:55  

  178                   *    - CartPage and CartOffsetLow,High are advanced to
  179                   *      the last byte read
  180                   *    - X,Y (low,high) has RAM address of the byte beyo
  181                   
  182                   
  183                   ;??? For now, presume that all data will be coming fro
  184                   ;??? entry.  Later, it will come from either there or 
  185                   ;??? list if the programmer is willing to burn the byt
  186                   
  187      TRUE         	#IFDEF	ROMDIR_DEST
  188 15F5:C9 01        	cmp #1
  189 15F7:B0 **        	bcs .30
  190 15F9:AE A5 15     	ldx CartDirectory+ROMDIR_DEST	; get RAM destination f
  191 15FC:AC A6 15     	ldy CartDirectory+ROMDIR_DEST+1
  192                   	#ENDIF
  193                   
  194 15FF:AD A8 15     .30	lda CartDirectory+ROMDIR_SIZE+1	; set up count of 
  195 1602:1A           	ina
  196 1603:8D A0 15     	sta CartIOCount+1
  197 1606:AD A7 15     	lda CartDirectory+ROMDIR_SIZE
  198 1609:1A           	ina
  199 160A:8D 9F 15     	sta CartIOCount
  200                   
  201 160D:86 00        	STX sysptr		; X,Y has the RAM destination pointer
  202 160F:84 01        	STY sysptr+1
  203                   
  204                   ;	jmp readCart0Grunt	; fall through
  205                   
  206                   
  207                   	#ENDIF	; of #IFNDEF ROM_NODIR
  208                   
  209                   
  210                   
  211 1611:             readCart0Grunt
  212                   * ****************************************************
  213                   * Grunt routine used by several cart-reading routines,
  214                   * have been tended to and everything is ready for the 
  215                   * 
  216                   * ON ENTRY:
  217                   *    - CartIOCount is initialized to number of bytes t
  218                   *      byte incremented once (for instance: to read $0
  219                   *      CartIOCount to $0224, to read $04ff bytes set C
  220                   *    - sysptr points to buffer for incoming data
  221                   *    - CartOffsetLow,High and CartPage to have valid n
  222                   * 
  223                   * ON EXIT:
  224                   *    - CartPage and CartOffsetLow,High are advanced to
  225                   *      the last byte read
  226                   *    - X,Y (low,high) have RAM address of the byte bey
  227                   
  228                   	SET_TO_READ_CART
    1 1611:AD 40 0C   + 		LDA	IODAT_RAM
    2 1614:29 FD      + 		AND	#~CART_POWER_OFF 
    3      FALSE        	  #IFDEF RAMCART_USER
    5                 + 	  #ENDIF
    6 1616:8D 40 0C   + 		STA	IODAT_RAM
    7 1619:8D 8B FD   + 		STA	IODAT
    8                 + 
  229                   
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   73
                        6502:src/cart.src               18:23:55  

  230 161C:AE 9C 15     	ldx CartOffsetLow	; ROMPAGESIZE is assumed to be mult
  231      TRUE          #IF ROMPAGESIZE>256
  232 161F:38           	sec			; set Y to complement of CartOffsetHigh
  233 1620:AD 9D 15     	lda CartOffsetHigh	;  to facilitate bounds checking
  234 1623:E9 04        	sbc #>ROMPAGESIZE
  235 1625:A8           	tay
  236                    #ENDIF
  237                   
  238 1626:CE 9F 15     .30	      dec CartIOCount	; count down bytes to read
  239 1629:F0 **        	      beq .31
  240 162B:AD B2 FC     .32	      LDA RCART_0	; read and store byte
  241 162E:92 00        	      STA (sysptr)
  242 1630:E6 00        	      inc sysptr
  243 1632:F0 **        	      beq .44
  244                   
  245 1634:E8           .33	      inx		; bump the cart page counters
  246 1635:D0 EF        	     BNE .30
  247      TRUE          #IF ROMPAGESIZE>256
  248 1637:C8           	    iny
  249 1638:D0 EC        	   BNE .30
  250                    #ENDIF
  251                   
  252 163A:EE 9E 15     	  inc CartPage		; get next page from cartridge
  253 163D:AD 9E 15     	  lda CartPage
  254 1640:20 ** **     	  JSR SetCartPage
  255                   
  256 1643:A2 00        	  ldx #<{-ROMPAGESIZE}	; set count to read whole page
  257      TRUE          #IF ROMPAGESIZE>256
  258 1645:A0 FC        	  ldy #>{-ROMPAGESIZE}
  259                    #ENDIF
  260 1647:80 DD        	 BRA .30
  261                   
  262 1649:E6 01        .44	      INC sysptr+1	; not done frequently so pulled
  263 164B:80 E7        	      bra .33
  264                   
  265                   
  266 164D:CE A0 15     .31	      dec CartIOCount+1	; check to see if load is 
  267 1650:D0 D9        	      bne .32		; if not, get back in there
  268                   
  269 1652:8E 9C 15     .80	stx CartOffsetLow	; ROMPAGESIZE is assumed to be m
  270      TRUE          #IF ROMPAGESIZE>256
  271 1655:18           	clc			; restore true offset value
  272 1656:98           	tya
  273 1657:69 04        	ADC #>ROMPAGESIZE
  274 1659:8D 9D 15     	STA CartOffsetHigh
  275                    #ENDIF
  276                   
  277 165C:A6 00        	ldx sysptr
  278 165E:A4 01        	ldy sysptr+1
  279                   
  280 1660:4C E9 15     	jmp RestoreReturn	; only affects A register
  281                   
  282                   
  283                   
  284                   * ****************************************************
  285                   * SetCartPage strobes the cartridge page number in A i
  286                   * The result of this also leaves the counter reset to 
  287                   *
  288                   * On return, A, X and Y are trashed, and ROM power is 
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   74
                        6502:src/cart.src               18:23:55  

  289                   
  290 1663:             SetCartPage
  291 1663:8D ** **     	sta .ff
  292                   
  293 1666:AD 40 0C     	lda IODAT_RAM
  294 1669:09 0A        	ora #RESTLESS+CART_ADDR_DATA
  295 166B:A8           	tay
  296 166C:29 FD        	and #~CART_ADDR_DATA
  297                   
  298 166E:38           	sec
  299 166F:80 **        	bra .2
  300 1671:90 **        .0	  bcc .1
  301 1673:8C 8B FD     	  sty IODAT	; set CART_ADDR_DATA to clock in 1 bit
  302 1676:18           	  clc
  303 1677:E8           .1	  inx		; ldx #3, adds in CART_ADDR_STROBE
  304 1678:8E 87 FD     	  stx SYSCTL1
  305 167B:A2 02        .2	  ldx #POWERON
  306 167D:8E 87 FD     	  stx SYSCTL1
  307 1680:2E ** **     	  rol .ff
  308 1683:8D 8B FD     	  sta IODAT	; reset CART_ADDR_DATA to clock 0 bit and
  309 1686:D0 E9        	 bne .0
  310                   
  311 1688:60           	rts
  312                   
  313 1689:00           .ff	.BY 0
  314                   
  315                   
  316                   
  317                   
  318                   ;	#IFDEF	GETDIR_USER
  319                   ;
  320                   ;GetDirAddress
  321                   ;* ***************************************************
  322                   ;
  323                   ;		;------	Get copy of file number
  324                   ;		TAY
  325                   ;		INY	; Increment it so we can count down to zero
  326                   ;
  327                   ;		;------	Init the result fields to the file 0 entry
  328                   ;		LDX	#ROMDIR_FILE0_PAGE	; X will keep the page
  329                   ;		LDA	#<ROMDIR_FILE0_OFFSET
  330                   ;		STA	.FE
  331                   ;		LDA	#>ROMDIR_FILE0_OFFSET
  332                   ;		STA	.FF
  333                   ;
  334                   ;.10		;------	Loop until file number is reduced to zer
  335                   ;		DEY
  336                   ;		BEQ	.20
  337                   ;
  338                   ;		;------	Add the size of an entry to the current car
  339                   ;		LDA	#ROMDIR_ENTRY_SIZE
  340                   ;		CLC
  341                   ;		ADC	.FE
  342                   ;		STA	.FE
  343                   ;	bcc .11
  344                   ;	inc .ff
  345                   ;;		LDA	#0
  346                   ;;		ADC	.FF
  347                   ;;		STA	.FF
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   75
                        6502:src/cart.src               18:23:55  

  348                   ;
  349                   ;		;------	Compare the current offset with the largest
  350                   ;		;------	allowable offset
  351                   ;.11		LDA	#<ROMPAGESIZE-1
  352                   ;		CMP	.FE
  353                   ;		LDA	#>ROMPAGESIZE-1
  354                   ;		SBC	.FF
  355                   ;		BCS	.10		; Branch if offset <= largest allowed
  356                   ;
  357                   ;		;------	Offset too big.  Back offset down by one pa
  358                   ;		;------	bump page
  359                   ;		LDA	.FE
  360                   ;		SEC
  361                   ;		SBC	#<ROMPAGESIZE
  362                   ;		STA	.FE
  363                   ;		LDA	.FF
  364                   ;		SBC	#>ROMPAGESIZE
  365                   ;		STA	.FF
  366                   ;		INX
  367                   ;		BRA	.10		; Go do it again
  368                   ;
  369                   ;.20		;------	Return with the registers containing the
  370                   ;		LDA	.FE
  371                   ;		LDY	.FF
  372                   ;		RTS
  373                   ;
  374                   ;.FE		.DS	1
  375                   ;.FF		.DS	1
  376                   ;
  377                   ;	#ENDIF	; of #IFDEF GETDIR_USER
  378                   ;
  379                   ;
  380                   ;	#IFDEF	GETDIRFAST_USER
  381                   ;
  382                   ;GetDirAddressFast
  383                   ;* ***************************************************
  384                   ;
  385                   ;		;------	Create the offset from the start of the dir
  386                   ;		;------	this directory entry
  387                   ;		STA MATHD
  388                   ;		STZ MATHC
  389                   ;		LDA #ROMDIR_ENTRY_SIZE
  390                   ;		STA MATHB
  391                   ;		STZ MATHA	; MULTIPLY
  392                   ;
  393                   ;		;------	Create the page of this entry by adding the
  394                   ;		;------	ROM header to the directory entry offset an
  395                   ;		;------	dividing this by the size of a page
  396                   ;		LDA	#<ROMPAGESIZE
  397                   ;		WAITMATH
  398                   ;		STA	MATHP
  399                   ;		LDA	#>ROMPAGESIZE
  400                   ;		STA	MATHN
  401                   ;		LDA	#<ROM_HEADER_SIZE
  402                   ;		CLC
  403                   ;		ADC	MATHH
  404                   ;		TAX
  405                   ;		LDA	#>ROM_HEADER_SIZE
  406                   ;		ADC	MATHG
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   76
                        6502:src/cart.src               18:23:55  

  407                   ;		STX	MATHH
  408                   ;		STA	MATHG
  409                   ;		LDA	#0
  410                   ;		ADC	MATHF
  411                   ;		STA	MATHF
  412                   ;		STZ	MATHE	; DIVIDE
  413                   ;
  414                   ;		;------	Create the byte offset of the entry by subt
  415                   ;		;------	start byte offset from the real byte offset
  416                   ;		;------	Wouldn't have to do this if division remain
  417                   ;		WAITMATH
  418                   ;		lda	MATHH
  419                   ;		ldy	MATHG
  420                   ;
  421                   ;		ldx	#<ROMPAGESIZE
  422                   ;		stx	MATHB
  423                   ;		ldx	#>ROMPAGESIZE
  424                   ;		stx	MATHA	; MULTIPLY
  425                   ;
  426                   ;		SEC
  427                   ;		WAITMATH
  428                   ;		SBC	MATHH
  429                   ;		TAX
  430                   ;		tya
  431                   ;		SBC	MATHG
  432                   ;		TAY
  433                   ;		TXA
  434                   ;		LDX	MATHD
  435                   ;
  436                   ;		RTS
  437                   ;
  438                   ;.FD		.DS	1
  439                   ;.FE		.DS	1
  440                   ;
  441                   ;	#ENDIF	; of #IFDEF GETDIRFAST_USER
  442                   
  443                   
  444      TRUE         	#IFDEF GETDIR_USER | GETDIRFAST_USER
  445                   
  446                   * GetDirAddress calculates the ROM address of the dire
  447                   * specified in the A register
  448                   *
  449                   * ROMPAGESIZE is assumed to be one of 256, 512, 1024, 
  450                   *
  451                   * On exit:
  452                   *	A = page number
  453                   *	X,Y = byte offset into page
  454                   
  455 168A:             GetDirAddress
  456      TRUE           #IF ROMDIR_ENTRY_SIZE=8
  457 168A:9C ** **     	stz .ff
  458 168D:0A           	asl a
  459 168E:2E ** **     	rol .ff
  460 1691:0A           	asl a
  461 1692:2E ** **     	rol .ff
  462 1695:0A           	asl a
  463 1696:2E ** **     	rol .ff
  464                     #ELSE
  473                     #ENDIF
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   77
                        6502:src/cart.src               18:23:55  

  474                   
  475      TRUE           #IF ROM_HEADER_SIZE&$ff>0
  476 1699:69 9A        	adc #<ROM_HEADER_SIZE
  477                     #ENDIF
  478 169B:AA           	tax
  479      TRUE           #IF ROMDIR_ENTRY_SIZE=8
  480 169C:AD ** **     	lda .ff
  481                     #ELSE
  483                     #ENDIF
  484 169F:69 01        	adc #>ROM_HEADER_SIZE
  485      TRUE           #IF ROMPAGESIZE>256
  486 16A1:48           	 pha
  487 16A2:29 03        	  and #>{ROMPAGESIZE-1}
  488 16A4:A8           	  tay
  489 16A5:68           	 pla
  490 16A6:4A           	lsr a
  491      TRUE             #IF ROMPAGESIZE>512
  492 16A7:4A           	lsr a
  493      FALSE              #IF ROMPAGESIZE>1024
  495                         #ENDIF
  496                       #ENDIF
  497                     #ENDIF
  498                   
  499 16A8:60           	rts
  500                   
  501      TRUE           #IF ROMDIR_ENTRY_SIZE=8
  502 16A9:             .ff	.ds 1
  503                     #ENDIF
  504                   
  505                   	#ENDIF	; of #IFDEF GETDIR_USER | GETDIRFAST_USER
  506                   
  507                   
  508                   
  509                   
  510                   
  511                   
 1351      0A6C         len.sys		.eq *-beg.sys
 1352                   
   38                   	BEGIN_ZPAGE
    1      16AA       + TEMPORG	  .= *
    2 16AA:           + 	  .ORG NEXTZPG
    3                 + 
   39                   ; user zero page variables (use .ds only)
   40 003E:             my.var1	.ds 10
   41                   	END_ZPAGE
    1      0048       + NEXTZPG	  .= *
    2      FALSE        	  #IF NEXTZPG > $0100
    4                 + 	  #ENDIF
    5 0048:           + 	  .ORG TEMPORG
    6                 + 
   42                   
   43                   ; "game.start" must be the entry point for the game
   44                   
   45 16AA:             game.start
   46 16AA:A9 **        	lda #normal.pal
   47 16AC:20 C1 08     	jsr set.colors		;fade up from black
   48 16AF:A9 1E        	lda #30
   49 16B1:85 0F        	sta hscroll		;position "window on the world"
   50 16B3:A9 1E        	lda #30
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   78
                                                        18:23:55  

   51 16B5:85 0D        	sta vscroll
   52 16B7:A0 40        	ldy #$40		;start the music
   53 16B9:A2 **        	ldx #>tune.1
   54 16BB:A9 **        	lda #<tune.1
   55 16BD:20 8A 08     	jsr start.tune
   56                   
   57 16C0:A9 **        	lda #zapsnd		;make a sound on powerup
   58 16C2:20 E2 0B     	jsr start.sound
   59 16C5:A9 5E        	lda #64+30		;center the face
   60 16C7:8D ** **     	sta face+SCB_HPOS
   61 16CA:A9 3D        	lda #31+30
   62 16CC:8D ** **     	sta face+SCB_VPOS
   63                   ; ---- MAIN GAME LOOP ----
   64                   ; example
   65 16CF:             loop
   66 16CF:A2 **        	ldx #>blob
   67 16D1:A0 **        	ldy #<blob
   68 16D3:20 0A 05     	jsr do.sprite	;display a sprite
   69 16D6:A5 0C        	lda count		;this counts once per game frame
   70 16D8:29 7F        	and #$7f
   71 16DA:D0 **        	bne .01			;once in a while
   72 16DC:A9 **        	lda #gulp
   73 16DE:20 E2 0B     	jsr start.sound
   74 16E1:A9 01        	lda #$01
   75 16E3:20 07 0C     	jsr add.score
   76 16E6:             .01
   77                   ; display sprites
   78 16E6:A6 1A        	ldx my.player
   79 16E8:A6 19        	ldx number.of.players
   80 16EA:             face.loop
   81 16EA:B5 23        	lda level,x	;joystick/firebutton levels
   82 16EC:89 40        	bit #JOY_UP
   83 16EE:F0 **        	beq .02
   84 16F0:DE ** **     	dec facev,x
   85                   
   86 16F3:             .02
   87 16F3:89 80        	bit #JOY_DOWN
   88 16F5:F0 **        	beq .03
   89 16F7:FE ** **     	inc facev,x
   90 16FA:             .03
   91 16FA:89 10        	bit #JOY_LEFT
   92 16FC:F0 **        	beq .04
   93 16FE:DE ** **     	dec faceh,x
   94 1701:             .04
   95 1701:89 20        	bit #JOY_RIGHT
   96 1703:F0 **        	beq .05
   97 1705:FE ** **     	inc faceh,x
   98 1708:             .05
   99                   
  100                   
  101 1708:E4 1A        	cpx my.player		;check button for my.player only
  102 170A:D0 **        	bne .06
  103 170C:B5 27        	lda edge,x	;joystick/firebutton leading edges
  104 170E:89 01        	bit #BUTTON_A	
  105                   ;	bit #OPTION2_BUTTON
  106 1710:F0 **        	beq .06
  107 1712:DA           	phx
  108 1713:A9 **        	lda #lazsnd
  109 1715:20 E2 0B     	jsr start.sound
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   79
                                                        18:23:55  

  110 1718:A9 50        	lda #$50
  111 171A:20 07 0C     	jsr add.score
  112 171D:FA           	plx
  113 171E:             .06
  114 171E:BD ** **     	lda facev,x
  115 1721:8D ** **     	sta face+SCB_VPOS
  116 1724:BD ** **     	lda faceh,x
  117 1727:8D ** **     	sta face+SCB_HPOS
  118 172A:DA           	phx
  119 172B:A2 **        	ldx #>face
  120 172D:A0 **        	ldy #<face
  121 172F:20 0A 05     	jsr do.sprite	;display a sprite
  122 1732:FA           	plx
  123 1733:CA           	dex
  124 1734:10 B4        	bpl face.loop
  125                   
  126 1736:20 F8 04     	jsr game.frame	;wait for next game frame (& display s
  127 1739:80 94        	bra loop
  128                   
  129                   
  130 173B:             tune.1
  131 173B:0A7D         	.pc music.dnl
  132                   
  133                   
  134                   ; this is a table of pointers to color palettes
  135                   ; the first one must be all 0's
  136                   ; the game should supplly the palettes
  137                   
  138 21B8:             color.pnts
  139 21B8:00 ** ** **  	.wo all.black,pal1,pal2
  139      ** **        
  140                   
  141 21BE:             all.black
  142      0000         black.pal	.eq 0
  143                   ;green
  144 21BE:00 00 00 00  	.by $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$
  144      00 00 00 00  
  144      00 00 00 00  
  144      00 00 00 00  
  144                   
  145                   ;bluered
  146 21CE:00 00 00 00  	.by $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$
  146      00 00 00 00  
  146      00 00 00 00  
  146      00 00 00 00  
  146                   
  147                   
  148 21DE:             pal1
  149      0001         normal.pal	.eq 1
  150                   ; Handy Color Palette
  151                   ; Greens
  152 21DE:00 07 05 03  	.BYTE	$00,$07,$05,$03,$00,$00,$0f,$00
  152      00 00 0F 00  
  152                   
  153 21E6:00 02 03 06  	.BYTE	$00,$02,$03,$06,$0b,$00,$04,$07
  153      0B 00 04 07  
  153                   
  154                   ; Blues-Reds
  155                   
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   80
                                                        18:23:55  

  156 21EE:F0 06 00 00  	.BYTE	$f0,$06,$00,$00,$06,$0f,$0f,$f0
  156      06 0F 0F F0  
  156                   
  157 21F6:00 04 28 6B  	.BYTE	$00,$04,$28,$6b,$cf,$6d,$00,$00
  157      CF 6D 00 00  
  157                   
  158 21FE:             pal2
  159      0002         star.pal	.eq 2
  160                   ;greys (starfield)
  161                   ;green
  162 21FE:00 06 00 00  	.by $00,$06,$00,$00,$00,$00,$0f,$00,$02,$04,$07,$0b,$
  162      00 00 0F 00  
  162      02 04 07 0B  
  162      0F 06 09 0F  
  162                   
  163                   ;bluered
  164 220E:00 F6 F0 90  	.by $00,$f6,$f0,$90,$0a,$0f,$0f,$f0,$22,$44,$77,$bb,$
  164      0A 0F 0F F0  
  164      22 44 77 BB  
  164      FF 00 00 00  
  164                   
  165                   
  166                   
  167                   
  168                   ; name for sounds
  169      0000         small.bang	.eq 0
  170      0001         mid.bang	.eq 1
  171      0002         big.bang	.eq 2
  172      0003         shoot		.eq 3
  173      0004         boing		.eq 4
  174      0005         zapsnd		.eq 5
  175      0006         gulp		.eq 6
  176      0007         lazsnd		.eq 7
  177      0008         shieldsnd	.eq 8
  178      0009         elevsnd		.eq 9
  179      000A         boggle		.eq 10
  180      000B         transnd		.eq 11
  181      000C         whoosh		.eq 12
  182      000D         giggle		.eq 13
  183      000E         my.bang		.eq 14
  184                   
  185                   ; these are sound priorities
  186 221E:             sound.pri
  187 221E:65 67 69 5B  	.by 101,103,105,91,33,201,249,49,53
  187      21 C9 F9 31  
  187      35           
  188 2227:F7           	.by 247
  189 2228:39           	.by 57
  190 2229:FB           	.by 251
  191 222A:37           	.by 55
  192 222B:3D           	.by 61
  193 222C:FD           	.by 253
  194                   
  195                   ; pointers to sounds
  196 222D:             sound.lo
  197 222D:00 ** **     	.by <small.bang.fxdata,<mid.bang.fxdata,<big.bang.fxd
  198 2230:00 ** **     	.by <shoot.fxdata,<boing.fxdata,<zap.fxdata
  199 2233:00           	.by <gulp.fxdata
  200 2234:00           	.by <laz.fxdata
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   81
                                                        18:23:55  

  201 2235:00           	.by <shield.fxdata
  202 2236:00           	.by <elevator.fxdata
  203 2237:00           	.by <boggle.fxdata
  204 2238:00           	.by <trans.fxdata
  205 2239:00           	.by <whoosh.fxdata
  206 223A:00           	.by <giggle.fxdata
  207 223B:00           	.by <my.bang.fxdata
  208                   
  209 223C:             sound.hi
  210 223C:00 ** **     	.by >small.bang.fxdata,>mid.bang.fxdata,>big.bang.fxd
  211 223F:00 ** **     	.by >shoot.fxdata,>boing.fxdata,>zap.fxdata
  212 2242:00           	.by >gulp.fxdata
  213 2243:00           	.by >laz.fxdata
  214 2244:00           	.by >shield.fxdata
  215 2245:00           	.by >elevator.fxdata
  216 2246:00           	.by >boggle.fxdata
  217 2247:00           	.by >trans.fxdata
  218 2248:00           	.by >whoosh.fxdata
  219 2249:00           	.by >giggle.fxdata
  220 224A:00           	.by >my.bang.fxdata
  221                   
  222 224B:             small.bang.fxdata
  223                   	;------ Next Frame
  224 224B:00 00        	.WORD	0	; Frame number
  225 224D:B8 0F        	.WORD	$0fb8	; Flags
  226 224F:FC 1F        	.WORD	$1ffc	; Freq accum
  227 2251:FF FF        	.WORD	$ffff	; Shifter accum
  228 2253:10 C0        	.WORD	$c010	; Feedback accum
  229 2255:00 00        	.WORD	$0000	; Volume accum
  230 2257:74 FC        	.WORD	$fc74	; Freq interp
  231 2259:03 00        	.WORD	$0003	; Feedback interp
  232 225B:55 03        	.WORD	$0355	; Volume interp
  233                   	;------ Next Frame
  234 225D:09 00        	.WORD	9	; Frame number
  235 225F:B8 0F        	.WORD	$0fb8	; Flags
  236 2261:08 00        	.WORD	$0008	; Freq accum
  237 2263:16 F0        	.WORD	$f016	; Shifter accum
  238 2265:30 C0        	.WORD	$c030	; Feedback accum
  239 2267:00 1E        	.WORD	$1e00	; Volume accum
  240 2269:0A 00        	.WORD	$000a	; Freq interp
  241 226B:DA F6        	.WORD	$f6da	; Feedback interp
  242 226D:93 FE        	.WORD	$fe93	; Volume interp
  243                   	;------ Next Frame
  244 226F:1E 00        	.WORD	30	; Frame number
  245 2271:01 00        	.WORD	$0001	; Flags
  246                   
  247 2273:             mid.bang.fxdata
  248                   	;------ Next Frame
  249 2273:00 00        	.WORD	0	; Frame number
  250 2275:B8 0F        	.WORD	$0fb8	; Flags
  251 2277:FC FF        	.WORD	$fffc	; Freq accum
  252 2279:FF FF        	.WORD	$ffff	; Shifter accum
  253 227B:10 C0        	.WORD	$c010	; Feedback accum
  254 227D:00 00        	.WORD	$0000	; Volume accum
  255 227F:91 E3        	.WORD	$e391	; Freq interp
  256 2281:03 00        	.WORD	$0003	; Feedback interp
  257 2283:1C 09        	.WORD	$091c	; Volume interp
  258                   	;------ Next Frame
  259 2285:09 00        	.WORD	9	; Frame number
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   82
                                                        18:23:55  

  260 2287:B8 0F        	.WORD	$0fb8	; Flags
  261 2289:10 00        	.WORD	$0010	; Freq accum
  262 228B:16 F0        	.WORD	$f016	; Shifter accum
  263 228D:30 C0        	.WORD	$c030	; Feedback accum
  264 228F:00 52        	.WORD	$5200	; Volume accum
  265 2291:1B 00        	.WORD	$001b	; Freq interp
  266 2293:00 00        	.WORD	$0000	; Feedback interp
  267 2295:B8 FF        	.WORD	$ffb8	; Volume interp
  268                   	;------ Next Frame
  269 2297:2C 01        	.WORD	300	; Frame number
  270 2299:01 00        	.WORD	$0001	; Flags
  271                   
  272 229B:             big.bang.fxdata
  273                   	;------ Next Frame
  274 229B:00 00        	.WORD	0	; Frame number
  275 229D:B8 0F        	.WORD	$0fb8	; Flags
  276 229F:FC FF        	.WORD	$fffc	; Freq accum
  277 22A1:FF FF        	.WORD	$ffff	; Shifter accum
  278 22A3:10 C0        	.WORD	$c010	; Feedback accum
  279 22A5:00 00        	.WORD	$0000	; Volume accum
  280 22A7:E8 E3        	.WORD	$e3e8	; Freq interp
  281 22A9:03 00        	.WORD	$0003	; Feedback interp
  282 22AB:1C 0E        	.WORD	$0e1c	; Volume interp
  283                   	;------ Next Frame
  284 22AD:09 00        	.WORD	9	; Frame number
  285 22AF:B8 0F        	.WORD	$0fb8	; Flags
  286 22B1:1C 03        	.WORD	$031c	; Freq accum
  287 22B3:16 F0        	.WORD	$f016	; Shifter accum
  288 22B5:30 C0        	.WORD	$c030	; Feedback accum
  289 22B7:00 7F        	.WORD	$7f00	; Volume accum
  290 22B9:02 00        	.WORD	$0002	; Freq interp
  291 22BB:00 00        	.WORD	$0000	; Feedback interp
  292 22BD:C9 FF        	.WORD	$ffc9	; Volume interp
  293                   	;------ Next Frame
  294 22BF:58 02        	.WORD	600	; Frame number
  295 22C1:01 00        	.WORD	$0001	; Flags
  296                   
  297 22C3:             shoot.fxdata
  298                   	;------ Next Frame
  299 22C3:00 00        	.WORD	0	; Frame number
  300 22C5:90 0F        	.WORD	$0f90	; Flags
  301 22C7:08 00        	.WORD	$0008	; Freq accum
  302 22C9:83 FC        	.WORD	$fc83	; Shifter accum
  303 22CB:00 02        	.WORD	$0200	; Feedback accum
  304 22CD:00 7F        	.WORD	$7f00	; Volume accum
  305 22CF:4F 00        	.WORD	$004f	; Freq interp
  306 22D1:CD FD        	.WORD	$fdcd	; Volume interp
  307                   	;------ Next Frame
  308 22D3:32 00        	.WORD	50	; Frame number
  309 22D5:01 00        	.WORD	$0001	; Flags
  310                   
  311 22D7:             boing.fxdata
  312                   	;------ Next Frame
  313 22D7:00 00        	.WORD	0	; Frame number
  314 22D9:90 0F        	.WORD	$0f90	; Flags
  315 22DB:AC 04        	.WORD	$04ac	; Freq accum
  316 22DD:9F FC        	.WORD	$fc9f	; Shifter accum
  317 22DF:00 02        	.WORD	$0200	; Feedback accum
  318 22E1:00 7F        	.WORD	$7f00	; Volume accum
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   83
                                                        18:23:55  

  319 22E3:D9 FF        	.WORD	$ffd9	; Freq interp
  320 22E5:6F FD        	.WORD	$fd6f	; Volume interp
  321                   	;------ Next Frame
  322 22E7:1E 00        	.WORD	30	; Frame number
  323 22E9:01 00        	.WORD	$0001	; Flags
  324                   
  325 22EB:             zap.fxdata
  326                   	;------ Next Frame
  327 22EB:00 00        	.WORD	0	; Frame number
  328 22ED:B8 0F        	.WORD	$0fb8	; Flags
  329 22EF:00 00        	.WORD	$0000	; Freq accum
  330 22F1:FF FF        	.WORD	$ffff	; Shifter accum
  331 22F3:10 C0        	.WORD	$c010	; Feedback accum
  332 22F5:00 00        	.WORD	$0000	; Volume accum
  333 22F7:01 00        	.WORD	$0001	; Freq interp
  334 22F9:58 FD        	.WORD	$fd58	; Feedback interp
  335 22FB:C9 01        	.WORD	$01c9	; Volume interp
  336                   	;------ Next Frame
  337 22FD:47 00        	.WORD	71	; Frame number
  338 22FF:B8 0F        	.WORD	$0fb8	; Flags
  339 2301:4C 00        	.WORD	$004c	; Freq accum
  340 2303:0F FC        	.WORD	$fc0f	; Shifter accum
  341 2305:40 03        	.WORD	$0340	; Feedback accum
  342 2307:00 7F        	.WORD	$7f00	; Volume accum
  343 2309:22 00        	.WORD	$0022	; Freq interp
  344 230B:00 00        	.WORD	$0000	; Feedback interp
  345 230D:73 FF        	.WORD	$ff73	; Volume interp
  346                   	;------ Next Frame
  347 230F:2C 01        	.WORD	300	; Frame number
  348 2311:01 00        	.WORD	$0001	; Flags
  349                   
  350 2313:             laz.fxdata
  351                   	;------ Next Frame
  352 2313:00 00        	.WORD	0	; Frame number
  353 2315:98 0F        	.WORD	$0f98	; Flags
  354 2317:24 00        	.WORD	$0024	; Freq accum
  355 2319:C0 FF        	.WORD	$ffc0	; Shifter accum
  356 231B:10 C0        	.WORD	$c010	; Feedback accum
  357 231D:00 0A        	.WORD	$0a00	; Volume accum
  358 231F:0C 00        	.WORD	$000c	; Freq interp
  359 2321:41 00        	.WORD	$0041	; Volume interp
  360                   	;------ Next Frame
  361 2323:4E 00        	.WORD	78	; Frame number
  362 2325:01 00        	.WORD	$0001	; Flags
  363                   
  364 2327:             shield.fxdata
  365                   	;------ Next Frame
  366 2327:00 00        	.WORD	0	; Frame number
  367 2329:98 0F        	.WORD	$0f98	; Flags
  368 232B:34 02        	.WORD	$0234	; Freq accum
  369 232D:C0 FF        	.WORD	$ffc0	; Shifter accum
  370 232F:10 C0        	.WORD	$c010	; Feedback accum
  371 2331:00 17        	.WORD	$1700	; Volume accum
  372 2333:03 00        	.WORD	$0003	; Freq interp
  373 2335:44 00        	.WORD	$0044	; Volume interp
  374                   	;------ Next Frame
  375 2337:40 00        	.WORD	64	; Frame number
  376 2339:98 0B        	.WORD	$0b98	; Flags
  377 233B:1C 03        	.WORD	$031c	; Freq accum
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   84
                                                        18:23:55  

  378 233D:10 C0        	.WORD	$c010	; Feedback accum
  379 233F:00 28        	.WORD	$2800	; Volume accum
  380 2341:FD FF        	.WORD	$fffd	; Freq interp
  381 2343:00 00        	.WORD	$0000	; Volume interp
  382                   	;------ Next Frame
  383 2345:80 00        	.WORD	128	; Frame number
  384 2347:01 00        	.WORD	$0001	; Flags
  385                   
  386 2349:             elevator.fxdata
  387                   	;------ Next Frame
  388 2349:00 00        	.WORD	0	; Frame number
  389 234B:10 0F        	.WORD	$0f10	; Flags
  390 234D:00 00        	.WORD	$0000	; Freq accum
  391 234F:FE FF        	.WORD	$fffe	; Shifter accum
  392 2351:40 49        	.WORD	$4940	; Feedback accum
  393 2353:00 00        	.WORD	$0000	; Volume accum
  394 2355:00 01        	.WORD	$0100	; Volume interp
  395                   	;------ Next Frame
  396 2357:14 00        	.WORD	20	; Frame number
  397 2359:10 0F        	.WORD	$0f10	; Flags
  398 235B:24 00        	.WORD	$0024	; Freq accum
  399 235D:FE FF        	.WORD	$fffe	; Shifter accum
  400 235F:00 4B        	.WORD	$4b00	; Feedback accum
  401 2361:00 14        	.WORD	$1400	; Volume accum
  402 2363:02 00        	.WORD	$0002	; Volume interp
  403                   	;------ Next Frame
  404 2365:E8 03        	.WORD	1000	; Frame number
  405 2367:01 00        	.WORD	$0001	; Flags
  406 2369:             gulp.fxdata
  407                   	;------ Next Frame
  408 2369:00 00        	.WORD	0	; Frame number
  409 236B:88 0F        	.WORD	$0f88	; Flags
  410 236D:04 00        	.WORD	$0004	; Freq accum
  411 236F:87 FC        	.WORD	$fc87	; Shifter accum
  412 2371:00 02        	.WORD	$0200	; Feedback accum
  413 2373:00 7F        	.WORD	$7f00	; Volume accum
  414 2375:85 00        	.WORD	$0085	; Freq interp
  415                   	;------ Next Frame
  416 2377:1E 00        	.WORD	30	; Frame number
  417 2379:98 0B        	.WORD	$0b98	; Flags
  418 237B:9C 0F        	.WORD	$0f9c	; Freq accum
  419 237D:00 02        	.WORD	$0200	; Feedback accum
  420 237F:00 7F        	.WORD	$7f00	; Volume accum
  421 2381:E4 FF        	.WORD	$ffe4	; Freq interp
  422 2383:74 FF        	.WORD	$ff74	; Volume interp
  423                   	;------ Next Frame
  424 2385:AA 00        	.WORD	170	; Frame number
  425 2387:01 00        	.WORD	$0001	; Flags
  426                   
  427 2389:             boggle.fxdata
  428                   	;------ Next Frame
  429 2389:00 00        	.WORD	0	; Frame number
  430 238B:B0 0F        	.WORD	$0fb0	; Flags
  431 238D:AC 00        	.WORD	$00ac	; Freq accum
  432 238F:80 FC        	.WORD	$fc80	; Shifter accum
  433 2391:F0 01        	.WORD	$01f0	; Feedback accum
  434 2393:00 7F        	.WORD	$7f00	; Volume accum
  435 2395:07 00        	.WORD	$0007	; Freq interp
  436 2397:01 00        	.WORD	$0001	; Feedback interp
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   85
                                                        18:23:55  

  437 2399:E7 FE        	.WORD	$fee7	; Volume interp
  438                   	;------ Next Frame
  439 239B:64 00        	.WORD	100	; Frame number
  440 239D:B0 0F        	.WORD	$0fb0	; Flags
  441 239F:88 03        	.WORD	$0388	; Freq accum
  442 23A1:8B F4        	.WORD	$f48b	; Shifter accum
  443 23A3:A0 02        	.WORD	$02a0	; Feedback accum
  444 23A5:00 11        	.WORD	$1100	; Volume accum
  445 23A7:00 00        	.WORD	$0000	; Freq interp
  446 23A9:F5 FF        	.WORD	$fff5	; Feedback interp
  447 23AB:B5 FF        	.WORD	$ffb5	; Volume interp
  448                   	;------ Next Frame
  449 23AD:97 00        	.WORD	151	; Frame number
  450 23AF:01 00        	.WORD	$0001	; Flags
  451                   
  452 23B1:             trans.fxdata
  453                   	;------ Next Frame
  454 23B1:00 00        	.WORD	0	; Frame number
  455 23B3:98 0F        	.WORD	$0f98	; Flags
  456 23B5:60 00        	.WORD	$0060	; Freq accum
  457 23B7:FF FF        	.WORD	$ffff	; Shifter accum
  458 23B9:10 C0        	.WORD	$c010	; Feedback accum
  459 23BB:00 00        	.WORD	$0000	; Volume accum
  460 23BD:67 00        	.WORD	$0067	; Freq interp
  461 23BF:AB 01        	.WORD	$01ab	; Volume interp
  462                   	;------ Next Frame
  463 23C1:4C 00        	.WORD	76	; Frame number
  464 23C3:98 0F        	.WORD	$0f98	; Flags
  465 23C5:3C 1F        	.WORD	$1f3c	; Freq accum
  466 23C7:FF FF        	.WORD	$ffff	; Shifter accum
  467 23C9:10 00        	.WORD	$0010	; Feedback accum
  468 23CB:00 7F        	.WORD	$7f00	; Volume accum
  469 23CD:24 E1        	.WORD	$e124	; Freq interp
  470 23CF:00 81        	.WORD	$8100	; Volume interp
  471                   	;------ Next Frame
  472 23D1:4D 00        	.WORD	77	; Frame number
  473 23D3:98 0F        	.WORD	$0f98	; Flags
  474 23D5:60 00        	.WORD	$0060	; Freq accum
  475 23D7:FF FF        	.WORD	$ffff	; Shifter accum
  476 23D9:10 C0        	.WORD	$c010	; Feedback accum
  477 23DB:00 00        	.WORD	$0000	; Volume accum
  478 23DD:1C 00        	.WORD	$001c	; Freq interp
  479 23DF:65 02        	.WORD	$0265	; Volume interp
  480                   	;------ Next Frame
  481 23E1:82 00        	.WORD	130	; Frame number
  482 23E3:98 0F        	.WORD	$0f98	; Flags
  483 23E5:3C 06        	.WORD	$063c	; Freq accum
  484 23E7:FF FF        	.WORD	$ffff	; Shifter accum
  485 23E9:10 00        	.WORD	$0010	; Feedback accum
  486 23EB:00 7F        	.WORD	$7f00	; Volume accum
  487 23ED:E0 FC        	.WORD	$fce0	; Freq interp
  488 23EF:00 81        	.WORD	$8100	; Volume interp
  489                   	;------ Next Frame
  490 23F1:83 00        	.WORD	131	; Frame number
  491 23F3:98 0F        	.WORD	$0f98	; Flags
  492 23F5:1C 03        	.WORD	$031c	; Freq accum
  493 23F7:FF FF        	.WORD	$ffff	; Shifter accum
  494 23F9:10 C0        	.WORD	$c010	; Feedback accum
  495 23FB:00 00        	.WORD	$0000	; Volume accum
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   86
                                                        18:23:55  

  496 23FD:FE FF        	.WORD	$fffe	; Freq interp
  497 23FF:08 01        	.WORD	$0108	; Volume interp
  498                   	;------ Next Frame
  499 2401:FA 00        	.WORD	250	; Frame number
  500 2403:01 00        	.WORD	$0001	; Flags
  501 2405:             whoosh.fxdata
  502                   	;------ Next Frame
  503 2405:00 00        	.WORD	0	; Frame number
  504 2407:38 0F        	.WORD	$0f38	; Flags
  505 2409:4C 00        	.WORD	$004c	; Freq accum
  506 240B:BF FC        	.WORD	$fcbf	; Shifter accum
  507 240D:90 CB        	.WORD	$cb90	; Feedback accum
  508 240F:00 64        	.WORD	$6400	; Volume accum
  509 2411:A0 3C        	.WORD	$3ca0	; Feedback interp
  510 2413:00 A6        	.WORD	$a600	; Volume interp
  511                   	;------ Next Frame
  512 2415:01 00        	.WORD	1	; Frame number
  513 2417:B8 0F        	.WORD	$0fb8	; Flags
  514 2419:4C 00        	.WORD	$004c	; Freq accum
  515 241B:B5 FC        	.WORD	$fcb5	; Shifter accum
  516 241D:30 08        	.WORD	$0830	; Feedback accum
  517 241F:00 0A        	.WORD	$0a00	; Volume accum
  518 2421:FF FF        	.WORD	$ffff	; Freq interp
  519 2423:1A 05        	.WORD	$051a	; Feedback interp
  520 2425:50 01        	.WORD	$0150	; Volume interp
  521                   	;------ Next Frame
  522 2427:27 00        	.WORD	39	; Frame number
  523 2429:B8 0F        	.WORD	$0fb8	; Flags
  524 242B:04 00        	.WORD	$0004	; Freq accum
  525 242D:BF FC        	.WORD	$fcbf	; Shifter accum
  526 242F:10 CA        	.WORD	$ca10	; Feedback accum
  527 2431:00 3C        	.WORD	$3c00	; Volume accum
  528 2433:00 00        	.WORD	$0000	; Freq interp
  529 2435:80 01        	.WORD	$0180	; Feedback interp
  530 2437:00 3C        	.WORD	$3c00	; Volume interp
  531                   	;------ Next Frame
  532 2439:28 00        	.WORD	40	; Frame number
  533 243B:B8 0F        	.WORD	$0fb8	; Flags
  534 243D:04 00        	.WORD	$0004	; Freq accum
  535 243F:BF FC        	.WORD	$fcbf	; Shifter accum
  536 2441:90 CB        	.WORD	$cb90	; Feedback accum
  537 2443:00 78        	.WORD	$7800	; Volume accum
  538 2445:45 00        	.WORD	$0045	; Freq interp
  539 2447:F3 FD        	.WORD	$fdf3	; Feedback interp
  540 2449:29 FF        	.WORD	$ff29	; Volume interp
  541                   	;------ Next Frame
  542 244B:87 00        	.WORD	135	; Frame number
  543 244D:B8 0F        	.WORD	$0fb8	; Flags
  544 244F:FC 19        	.WORD	$19fc	; Freq accum
  545 2451:B1 FC        	.WORD	$fcb1	; Shifter accum
  546 2453:60 08        	.WORD	$0860	; Feedback accum
  547 2455:00 28        	.WORD	$2800	; Volume accum
  548 2457:A3 00        	.WORD	$00a3	; Freq interp
  549 2459:00 00        	.WORD	$0000	; Feedback interp
  550 245B:A3 FF        	.WORD	$ffa3	; Volume interp
  551                   	;------ Next Frame
  552 245D:D9 00        	.WORD	217	; Frame number
  553 245F:90 0F        	.WORD	$0f90	; Flags
  554 2461:7C 4E        	.WORD	$4e7c	; Freq accum
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   87
                                                        18:23:55  

  555 2463:B1 FC        	.WORD	$fcb1	; Shifter accum
  556 2465:70 08        	.WORD	$0870	; Feedback accum
  557 2467:00 0A        	.WORD	$0a00	; Volume accum
  558 2469:AB 04        	.WORD	$04ab	; Freq interp
  559 246B:C4 FF        	.WORD	$ffc4	; Volume interp
  560                   	;------ Next Frame
  561 246D:FF 00        	.WORD	255	; Frame number
  562 246F:01 00        	.WORD	$0001	; Flags
  563 2471:             giggle.fxdata
  564                   ; HSFX Table for SFX_1 sound effect
  565                   	;------ Next Frame
  566 2471:00 00        	.WORD	0	; Frame number
  567 2473:18 0F        	.WORD	$0f18	; Flags
  568 2475:FC 00        	.WORD	$00fc	; Freq accum
  569 2477:B5 F0        	.WORD	$f0b5	; Shifter accum
  570 2479:00 00        	.WORD	$0000	; Feedback accum
  571 247B:00 4E        	.WORD	$4e00	; Volume accum
  572 247D:9A FD        	.WORD	$fd9a	; Volume interp
  573                   	;------ Next Frame
  574 247F:19 00        	.WORD	25	; Frame number
  575 2481:38 0F        	.WORD	$0f38	; Flags
  576 2483:FC 00        	.WORD	$00fc	; Freq accum
  577 2485:B5 F0        	.WORD	$f0b5	; Shifter accum
  578 2487:10 00        	.WORD	$0010	; Feedback accum
  579 2489:00 12        	.WORD	$1200	; Volume accum
  580 248B:07 00        	.WORD	$0007	; Feedback interp
  581 248D:D7 00        	.WORD	$00d7	; Volume interp
  582                   	;------ Next Frame
  583 248F:32 00        	.WORD	50	; Frame number
  584 2491:38 0F        	.WORD	$0f38	; Flags
  585 2493:F8 00        	.WORD	$00f8	; Freq accum
  586 2495:B9 F0        	.WORD	$f0b9	; Shifter accum
  587 2497:C0 00        	.WORD	$00c0	; Feedback accum
  588 2499:00 27        	.WORD	$2700	; Volume accum
  589 249B:FE FF        	.WORD	$fffe	; Feedback interp
  590 249D:B3 00        	.WORD	$00b3	; Volume interp
  591                   	;------ Next Frame
  592 249F:50 00        	.WORD	80	; Frame number
  593 24A1:38 0F        	.WORD	$0f38	; Flags
  594 24A3:FC 00        	.WORD	$00fc	; Freq accum
  595 24A5:B5 F0        	.WORD	$f0b5	; Shifter accum
  596 24A7:80 00        	.WORD	$0080	; Feedback accum
  597 24A9:00 3C        	.WORD	$3c00	; Volume accum
  598 24AB:00 00        	.WORD	$0000	; Feedback interp
  599 24AD:D9 01        	.WORD	$01d9	; Volume interp
  600                   	;------ Next Frame
  601 24AF:64 00        	.WORD	100	; Frame number
  602 24B1:B8 0F        	.WORD	$0fb8	; Flags
  603 24B3:FC 00        	.WORD	$00fc	; Freq accum
  604 24B5:B5 F0        	.WORD	$f0b5	; Shifter accum
  605 24B7:80 00        	.WORD	$0080	; Feedback accum
  606 24B9:00 61        	.WORD	$6100	; Volume accum
  607 24BB:90 07        	.WORD	$0790	; Freq interp
  608 24BD:64 32        	.WORD	$3264	; Feedback interp
  609 24BF:80 F0        	.WORD	$f080	; Volume interp
  610                   	;------ Next Frame
  611 24C1:68 00        	.WORD	104	; Frame number
  612 24C3:01 00        	.WORD	$0001	; Flags
  613                   
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   88
                                                        18:23:55  

  614 24C5:             my.bang.fxdata
  615                   ; HSFX Table for SFX_1 sound effect
  616                   	;------ Next Frame
  617 24C5:00 00        	.WORD	0	; Frame number
  618 24C7:90 0F        	.WORD	$0f90	; Flags
  619 24C9:FC 7F        	.WORD	$7ffc	; Freq accum
  620 24CB:F3 FF        	.WORD	$fff3	; Shifter accum
  621 24CD:F0 CB        	.WORD	$cbf0	; Feedback accum
  622 24CF:00 00        	.WORD	$0000	; Volume accum
  623 24D1:84 F3        	.WORD	$f384	; Freq interp
  624 24D3:1C 0E        	.WORD	$0e1c	; Volume interp
  625                   	;------ Next Frame
  626 24D5:09 00        	.WORD	9	; Frame number
  627 24D7:90 0B        	.WORD	$0b90	; Flags
  628 24D9:9C 0F        	.WORD	$0f9c	; Freq accum
  629 24DB:10 C2        	.WORD	$c210	; Feedback accum
  630 24DD:00 7F        	.WORD	$7f00	; Volume accum
  631 24DF:08 00        	.WORD	$0008	; Freq interp
  632 24E1:BE FF        	.WORD	$ffbe	; Volume interp
  633                   	;------ Next Frame
  634 24E3:F4 01        	.WORD	500	; Frame number
  635 24E5:01 00        	.WORD	$0001	; Flags
  636                   
  637                   
  638                   
  639                   
  640                   
  641 24E7:             blob.Data
  642                   ; Handy Sprite Image Data
  643                   ; Bits per Pixel = 3
  644                   ; Next data is down-right
  645 24E7:04 10 09 00  	.BYTE	$04,$10,$09,$00
  645                   
  646 24EB:07 18 C9 20  	.BYTE	$07,$18,$c9,$20,$02,$01,$20
  646      02 01 20     
  647 24F2:06 18 11 80  	.BYTE	$06,$18,$11,$80,$21,$00
  647      21 00        
  648 24F8:07 10 B1 48  	.BYTE	$07,$10,$b1,$48,$82,$84,$40
  648      82 84 40     
  649 24FF:08 F8 24 94  	.BYTE	$08,$f8,$24,$94,$53,$48,$80,$08
  649      53 48 80 08  
  649                   
  650 2507:08 18 E1 49  	.BYTE	$08,$18,$e1,$49,$34,$91,$00,$90
  650      34 91 00 90  
  650                   
  651 250F:08 E8 04 B4  	.BYTE	$08,$e8,$04,$b4,$a4,$69,$20,$22
  651      A4 69 20 22  
  651                   
  652 2517:09 08 F1 6D  	.BYTE	$09,$08,$f1,$6d,$37,$1b,$48,$90,$40
  652      37 1B 48 90  
  652      40           
  653 2520:06 19 13 14  	.BYTE	$06,$19,$13,$14,$93,$48
  653      93 48        
  654 2526:09 F1 04 A4  	.BYTE	$09,$f1,$04,$a4,$e4,$8d,$22,$02,$40
  654      E4 8D 22 02  
  654      40           
  655 252F:07 10 A9 49  	.BYTE	$07,$10,$a9,$49,$b8,$26,$32
  655      B8 26 32     
  656 2536:08 D8 24 94  	.BYTE	$08,$d8,$24,$94,$db,$65,$88,$80
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   89
                                                        18:23:55  

  656      DB 65 88 80  
  656                   
  657 253E:08 10 E1 4D  	.BYTE	$08,$10,$e1,$4d,$a4,$89,$20,$90
  657      A4 89 20 90  
  657                   
  658 2546:07 10 C1 08  	.BYTE	$07,$10,$c1,$08,$92,$91,$00
  658      92 91 00     
  659 254D:06 B8 04 80  	.BYTE	$06,$b8,$04,$80,$41,$48
  659      41 48        
  660 2553:05 90 04 60  	.BYTE	$05,$90,$04,$60,$44
  660      44           
  661 2558:00           	.BYTE	$00
  662                   ; 114 total image bytes
  663 2559:             blob
  664                   ; Handy Sprite
  665 2559:85           	.BYTE	THREE_PER_PIXEL+NONCOLL_SPRITE ; Control 0
  666 255A:30           	.BYTE	RELOAD_HVST ; Control 1
  667 255B:00           	.BYTE	$00 ; Control 2
  668 255C:00 00        	.WORD	$0000	; Next Sprite
  669 255E:E7 24        	.WORD	blob.Data	; ImageData
  670 2560:50 00        	.WORD	80	; HPos
  671 2562:33 00        	.WORD	51	; VPos
  672 2564:00 01        	.WORD	$0100	; HSize
  673 2566:00 01        	.WORD	$0100	; VSize
  674 2568:00 00        	.WORD	$0000	; Stretch
  675 256A:00 00        	.WORD	$0000	; Tilt
  676                   	; Palette
  677 256C:09 AB C0 00  	.BYTE	$09,$ab,$c0,$00
  677                   
  678 2570:             face.Data
  679                   ; Handy Sprite Image Data
  680                   ; Bits per Pixel = 3
  681                   ; Next data is down-right
  682 2570:04 50 31 00  	.BYTE	$04,$50,$31,$00
  682                   
  683 2574:04 38 71 00  	.BYTE	$04,$38,$71,$00
  683                   
  684 2578:06 30 31 82  	.BYTE	$06,$30,$31,$82,$49,$00
  684      49 00        
  685 257E:05 20 79 21  	.BYTE	$05,$20,$79,$21,$00
  685      00           
  686 2583:06 18 21 92  	.BYTE	$06,$18,$21,$92,$45,$e4
  686      45 E4        
  687 2589:05 10 79 49  	.BYTE	$05,$10,$79,$49,$00
  687      00           
  688 258E:05 10 79 51  	.BYTE	$05,$10,$79,$51,$00
  688      00           
  689 2593:07 08 79 A1  	.BYTE	$07,$08,$79,$a1,$32,$23,$10
  689      32 23 10     
  690 259A:07 08 79 A9  	.BYTE	$07,$08,$79,$a9,$56,$d4,$52
  690      56 D4 52     
  691 25A1:07 80 71 92  	.BYTE	$07,$80,$71,$92,$50,$94,$c4
  691      50 94 C4     
  692 25A8:0A A0 25 44  	.BYTE	$0a,$a0,$25,$44,$99,$25,$0b,$60,$8a,$40
  692      99 25 0B 60  
  692      8A 40        
  693 25B2:0A A8 26 54  	.BYTE	$0a,$a8,$26,$54,$32,$24,$38,$6b,$08,$52
  693      32 24 38 6B  
  693      08 52        
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   90
                                                        18:23:55  

  694 25BC:0A B0 2A DB  	.BYTE	$0a,$b0,$2a,$db,$04,$89,$11,$61,$0a,$40
  694      04 89 11 61  
  694      0A 40        
  695 25C6:07 91 29 F4  	.BYTE	$07,$91,$29,$f4,$96,$10,$a4
  695      96 10 A4     
  696 25CD:07 11 7D 25  	.BYTE	$07,$11,$7d,$25,$82,$29,$00
  696      82 29 00     
  697 25D4:07 11 7D 1D  	.BYTE	$07,$11,$7d,$1d,$8c,$45,$20
  697      8C 45 20     
  698 25DB:0C 11 1D 0C  	.BYTE	$0c,$11,$1d,$0c,$0a,$1c,$12,$14,$9d,$b1,$14,$80
  698      0A 1C 12 14  
  698      9D B1 14 80  
  698                   
  699 25E7:0B 11 8C A4  	.BYTE	$0b,$11,$8c,$a4,$54,$25,$44,$32,$34,$18,$52
  699      54 25 44 32  
  699      34 18 52     
  700 25F2:0C 11 DA 51  	.BYTE	$0c,$11,$da,$51,$12,$4a,$91,$10,$8d,$06,$10,$80
  700      12 4A 91 10  
  700      8D 06 10 80  
  700                   
  701 25FE:0C A9 45 58  	.BYTE	$0c,$a9,$45,$58,$45,$92,$91,$49,$14,$46,$8a,$40
  701      45 92 91 49  
  701      14 46 8A 40  
  701                   
  702 260A:0E C8 51 5B  	.BYTE	$0e,$c8,$51,$5b,$64,$5f,$86,$d3,$22,$92,$d9,$12
  702      64 5F 86 D3  
  702      22 92 D9 12  
  702      21 00        
  703 2618:0C 80 14 2D  	.BYTE	$0c,$80,$14,$2d,$ac,$96,$d8,$6b,$35,$62,$11,$00
  703      AC 96 D8 6B  
  703      35 62 11 00  
  703                   
  704 2624:0D A0 52 A2  	.BYTE	$0d,$a0,$52,$a2,$58,$41,$df,$29,$6d,$b1,$4b,$22
  704      58 41 DF 29  
  704      6D B1 4B 22  
  704      24           
  705 2631:0B A0 12 D2  	.BYTE	$0b,$a0,$12,$d2,$a2,$52,$ab,$c9,$64,$29,$00
  705      A2 52 AB C9  
  705      64 29 00     
  706 263C:0B C8 12 D9  	.BYTE	$0b,$c8,$12,$d9,$2c,$46,$83,$30,$64,$82,$40
  706      2C 46 83 30  
  706      64 82 40     
  707 2647:0D 90 08 77  	.BYTE	$0d,$90,$08,$77,$c8,$d8,$4a,$45,$22,$89,$1c,$93
  707      C8 D8 4A 45  
  707      22 89 1C 93  
  707      48           
  708 2654:0B 10 B4 B6  	.BYTE	$0b,$10,$b4,$b6,$17,$4e,$72,$91,$32,$48,$d0
  708      17 4E 72 91  
  708      32 48 D0     
  709 265F:09 10 A4 B6  	.BYTE	$09,$10,$a4,$b6,$26,$1a,$b9,$23,$60
  709      26 1A B9 23  
  709      60           
  710 2668:0A 10 BC B6  	.BYTE	$0a,$10,$bc,$b6,$c7,$21,$10,$c9,$24,$18
  710      C7 21 10 C9  
  710      24 18        
  711 2672:0A 18 BC B6  	.BYTE	$0a,$18,$bc,$b6,$48,$50,$a0,$91,$60,$58
  711      48 50 A0 91  
  711      60 58        
  712 267C:09 18 24 0D  	.BYTE	$09,$18,$24,$0d,$14,$25,$1c,$0b,$00
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   91
                                                        18:23:55  

  712      14 25 1C 0B  
  712      00           
  713 2685:0A 20 1C C5  	.BYTE	$0a,$20,$1c,$c5,$b1,$25,$25,$24,$83,$00
  713      B1 25 25 24  
  713      83 00        
  714 268F:09 20 1C 0D  	.BYTE	$09,$20,$1c,$0d,$1c,$bd,$96,$48,$d8
  714      1C BD 96 48  
  714      D8           
  715 2698:07 28 14 45  	.BYTE	$07,$28,$14,$45,$0c,$0b,$00
  715      0C 0B 00     
  716 269F:07 38 0C 35  	.BYTE	$07,$38,$0c,$35,$14,$83,$00
  716      14 83 00     
  717 26A6:04 40 3C 00  	.BYTE	$04,$40,$3c,$00
  717                   
  718 26AA:00           	.BYTE	$00
  719                   ; 315 total image bytes
  720 26AB:             face
  721                   ; Handy Sprite
  722 26AB:85           	.BYTE	THREE_PER_PIXEL+NONCOLL_SPRITE ; Control 0
  723 26AC:30           	.BYTE	RELOAD_HVST ; Control 1
  724 26AD:00           	.BYTE	$00 ; Control 2
  725 26AE:00 00        	.WORD	$0000	; Next Sprite
  726 26B0:70 25        	.WORD	face.Data	; ImageData
  727 26B2:40 00        	.WORD	64	; HPos
  728 26B4:1F 00        	.WORD	31	; VPos
  729 26B6:00 01        	.WORD	$0100	; HSize
  730 26B8:00 01        	.WORD	$0100	; VSize
  731 26BA:00 00        	.WORD	$0000	; Stretch
  732 26BC:00 00        	.WORD	$0000	; Tilt
  733                   	; Palette
  734 26BE:08 9A BC 00  	.BYTE	$08,$9a,$bc,$00
  734                   
  735                   
  736                   
  737                   
  738                   ;-----------------------------------------------------
  739                   ; include system variables
  740                   	.in sys.var
    1 26C2:             most.variables
    2                   ; some system variables
    3                   	.in 6502:src/hmusic.var
    1                   ; Tuesday 24-Apr-90 13:46:38
    2                   * === hmusic.src =====================================
    3                   *
    4                   * Handy Music Driver  --  Handy Software
    5                   *
    6                   * Confidential and Proprietary
    7                   * Copyright (C) 1989, Epyx, Inc.
    8                   * 
    9                   * Date		Name		Description
   10                   * ---------	--------------	---------------------------
   11                   * 24-Apr-90	SHL		ring0_flag and ring1_flag arrays repl
   12                   *				ring_flag array
   13                   * 18-Apr-90	SHL		HMUSIC_DEFAULT_PRIORITY added to give
   14                   *				a default priority level
   15                   *				Added HMusicVarStart and HMusicVarEnd markers
   16                   * 31-Aug-89	Stephen Jungels	Split this file from hsfx.
   17                   *
   18                   * ====================================================
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   92
                        6502:src/hmusic.var             18:23:55  

   19                   
   20                   
   21                   ; Variables used by the HMUSIC driver
   22                   
   23                   ; If you are using HMUSIC you must include this file
   24                   
   25 26C2:             HMusicVarStart
   26                   
   27                   
   28 26C2:             VoiceInUse	.DS HMUSIC_CHANNELCOUNT	; Flags whether thi
   29                   
   30 26C6:             instance	.DS 1			; Holds next 'instance' value
   31 26C7:             VoiceInstance	.DS HMUSIC_CHANNELCOUNT	; Instances for 
   32                   
   33 26CB:             restore_ds	.DS HMUSIC_CHANNELCOUNT ; Flag for modified
   34 26CF:             save_decayl	.DS HMUSIC_CHANNELCOUNT ; Save location fo
   35 26D3:             save_decayh	.DS HMUSIC_CHANNELCOUNT
   36 26D7:             save_sustainl	.DS HMUSIC_CHANNELCOUNT ; Save location 
   37 26DB:             save_sustainh	.DS HMUSIC_CHANNELCOUNT
   38                   
   39 26DF:             voice_freq_ptrl	.DS HMUSIC_CHANNELCOUNT ; Address of p
   40 26E3:             voice_freq_ptrh	.DS HMUSIC_CHANNELCOUNT
   41 26E7:             voice_dur_ptrl	.DS HMUSIC_CHANNELCOUNT ; Address of du
   42 26EB:             voice_dur_ptrh	.DS HMUSIC_CHANNELCOUNT
   43                   
   44 26EF:             gatel		.DS HMUSIC_CHANNELCOUNT	; Gate timing
   45 26F3:             gateh		.DS HMUSIC_CHANNELCOUNT
   46                   
   47 26F7:             voicedata_ptrl	.DS HMUSIC_CHANNELCOUNT ; Current addre
   48 26FB:             voicedata_ptrh	.DS HMUSIC_CHANNELCOUNT
   49                   
   50 26FF:             frames_alivel	.DS HMUSIC_CHANNELCOUNT ; Number of audi
   51 2703:             frames_aliveh	.DS HMUSIC_CHANNELCOUNT ; has been alive
   52 2707:             voice_endframel	.DS HMUSIC_CHANNELCOUNT ; When current
   53 270B:             voice_endframeh	.DS HMUSIC_CHANNELCOUNT
   54                   
   55 270F:             hmflagsl	.DS 1		; Last CFW read
   56 2710:             hmflagsh	.DS 1
   57                   
   58 2711:             gating		.DS HMUSIC_CHANNELCOUNT ; Last AGD/AGS flag re
   59                   
   60 2715:             new_note	.DS HMUSIC_CHANNELCOUNT ; Flag - send new not
   61                   
   62 2719:             SFX_to_cancel	.DS HMUSIC_CHANNELCOUNT ; Priority of SF
   63                   
   64 271D:             did_outernext	.DS 1
   65 271E:             did_innernext	.DS 1
   66 271F:             did_ring_end	.DS 1	; One-shot prevention of recursive 
   67                   
   68 2720:             mloop_count0	.DS HMUSIC_CHANNELCOUNT
   69 2724:             mloop_adrl0	.DS HMUSIC_CHANNELCOUNT
   70 2728:             mloop_adrh0	.DS HMUSIC_CHANNELCOUNT
   71 272C:             mloop_count1	.DS HMUSIC_CHANNELCOUNT
   72 2730:             mloop_adrl1	.DS HMUSIC_CHANNELCOUNT
   73 2734:             mloop_adrh1	.DS HMUSIC_CHANNELCOUNT
   74                   
   75 2738:             ring_flag	.DS HMUSIC_CHANNELCOUNT
   76 273C:             ring0_returnl	.DS HMUSIC_CHANNELCOUNT ; RING0 info
   77 2740:             ring0_returnh	.DS HMUSIC_CHANNELCOUNT
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   93
                        6502:src/hmusic.var             18:23:55  

   78 2744:             ring1_returnl	.DS HMUSIC_CHANNELCOUNT ; RING1 info
   79 2748:             ring1_returnh	.DS HMUSIC_CHANNELCOUNT
   80                   
   81 274C:             hmusic_base	.DS 2		; Address of music data
   82                   
   83 274E:             VoiceHSFXChannel .DS HMUSIC_CHANNELCOUNT ; Hardware ch
   84                   
   85                   
   86      TRUE         	#IFDEF MUTE_USER
   87 2752:             Mute_flag	.DS 1
   88                   	#ENDIF
   89                   
   90      FALSE        	#IFDEF	USERCALLS_USER
   93                   	#ENDIF ; of #IFDEF USERCALLS_USER
   94                   
   95                   
   96 2753:             HMusicVarEnd
   97                   
    4                   	.in 6502:src/hsfx.var
    1                   ; Thursday 19-Apr-90 16:17:32
    2                   * === hsfx.var =======================================
    3                   *
    4                   * Handy Sound Effects Driver  --  Handy Software
    5                   *
    6                   * Confidential and Proprietary
    7                   * Copyright (C) 1989, Epyx, Inc.
    8                   *
    9                   * Date		Name		Description
   10                   * ---------	--------------	---------------------------
   11                   * 19-Apr-90	SHL		Moved top_of_loop0,1 variables from h
   12                   *				Moved hsfx_temp to zero page in hsfx.src
   13                   * 18-Apr-90	SHL		Added HSFXVarStart and HSFXVarEnd mar
   14                   * 31-Aug-89	Stephen Jungels	Split this file from hsfx.
   15                   *
   16                   * ====================================================
   17                   
   18                   
   19                   ; Variables used by the HSFX driver
   20                   
   21                   ; If you are using HSFX you must include this file
   22                   
   23                   
   24 2753:             HSFXVarStart
   25                   
   26                   
   27 2753:             audio_interruptus .ds 1	; Set on entry to audio interr
   28 2754:             audio_lockout	.ds 1	; flag to lock out audio interrupt
   29 2755:             audio_dropout	.ds 1	; count of audio frames that have 
   30                   
   31 2756:             top_of_loop0	.ds 1	; recursion flag
   32 2757:             top_of_loop1	.ds 1	; recursion flag
   33                   
   34                   
   35                   * ChannelInUse is used to denote both that the HSFX ch
   36                   * and the priority of the effect currently playing on 
   37                   * A ChannelInUse value of 0 (HSFX_FREECHANNEL) denotes
   38                   * A value of $FF (HSFX_NOCHANNEL) denotes channel not 
   39                   * Any other value is a channel-priority value, where s
   40                   * odd priorities and music notes get even priorities.
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   94
                        6502:src/hsfx.var               18:23:55  

   41                   * Note that ChannelInUse has 5 elements, allowing for 
   42                   * "mock channel" which is guaranteed to always have a 
   43                   * Channel 4 is returned by StartHSFX when the effect c
   44                   
   45 2758:             ChannelInUse	.ds HSFX_CHANNELCOUNT+1
   46                   
   47                   
   48                   * NOTE:  The above software depends on the exact order
   49                   * accumulators and interpolators.
   50                   * Also, the software presumes that:  there are HSFX_AC
   51                   * accumulators; there are a total of HSFX_REGCOUNT arr
   52                   * and each pair is (HSFX_CHANNELCOUNT * HSFX_REGSIZE) 
   53                   
   54 275D:             freql		.ds HSFX_CHANNELCOUNT
   55 2761:             freqh		.ds HSFX_CHANNELCOUNT
   56 2765:             shiftl		.ds HSFX_CHANNELCOUNT
   57 2769:             shifth		.ds HSFX_CHANNELCOUNT
   58 276D:             feedbackl	.ds HSFX_CHANNELCOUNT
   59 2771:             feedbackh	.ds HSFX_CHANNELCOUNT
   60 2775:             volumel		.ds HSFX_CHANNELCOUNT
   61 2779:             volumeh		.ds HSFX_CHANNELCOUNT
   62 277D:             freq_interpl	.ds HSFX_CHANNELCOUNT
   63 2781:             freq_interph	.ds HSFX_CHANNELCOUNT
   64 2785:             shift_interpl	.ds HSFX_CHANNELCOUNT
   65 2789:             shift_interph	.ds HSFX_CHANNELCOUNT
   66 278D:             feed_interpl	.ds HSFX_CHANNELCOUNT
   67 2791:             feed_interph	.ds HSFX_CHANNELCOUNT
   68 2795:             vol_interpl	.ds HSFX_CHANNELCOUNT
   69 2799:             vol_interph	.ds HSFX_CHANNELCOUNT
   70                   
   71 279D:             flagsl		.ds HSFX_CHANNELCOUNT	;16 bit flags
   72 27A1:             flagsh		.ds HSFX_CHANNELCOUNT
   73                   
   74 27A5:             next_keyframel	.ds HSFX_CHANNELCOUNT	;next 'change of 
   75 27A9:             next_keyframeh	.ds HSFX_CHANNELCOUNT
   76                   
   77 27AD:             current_framel	.ds HSFX_CHANNELCOUNT	;current frame be
   78 27B1:             current_frameh	.ds HSFX_CHANNELCOUNT
   79                   
   80 27B5:             loop_count0	.ds HSFX_CHANNELCOUNT	;# loops to perform
   81 27B9:             loop_adrl0	.ds HSFX_CHANNELCOUNT	;'top of loop' addres
   82 27BD:             loop_adrh0	.ds HSFX_CHANNELCOUNT
   83                   
   84 27C1:             loop_count1	.ds HSFX_CHANNELCOUNT	;# loops to perform
   85 27C5:             loop_adrl1	.ds HSFX_CHANNELCOUNT	;'top of loop' addres
   86 27C9:             loop_adrh1	.ds HSFX_CHANNELCOUNT
   87                   
   88 27CD:             shift_flag	.ds HSFX_CHANNELCOUNT
   89                   
   90 27D1:             clock_temp	.ds HSFX_CHANNELCOUNT	;something wrong here
   91 27D5:             preload_temp	.ds HSFX_CHANNELCOUNT
   92 27D9:             data_temp	.ds HSFX_CHANNELCOUNT
   93 27DD:             shift_temp	.ds HSFX_CHANNELCOUNT
   94 27E1:             integrate	.ds HSFX_CHANNELCOUNT
   95                   
   96 27E5:             hsfx_basel	.ds HSFX_CHANNELCOUNT	;pointers to data tab
   97 27E9:             hsfx_baseh	.ds HSFX_CHANNELCOUNT
   98                   
   99 27ED:             launch_channel	.ds HSFX_CHANNELCOUNT	;for out of phase
Epyx HandyAsm 1.12      multi.src                       16-Apr-12518:23:55 Page   95
                        6502:src/hsfx.var               18:23:55  

  100                   
  101                   
  102 27F1:             HSFXVarEnd
  103                   
    5                   ; buffers
    6                   ; interrupt vector table
    7 27F1:             MyIntTable		.ds 16
    8                   
    9                   ; color palette buffers
   10 2801:             new.colors.rgb
   11 2801:             new.colors.g		.ds 16
   12 2811:             new.colors.br		.ds 16
   13                   
   14 2821:             old.colors.rgb
   15 2821:             old.colors.g		.ds 16
   16 2831:             old.colors.br		.ds 16
   17      TRUE         	#ifdef MULTIPLAYER
   18 2841:             messages	.ds MAX_PLAYERS
   19                   	#endif
   20                   
   21                   ; screen buffers
   22      E018         Buffer1	.eq {$ffff-{DISPLAY_BUFSIZE+4}}&$fffc
   23      C034         Buffer2	.eq {Buffer1-{DISPLAY_BUFSIZE+4}}&$fffc
   24                   
  741                   
  742                   
  743                   
  744                   ;-----------------------------------------------------
  745                   ; game variables/buffers (use the .ds command only)
  746 2845:             my.buffer	.ds 1000
  747                   
  748                   
  749                   ;-----------------------------------------------------
  750                   
  751                   
  752      9407         len.free	.eq Buffer2-* ;number of bytes unused RAM for
  753                   
  754 2C2D:             	.or $200
  755                   
  756                   
  757                   ;-----------------------------------------------------
  758                   ; more game variables/buffers (use the .ds command onl
  759                   ; there is room for 512 bytes here
  760 0200:             faceh	.ds 4
  761 0204:             facev	.ds 4
  762                   
  763                   ;-----------------------------------------------------
  764                   
  765                   	.list on	; enable list for symbol table in list
  766                   	.en
Epyx HandyAsm 1.12      Symbols                         16-Apr-12518:23:55 Page   96
                                                        18:23:55  

$0040 ACCUMULATE                        MACRO ADDMUSIC
$0100 AGD                               $0040 ALGO_3
$0F00 ALL_ACCUM                         $0200 ASD
$0000 ASM.EQUSYMS                       $010C ASM.VERSION
$FD40 ATTENREG0                         $FD41 ATTENREG1
$FD42 ATTENREG2                         $FD43 ATTENREG3
$FD86 AUDIN                             $0010 AUDIN_BIT
$FD20 AUDIO0                            $FD28 AUDIO1
$FD30 AUDIO2                            $FD38 AUDIO3
$0006 AUDIO_CLOCK_MASK                  $0001 AUDIO_DISABLE
$0040 AUDIO_PRELOAD                     $0006 AUDIO_TIMER
$0000 AUD_1                             $0004 AUD_16
$0001 AUD_2                             $0005 AUD_32
$0002 AUD_4                             $0006 AUD_64
$0003 AUD_8                             $0004 AUD_BACKUP
$0007 AUD_CLOCK_MASK                    $0005 AUD_CONTROL
$0006 AUD_COUNTER                       $0001 AUD_FEEDBACK
$0007 AUD_LINKING                       $0007 AUD_OTHER
$0002 AUD_OUTPUT                        $0003 AUD_SHIFT
$0000 AUD_VOLCNTRL                      $0001 A_BUTTON
$0000 A_OFFSET                          $0F58 AddMusic
$0000 BACKGROUND_SPRITE                 $0001 BACKNONCOLL_SPRITE
$0000 BACK_SHADOW_SPRITE                MACRO BEGIN_ALLOCATE_ZEROPAGE
MACRO BEGIN_ZPAGE                       $00C0 BITS_MASK
$FDB0 BLUERED0                          $FDB1 BLUERED1
$FDB2 BLUERED2                          $FDB3 BLUERED3
$FDB4 BLUERED4                          $FDB5 BLUERED5
$FDB6 BLUERED6                          $FDB7 BLUERED7
$FDB8 BLUERED8                          $FDB9 BLUERED9
$FDBA BLUEREDA                          $FDBB BLUEREDB
$FDBC BLUEREDC                          $FDBD BLUEREDD
$FDBE BLUEREDE                          $FDBF BLUEREDF
$0002 BORROW_IN                         $0001 BORROW_OUT
$0003 BOUNDARY_SPRITE                   $0015 BREAK_CONTROLS
$0002 BSHADOW_SPRITE                    $0013 BUS_MONITOR
$0001 BUTTON_A                          $0002 BUTTON_B
$0002 B_BUTTON                          $E018 Buffer1
$C034 Buffer2                           $0002 CART0_IO_INACTIVE
$0004 CART1_IO_INACTIVE                 $0002 CART_ADDR_DATA
$0001 CART_ADDR_STROBE                  $0002 CART_POWER_OFF
$0001 CHEAP_PAUSED                      MACRO CLEARACCUM
MACRO CLEARUSER                         $FC0F COLLADRH
$FC0E COLLADRL                          $FC0B COLLBASH
$FC0A COLLBASL                          $FC25 COLLOFFH
$FC24 COLLOFFL                          $0080 COMMAND
$0003 CONTINUE_REQUEST                  $FD91 CPUSLEEP
$FFFE CPU_IRQ                           $FFFA CPU_NMI
$FFFC CPU_RESET                         $15A1 CartDirectory
$159F CartIOCount                       $159D CartOffsetHigh
$159C CartOffsetLow                     $159E CartPage
$2758 ChannelInUse                      $0002 DATA
MACRO DBUF_DISPLAY                      $0003 DEBOUNCE
$FD95 DISPADRH                          $FD94 DISPADRL
$FD92 DISPCTL                           $0C3F DISPCTL_RAM
MACRO DISPLAY                           $157E DISPLAY.003C
$1584 DISPLAY.003C2                     $1FE0 DISPLAY_BUFSIZE
$0080 DISPLAY_EOFFLAG                   $0040 DISPLAY_EOLFLAG
MACRO DISP_AX                           MACRO DISP_AY
Epyx HandyAsm 1.12      Symbols                         16-Apr-12518:23:55 Page   97
                                                        18:23:55  

$0008 DISP_COLOR                        $0002 DISP_FLIP
$0004 DISP_FOURBIT                      $0001 DMA_ENABLE
$0001 DOWNLOAD_REQUEST                  $0001 DRAW_LEFT
$0002 DRAW_UP                           $0008 DURATION
$0C44 DisplayBuffer                     $0C47 DisplayFlags
$1540 DisplayFrameCount                 MACRO ECHO_VALUE
$0008 ENABLE_COUNT                      $0080 ENABLE_INT
$0020 ENABLE_INTEGRATE                  $0010 ENABLE_RELOAD
MACRO END_ALLOCATE_ZEROPAGE             MACRO END_DISABLE
$0001 END_OF_EFFECT                     $0000 END_OF_FILE
$0001 END_OF_VOICE                      MACRO END_ZPAGE
$0001 EOF_USER                          $0002 ESCAPE
$0004 EVER_ON                           $0040 EXPAND_CFW
$0001 EXTERNAL_POWER                    $0001 FAKE_COMLYNX
$0200 FBACK_ACCUM                       $0020 FBACK_INTERP
$0080 FEEDBACK_7                        $0011 FILL_MEM
MACRO FLIP                              $0004 FLIP_BUTTON
$00C0 FOUR_PER_PIXEL                    $0001 FRAMECOUNT_UP
$0004 FRAMERR                           $0004 FRAME_RATE
$0800 FREQ_ACCUM                        $0080 FREQ_INTERP
$1558 FrameEnd                          $1599 FrameEndExit
$0CBE FreeAudio                         MACRO GETDIR
MACRO GETDIRFAST                        $0001 GETDIR_USER
MACRO GETJOY                            MACRO GETSWITCH
$0005 GO_REQUEST                        $FDA0 GREEN0
$FDA1 GREEN1                            $FDA2 GREEN2
$FDA3 GREEN3                            $FDA4 GREEN4
$FDA5 GREEN5                            $FDA6 GREEN6
$FDA7 GREEN7                            $FDA8 GREEN8
$FDA9 GREEN9                            $FDAA GREENA
$FDAB GREENB                            $FDAC GREENC
$FDAD GREEND                            $FDAE GREENE
$FDAF GREENF                            $168A GetDirAddress
$0001 HANDYIO                           $0000 HANDYMATH
$0001 HANDYMUSIC                        $FC00 HARDWARE_START
MACRO HBRK                              $FD00 HCOUNT
$0020 HFLIP                             $0007 HIDE_HOWARD_REQUEST
$0004 HMUSIC_CHANNELCOUNT               $0064 HMUSIC_DEFAULT_PRIORITY
$0004 HMUSIC_USERCOUNT                  $2753 HMusicVarEnd
$26C2 HMusicVarStart                    MACRO HOFF16
MACRO HOFF8                             $FC05 HOFFH
$FC04 HOFFL                             $0001 HORIZONTAL_INT
$0016 HOWARD_ABUS                       $0017 HOWARD_BBUS
$0018 HOWARD_CBUS                       $0019 HOWARD_DBUS
$FCC4 HOWIE                             $FC15 HPOSSTRTH
$FC14 HPOSSTRTL                         $27F1 HSFXVarEnd
$2753 HSFXVarStart                      $0004 HSFX_ACCUMCOUNT
$00FE HSFX_BIGPRIORITY                  $0004 HSFX_CHANNELCOUNT
$0000 HSFX_FREECHANNEL                  $0001 HSFX_LILPRIORITY
$00FF HSFX_NOCHANNEL                    $0008 HSFX_REGCOUNT
$0002 HSFX_REGSIZE                      $FC29 HSIZOFFH
$FC28 HSIZOFFL                          MACRO INITEOF
MACRO INITHMUSIC                        MACRO INITHSFX
MACRO INITINT                           $045D INITINT.0006
MACRO INITSUZY                          MACRO INITSYS
$0002 INNER_BUTTON                      $0008 INTEGRATE
$00B0 INTERP                            $FD80 INTRST
$FD81 INTSET                            $0C46 INTSET_RAM
$FD8B IODAT                             $0C40 IODAT_RAM
Epyx HandyAsm 1.12      Symbols                         16-Apr-12518:23:55 Page   98
                                                        18:23:55  

$FD8A IODIR                             $0C41 IODIR_RAM
$FCC3 IOData                            $FCC2 IOStatus
$1541 InitEOF                           $0F1A InitHMusic
$0C48 InitHSFX                          $1537 IntReturn
$FBF0 IntTable                          $FCB0 JOYSTICK
$0080 JOY_DOWN                          $0010 JOY_LEFT
$0020 JOY_RIGHT                         $0040 JOY_UP
$0012 LARGE_DATA                        $0004 LAST_CLOCK
$FCC0 LEDS                              $0010 LEFT0_SELECT
$0020 LEFT1_SELECT                      $0040 LEFT2_SELECT
$0080 LEFT3_SELECT                      $0008 LEFTHAND
$0008 LEFTHANDED                        $00F0 LEFT_ATTENMASK
$0080 LITERAL                           $8000 LOOP0
$2000 LOOP1                             $FFF9 MAPCTL
$FC55 MATHA                             $FC54 MATHB
$FC53 MATHC                             $0020 MATHCARRY
$FC52 MATHD                             $FC63 MATHE
$FC62 MATHF                             $FC61 MATHG
$FC60 MATHH                             $FC6F MATHJ
$FC6E MATHK                             $FC6D MATHL
$FC6C MATHM                             $FC57 MATHN
$FC56 MATHP                             $0040 MATHWARNING
$0080 MATHWORKING                       $0004 MAX_PLAYERS
$FD88 MIKEYHREV                         $FD89 MIKEYSREV
$FD00 MIKEY_BASE                        $0002 MIKEY_SPACE
$0010 MONITOR_BYTECOUNT                 $0001 MONITOR_I
$F900 MONITOR_RAM_RESERVED              $00F8 MONITOR_ZP_RESERVED
$FD44 MPAN                              $0020 MSFX
$FD50 MSTEREO                           $FD9C MTEST0
$FD9D MTEST1                            $FD9E MTEST2
$0001 MULTIPLAYER                       $0001 MUSIC_TOGGLE
MACRO MUTE                              $0001 MUTE_USER
$101F Mute                              $2752 Mute_flag
$27F1 MyIntTable                        $05D3 MyReturn
$4000 NEXT0                             $1000 NEXT1
$0048 NEXTZPG                           $0004 NOEXP
$0005 NONCOLL_SPRITE                    $0000 NOP_REQUEST
$0004 NORMAL_SPRITE                     $0020 NO_COLLIDE
$0000 ONE_PER_PIXEL                     MACRO OPENFILE
$0008 OPTION1_BUTTON                    $0004 OPTION2_BUTTON
$0001 ORIGIN                            $001F ORNERY
$0001 OUTER_BUTTON                      $0008 OVERRUN
$15A9 OpenFile0                         $0001 PARBIT
$0010 PAREN                             $0010 PARERR
$0001 PAREVEN                           $0001 PAUSE_SWITCH
$FD93 PBKUP                             $0004 PC_OFFSET
$0004 PITCH                             MACRO PLAYHSFX
MACRO PLAYMUSIC                         $0002 POWERON
$FC2F PROCADRH                          $FC2E PROCADRL
$0006 P_OFFSET                          $0F33 PlayMusic
$FCB2 RCART_0                           $FCB3 RCART_1
MACRO READCART                          MACRO READFILE
$0010 READ_ENABLE                       $0010 REGISTER
$0007 REGISTER_BYTECOUNT                $0010 RELOAD_HV
$0020 RELOAD_HVS                        $0030 RELOAD_HVST
$0030 RELOAD_MASK                       $0000 RELOAD_NONE
$0008 RESETERR                          MACRO RESETHSFX
$0040 RESET_DONE                        MACRO RESET_TIMEOUT
MACRO RESPRITE                          $0008 RESTART_BUTTON
Epyx HandyAsm 1.12      Symbols                         16-Apr-12518:23:55 Page   99
                                                        18:23:55  

$0008 RESTLESS                          MACRO RESTORE_CART
$0008 REUSE_PALETTE                     MACRO RGB16
MACRO RGB16_I                           MACRO RGB_AXY
$0001 RIGHT0_SELECT                     $0002 RIGHT1_SELECT
$0004 RIGHT2_SELECT                     $0008 RIGHT3_SELECT
$000F RIGHT_ATTENMASK                   $0800 RING
$001A ROM                               $0004 ROMDIR_DEST
$0008 ROMDIR_ENTRY_SIZE                 $019A ROMDIR_FILE0_OFFSET
$0000 ROMDIR_FILE0_PAGE                 $01A2 ROMDIR_FILE1_LOC
$01A2 ROMDIR_FILE1_OFFSET               $0000 ROMDIR_FILE1_PAGE
$0003 ROMDIR_FLAG                       $0001 ROMDIR_OFFSET
$0000 ROMDIR_PAGE                       $0006 ROMDIR_SIZE
$0001 ROMFILE_ALIGN                     $0100 ROMPAGECOUNT
$0400 ROMPAGESIZE                       $0000 ROMSIZE
$019A ROM_HEADER_SIZE                   $00F3 ROM_SCREENBLANK_VALUE
$0004 ROM_SPACE                         $0003 RUN_ADDRESS
$0002 RXBRK                             $0040 RXINTEN
$0040 RXRDY                             $15F5 ReadFile0
$0C42 RenderBuffer                      $0C52 ResetHSFX
$15E9 RestoreReturn                     $FC2D SCBADRH
$FC2C SCBADRL                           $FC11 SCBNEXTH
$FC10 SCBNEXTL                          $0000 SCB_CTRL0
$0001 SCB_CTRL1                         $0002 SCB_CTRL2
$0005 SCB_DATA                          $0007 SCB_HPOS
$000B SCB_HSIZE                         $0003 SCB_NEXT
$0013 SCB_PALETTE                       $001B SCB_SIZEOF
$000F SCB_STRETCH                       $0011 SCB_TILT
$0009 SCB_VPOS                          $000D SCB_VSIZE
$0005 SCORE_SIZE                        $0001 SCREEN_CLEAR
$FC23 SCVPOSH                           $FC22 SCVPOSL
$FD90 SDONEACK                          $0006 SEE_HOWARD_REQUEST
$FD8C SERCTL                            $FD8D SERDAT
$FD10 SERIALRATE                        $0010 SERIAL_INT
MACRO SETCARTADDR                       MACRO SETCARTPAGE
MACRO SETCOLL                           MACRO SETDBUF
MACRO SETDISP                           MACRO SETDISP_50
MACRO SETDISP_60                        MACRO SETDISP_75
MACRO SETUSER                           MACRO SET_AUDIO_CLOCK
MACRO SET_BRK                           MACRO SET_TO_READ_CART
$2719 SFX_to_cancel                     $0007 SHADOW_SPRITE
$0400 SHIFT_ACCUM                       $0004 SHIFT_ALWAYS
$0040 SHIFT_INTERP                      $0080 SIGNMATH
$0004 SKIP_SPRITE                       $0004 SLAVE_REQUEST
$0070 SONG_DURATIONBITS                 $0008 SONG_MAINVOICES
$000F SONG_PITCHBITS                    $0000 SONG_STARTUPVOICE0
$0002 SONG_STARTUPVOICE1                $0004 SONG_STARTUPVOICE2
$0006 SONG_STARTUPVOICE3                $0009 SONG_VOICEFX_OFFSETS
$FC82 SPRCOLL                           $FC80 SPRCTL0
$FC81 SPRCTL1                           $FC13 SPRDLINEH
$FC12 SPRDLINEL                         $FC21 SPRDOFFH
$FC20 SPRDOFFL                          $FC91 SPRGO
$FC19 SPRHSIZH                          $FC18 SPRHSIZL
$FC83 SPRINIT                           MACRO SPRITES
$0002 SPRITESTOP                        $0002 SPRITETOSTOP
$0001 SPRITEWORKING                     $0001 SPRITE_GO
$FC92 SPRSYS                            $0C3E SPRSYS_RAM
$FC1B SPRVSIZH                          $FC1A SPRVSIZL
MACRO STARTVOICE                        MACRO START_DISABLE
MACRO STOPMUSIC                         $0001 STOPMUSIC_USER
Epyx HandyAsm 1.12      Symbols                         16-Apr-12518:23:55 Page  100
                                                        18:23:55  

MACRO STOPVOICE                         $FC1D STRETCHH
$FC1C STRETCHL                          $FC90 SUZYBUSEN
$FC88 SUZYHREV                          $FC89 SUZYSREV
$FC00 SUZY_BASE                         $0001 SUZY_SPACE
$FCB1 SWITCHES                          $FD87 SYSCTL1
$0003 S_OFFSET                          $15CA SetCartAddress
$15D6 SetCartOffset                     $1663 SetCartPage
$0C66 StartHSFX                         $0CA3 StopHSFX
$0FF4 StopMusic                         $16AA TEMPORG
$0001 TESTCART2_FILE                    $0000 TESTCART_FILE
$0002 TEST_1_FILE                       $0003 TEST_2_FILE
$0004 TEST_3_FILE                       $0005 TEST_4_FILE
$0080 THREE_PER_PIXEL                   $FC03 TILTACUMH
$FC02 TILTACUML                         $FC1F TILTH
$FC1E TILTL                             MACRO TIMEOUT
$FD00 TIMER0                            $0001 TIMER0_INT
$FD04 TIMER1                            $0002 TIMER1_INT
$FD08 TIMER2                            $0004 TIMER2_INT
$FD0C TIMER3                            $0008 TIMER3_INT
$FD10 TIMER4                            $FD14 TIMER5
$0020 TIMER5_INT                        $FD18 TIMER6
$0040 TIMER6_INT                        $FD1C TIMER7
$0080 TIMER7_INT                        $0008 TIMER_DONE
$0000 TIM_BACKUP                        $0001 TIM_CONTROLA
$0003 TIM_CONTROLB                      $0002 TIM_COUNT
$FC01 TMPADRH                           $FC00 TMPADRL
$0014 TRACE                             $0080 TURBO_DISABLE
$0040 TWO_PER_PIXEL                     $0002 TXBRK
$0020 TXEMPTY                           $0080 TXINTEN
$0004 TXOPEN                            $0080 TXRDY
$0004 UNSAFEACCESS                      $0004 UNSAFEACCESSRST
$0002 UPLOAD_REQUEST                    $0002 UP_CURRENT_PAGE
$0005 UP_HAHDATA                        $0004 UP_MEMWATCH
$0003 UP_REGISTERS                      $0001 UP_THIS_PAGE
$0010 USER                              $1521 UserIntHandler
$FD08 VCOUNT                            $0008 VECTOR_SPACE
$0004 VERTICAL_INT                      $0010 VFLIP
$FC0D VIDADRH                           $FC0C VIDADRL
$FC09 VIDBASH                           $FC08 VIDBASL
MACRO VOFF16                            MACRO VOFF8
$FC07 VOFFH                             $FC06 VOFFL
$0100 VOL_ACCUM                         $0010 VOL_INTERP
$FC17 VPOSSTRTH                         $FC16 VPOSSTRTL
$FC27 VSIZACUMH                         $FC26 VSIZACUML
$FC2B VSIZOFFH                          $FC2A VSIZOFFL
$0010 VSTRETCH                          $0010 VSTRETCHING
$274E VoiceHSFXChannel                  $26C2 VoiceInUse
$26C7 VoiceInstance                     MACRO WAITEOF
MACRO WAITEOL                           MACRO WAITMATH
MACRO WAITNEOF                          MACRO WAITNEOL
MACRO WAITSUZY                          $0520 WAITSUZY.000F1
$055F WAITSUZY.00111                    $07F0 WAITSUZY.00201
$09A6 WAITSUZY.00281                    $0006 XOR_SHADOW_SPRITE
$0006 XOR_SPRITE                        $0001 X_OFFSET
$0002 Y_OFFSET                          $0C09 add.big.score
$0C07 add.score                         $0C11 add.score.1
$0F5E addMusicEntry                     $0D72 advance_channels
$21BE all.black                         $06AD another.player
$124B asd_agd_considered                $144B attackframe_v0
Epyx HandyAsm 1.12      Symbols                         16-Apr-12518:23:55 Page  101
                                                        18:23:55  

$1481 attackframe_v1                    $14B7 attackframe_v2
$14ED attackframe_v3                    $144F attackfreq_v0
$2755 audio_dropout                     $2753 audio_interruptus
$2754 audio_lockout                     $0F16 audio_offsets
$0035 audio_ptr                         $0C3E beg.sys
$0002 big.bang                          $229B big.bang.fxdata
$0C2A black                             $0C25 black.Data
$0000 black.pal                         $0893 black.screen
$2559 blob                              $24E7 blob.Data
$000A boggle                            $2389 boggle.fxdata
$0004 boing                             $22D7 boing.fxdata
$0EBD calc_next_audio                   $05F0 check.controls
$05ED check.controls.pause.loop         $05F5 check.controls.player.loop
$05F0 check.controls.players            $0758 clear.paused
$097F clear.score.nib                   $0535 clear.screen
$143E clear_voice                       $1449 clear_voice_end
$27D1 clock_temp                        $0400 cold.start
$21B8 color.pnts                        $05D8 continue.delay
$001F control.edge                      $001B control.level
$000C count                             $27B1 current_frameh
$27AD current_framel                    $27D9 data_temp
$145D decayframe_v0                     $1493 decayframe_v1
$14C9 decayframe_v2                     $14FF decayframe_v3
$05D4 delay                             $271E did_innernext
$271D did_outernext                     $271F did_ring_end
$0008 dig.wid                           $0673 do.flip
$0824 do.reset                          $0588 do.screen
$050A do.sprite                         $1159 do_CFW
$136C do_note                           $0935 done.fade
$0C20 done.score                        $0C22 done.score.1
$12B2 dur_tbl_considered                $003A duration_ptr
$0027 edge                              $2349 elevator.fxdata
$0009 elevsnd                           $1310 end_escape
$0ED0 end_freq                          $0EBA end_of_effect
$1346 end_voice                         $147B endframe_v0
$14B1 endframe_v1                       $14E7 endframe_v2
$151D endframe_v3                       $132E escape_considered
$26AB face                              $2570 face.Data
$16EA face.loop                         $0200 faceh
$0204 facev                             $08DA fade
$08EF fade.1                            $08BF fade.to.black
$0936 fader                             $0944 fader.1
$0947 fader.2                           $0012 fading
$0707 fake.com.tab                      $2791 feed_interph
$278D feed_interpl                      $2771 feedbackh
$276D feedbackl                         $0CC9 find_lesser_channel
$1186 first_RING                        $27A1 flagsh
$279D flagsl                            $2703 frames_aliveh
$26FF frames_alivel                     $0CE0 freeChannelX
$2781 freq_interph                      $277D freq_interpl
$12CC freq_tbl_considered               $2761 freqh
$275D freql                             $0038 frequency_ptr
$04F8 game.frame                        $16AA game.start
$26F3 gateh                             $26EF gatel
$2711 gating                            $068F get.controls
$110E getNextData                       $000D giggle
$2471 giggle.fxdata                     $0006 gulp
$2369 gulp.fxdata                       $1523 hardInt
$2710 hmflagsh                          $270F hmflagsl
Epyx HandyAsm 1.12      Symbols                         16-Apr-12518:23:55 Page  102
                                                        18:23:55  

$274C hmusic_base                       $103F hmusic_driver
$1056 hmusic_interrupt_core             $000F hscroll
$0001 hsfxSysCancel                     $27E9 hsfx_baseh
$27E5 hsfx_basel                        $0CF9 hsfx_driver_grunt
$0037 hsfx_temp                         $0DF1 infinite0
$0E2F infinite1                         $0747 init.comlynx
$26C6 instance                          $27E1 integrate
$153A jumpIntTable                      $0CE2 killChannelX
$27ED launch_channel                    $0D53 launch_channels
$0D56 launch_next_channel               $2313 laz.fxdata
$0007 lazsnd                            $9407 len.free
$0A6C len.sys                           $0023 level
$16CF loop                              $27BD loop_adrh0
$27C9 loop_adrh1                        $27B9 loop_adrl0
$27C5 loop_adrl1                        $27B5 loop_count0
$27C1 loop_count1                       $0DC2 loop_frame
$2841 messages                          $0001 mid.bang
$2273 mid.bang.fxdata                   $1219 mloop0_considered
$1235 mloop1_considered                 $2728 mloop_adrh0
$2734 mloop_adrh1                       $2724 mloop_adrl0
$2730 mloop_adrl1                       $2720 mloop_count0
$272C mloop_count1                      $1148 mloop_frame
$11FA mnext0_done                       $11D7 mnext1_done
$26C2 most.variables                    $1290 msfx_considered
$1218 mstuff0                           $1234 mstuff1
$0FF3 musicReturn                       $1012 muteVoiceX
$000E my.bang                           $24C5 my.bang.fxdata
$2845 my.buffer                         $001A my.player
$003E my.var1                           $0BC8 nada.data
$0011 new.colors                        $2811 new.colors.br
$2801 new.colors.g                      $2801 new.colors.rgb
$1193 new_RING                          $2715 new_note
$0E02 next0_done                        $0E41 next1_done
$27A9 next_keyframeh                    $27A5 next_keyframel
$0706 nfc                               $05D3 no.screen
$0E19 no_loop0                          $0E58 no_loop1
$0001 normal.pal                        $00FF num
$0BD7 num.tab.hi                        $0BCC num.tab.lo
$09D9 num0.data                         $0A0F num1.data
$0A3E num2.data                         $0A6E num3.data
$0A9F num4.data                         $0AD2 num5.data
$0B00 num6.data                         $0B31 num7.data
$0B62 num8.data                         $0B96 num9.data
$0019 number.of.players                 $2831 old.colors.br
$2821 old.colors.g                      $2821 old.colors.rgb
$002F opt2.timer                        $21DE pal1
$21FE pal2                              $0033 pause.flag
$0820 pause.save.1                      $0821 pause.save.2
$0822 pause.save.3                      $0823 pause.save.4
$002B pause.timer                       $0856 paused.data
$0845 paused.scb                        $11AB post_ring
$27D5 preload_temp                      $0034 quiet
$0BF2 random                            $0006 random.ndx
$1611 readCart0Grunt                    $1471 releaseframe_v0
$14A7 releaseframe_v1                   $14DD releaseframe_v2
$1513 releaseframe_v3                   $26CB restore_ds
$1359 return_from_ring0                 $1351 return_from_ring1
$2740 ring0_returnh                     $273C ring0_returnl
$2748 ring1_returnh                     $2744 ring1_returnl
Epyx HandyAsm 1.12      Symbols                         16-Apr-12518:23:55 Page  103
                                                        18:23:55  

$11AC ring_considered                   $2738 ring_flag
$135F ring_return                       $26D3 save_decayh
$26CF save_decayl                       $26DB save_sustainh
$26D7 save_sustainl                     $0014 score
$0983 score.nib.1                       $0987 score.nib.2
$09C4 score.scb                         $0050 scpos
$08C1 set.colors                        $0FC0 setNewVoice
$0FA4 setUpMusicPtrs                    $2327 shield.fxdata
$0008 shieldsnd                         $27CD shift_flag
$2789 shift_interph                     $2785 shift_interpl
$27DD shift_temp                        $2769 shifth
$2765 shiftl                            $0003 shoot
$22C3 shoot.fxdata                      $077D show.paused
$0948 show.score                        $0966 show.score.byte
$095D show.score.loop                   $0977 show.score.nib
$0013 slow.fade                         $0000 small.bang
$224B small.bang.fxdata                 $223C sound.hi
$222D sound.lo                          $221E sound.pri
$0002 star.pal                          $0BE2 start.sound
$088A start.tune                        $0FFE stopAllVoices
$1009 stopVoiceX                        $0E18 stuff0
$0E57 stuff1                            $1467 sustainframe_v0
$149D sustainframe_v1                   $14D3 sustainframe_v2
$1509 sustainframe_v3                   $27F1 sysIntTable
$0000 sysptr                            $0002 sysptr2
$0004 sysptr3                           $08A3 systemp
$11E8 takeloop0                         $11C5 takeloop1
$0008 tmp                               $0666 toggle.music
$0750 toggle.pause                      $2756 top_of_loop0
$2757 top_of_loop1                      $23B1 trans.fxdata
$000B transnd                           $173B tune.1
$0DB8 update_frame                      $1298 user_considered
$1449 voice0                            $147F voice1
$14B5 voice2                            $14EB voice3
$10D4 voiceLaunchLoop                   $1059 voiceLoop
$10CF voiceLoopEnd                      $0F9B voiceReturn
$26EB voice_dur_ptrh                    $26E7 voice_dur_ptrl
$270B voice_endframeh                   $2707 voice_endframel
$26E3 voice_freq_ptrh                   $26DF voice_freq_ptrl
$143A voice_offsets                     $26FB voicedata_ptrh
$26F7 voicedata_ptrl                    $003C voiceoffsets_ptr
$2799 vol_interph                       $2795 vol_interpl
$2779 volumeh                           $2775 volumel
$000D vscroll                           $06E5 wait.comlynx
$05A7 wait.for.more.frames              $000C whoosh
$2405 whoosh.fxdata                     $22EB zap.fxdata
$0005 zapsnd                            
