Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page    1
                                                        07:11:20  

    1                   ; Example program skeleton - single player
    2                   ; 12/8/89 M. Peter Engelbrite
    3                   	.list off
   44                   	.list on
   45                   
   46                   
   47                   ; zero page variables for sys
   48                   
   49                   	BEGIN_ZPAGE
    1      FFFE       + TEMPORG	  .= *
    2 FFFE:           + 	  .ORG NEXTZPG
    3                 + 
   50                   ; variables to clear upon entry to a new world
   51 0006:             random.ndx		.ds 2	;for random number generator
   52 0008:             tmp			.ds 4	;temporary (used by system or user)
   53 000C:             count			.ds 1	;incremented once each game frame
   54 000D:             vscroll			.ds 2	;this is the screens "window" on the w
   55 000F:             hscroll			.ds 2	;upper left corner of screen
   56                   
   57                   ;used by system
   58 0011:             new.colors		.ds 1	;used in palette control
   59 0012:             fading			.ds 1	;used in palette control
   60 0013:             slow.fade		.ds 1	;set to $ff to cause colors to fade s
   61                   
   62                   ; game score
   63 0014:             score			.ds SCORE_SIZE	;score (in BCD)
   64                   
   65                   
   66                   ; control.level
   67                   ; joystick / fire control (1 = pressed, 0 = not presse
   68                   ; bits 4-7 = $f0 means: pause button pressed
   69                   
   70                   ; control.edge
   71                   ; similar to control.level, but it indicates the leadi
   72                   ; this state exists for one game frame only!
   73                   ; 1 = just pressed, 0 = not
   74                   
   75                   
   76      FALSE        	#ifdef MULTIPLAYER
   86                   	#else
   87 0017:             control.level		.ds 1
   88 0018:             control.edge		.ds 1
   89 0019:             level			.ds 1
   90 001A:             edge			.ds 1
   91 001B:             pause.timer		.ds 1
   92 001C:             opt2.timer		.ds 1
   93                   	#endif
   94 001D:             pause.flag		.ds 1
   95                   
   96      FALSE        	#ifdef MUSIC_TOGGLE
   98                   	#endif
   99                   
  100                   	END_ZPAGE
    1      001E       + NEXTZPG	  .= *
    2      FALSE        	  #IF NEXTZPG > $0100
    4                 + 	  #ENDIF
    5 001E:           + 	  .ORG TEMPORG
    6                 + 
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page    2
                        sys.src                         07:11:20  

  101                   
  102 FFFE:             	.or $400
  103                   ; ---- COLD START ENTRY ----
  104                   ;this is entered on powerup
  105 0400:             cold.start
  106 0400:78           	sei
  107 0401:D8           	cld
  108 0402:A2 FF        	ldx #$ff
  109 0404:9A           	txs
  110                   ; clear out all work variables
  111 0405:A9 **        	lda #>most.variables
  112 0407:85 01        	sta 1
  113 0409:64 00        	stz 0
  114 040B:A0 **        	ldy #<most.variables
  115 040D:             .11
  116 040D:A9 00        	lda #0
  117 040F:             .10
  118 040F:91 00        	sta (0),y
  119 0411:C8           	iny
  120 0412:D0 FB        	bne .10
  121 0414:E6 01        	inc 1
  122 0416:A5 01        	lda 1
  123 0418:C9 FC        	cmp #$fc
  124 041A:D0 F1        	bne .11
  125                   
  126 041C:A2 00        	ldx #0
  127 041E:             .00
  128 041E:74 00        	stz 0,x
  129 0420:9E 00 01     	stz $100,x
  130 0423:9E 00 02     	stz $200,x
  131 0426:9E 00 03     	stz $300,x
  132 0429:CA           	dex
  133 042A:D0 F2        	bne .00
  134                   
  135                   	INITSYS
    1 042C:A9 0D      + 	LDA #DISP_COLOR+DISP_FOURBIT+DMA_ENABLE
    2 042E:8D ** **   + 	STA DISPCTL_RAM
    3 0431:A9 08      + 	LDA #LEFTHAND		
    4 0433:8D ** **   + 	STA SPRSYS_RAM
    5 0436:8D 92 FC   + 	STA SPRSYS
    6 0439:A9 08      + 	LDA #VECTOR_SPACE	
    7 043B:8D F9 FF   + 	STA MAPCTL
    8      FALSE         #IFDEF RAMCART_USER
   10                 +  #ELSE
   11 043E:A9 0A      + 	LDA #CART_ADDR_DATA+RESTLESS
   12                 +  #ENDIF
   13 0440:8D ** **   + 	STA IODAT_RAM
   14 0443:8D 8B FD   + 	STA IODAT
   15 0446:8D ** **   + 	STA IODIR_RAM
   16 0449:8D 8A FD   + 	STA IODIR
   17 044C:A9 04      + 	LDA #TXOPEN	
   18 044E:8D 8C FD   + 	STA SERCTL	
   19      FALSE        	  #IFDEF AUTO_TIMEOUT_USER
   22                 + 	  #ENDIF
   23                 + 
  136                   	INITINT	MyIntTable,MyReturn
    1      ****       + sysIntTable	.EQ MyIntTable
    2 0451:A9 **      + 		LDA #<UserIntHandler
    3 0453:8D FE FF   + 		STA CPU_IRQ
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page    3
                        sys.src                         07:11:20  

    4 0456:A9 **      + 		LDA #>UserIntHandler
    5 0458:8D FF FF   + 		STA CPU_IRQ+1
    6 045B:A2 0F      + 		LDX #8*2-1
    7      045D       + INITINT.0006	.= *
    8 045D:A9 **      + 		  LDA #>IntReturn
    9 045F:9D ** **   + 		  STA MyIntTable,X
   10 0462:CA         + 		  DEX
   11 0463:A9 **      + 		  LDA #<IntReturn
   12 0465:9D ** **   + 		  STA MyIntTable,X
   13 0468:CA         + 		  DEX
   14 0469:10 F2      + 		 BPL INITINT.0006
   15      FALSE        	  #IFDEF BRK_USER
   20                 + 	  #ENDIF 
   21      FALSE        	  #IFDEF SERIALPORT_USER
   26                 + 	  #ENDIF
   27                 + 
  137 046B:9C ** **     	stz DisplayFrameCount
  138                   	INITHMUSIC
    1 046E:20 ** **   + 	JSR InitHMusic
    2                 + 
  139                   	SETCOLL Buffer1,2	; no collision (set to sceen anyway
    1 0471:A9 **      + 		LDA	#<Buffer1
    2 0473:8D 0A FC   + 		STA	COLLBASL
    3 0476:A9 **      + 		LDA	#>Buffer1
    4 0478:8D 0B FC   + 		STA	COLLBASH
    5 047B:A9 02      + 		LDA	#<2
    6 047D:8D 24 FC   + 		STA	COLLOFFL
    7 0480:A9 00      + 		LDA	#>2
    8 0482:8D 25 FC   + 		STA	COLLOFFH
    9                 + 
  140                   	SETDISP_60
    1                   		SETDISP	$9E,$98,$68,$9F,$29
    1 0485:A9 9E      + 		LDA	#$9E
    2 0487:8D 00 FD   + 		STA	HCOUNT+TIM_BACKUP
    3      FALSE        	#IFDEF EOL_USER
    5                 + 	#ELSE
    6 048A:A9 18      + 		lda #$98&%01111111
    7                 + 	#ENDIF
    8 048C:8D 01 FD   + 		STA	HCOUNT+TIM_CONTROLA
    9 048F:A9 68      + 		LDA	#$68
   10 0491:8D 08 FD   + 		STA	VCOUNT+TIM_BACKUP
   11 0494:A9 9F      + 		lda #$9F|%10000000
   12 0496:8D 09 FD   + 		STA	VCOUNT+TIM_CONTROLA
   13 0499:A9 29      + 		LDA	#$29
   14 049B:8D 93 FD   + 		STA	PBKUP
   15      FALSE        	#IFNDEF	EOF_USER
   17                 + 	#ENDIF
   18                 + 
    2                 + 
  141                   	INITEOF
    1 049E:20 ** **   + 		JSR	InitEOF
    2                 + 
  142                   	INITSUZY
    1 04A1:A9 F3      + 		LDA	#$F3
    2 04A3:8D 83 FC   + 		STA	SPRINIT
    3 04A6:A9 7F      + 		LDA	#$7F
    4 04A8:8D 28 FC   + 		STA	HSIZOFFL
    5 04AB:8D 2A FC   + 		STA	VSIZOFFL
    6 04AE:A9 01      + 		LDA	#$01
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page    4
                        sys.src                         07:11:20  

    7 04B0:8D 90 FC   + 		STA	SUZYBUSEN
    8 04B3:9C 90 FD   + 		STZ	SDONEACK
    9                 + 
  143                   	SETDBUF	Buffer1,Buffer2
    1 04B6:A9 **      + 		LDA	#<Buffer1
    2 04B8:8D ** **   + 		STA	RenderBuffer
    3 04BB:A9 **      + 		LDA	#>Buffer1
    4 04BD:8D ** **   + 		STA	RenderBuffer+1
    5 04C0:A9 **      + 		LDA	#<Buffer2
    6 04C2:8D ** **   + 		STA	DisplayBuffer
    7 04C5:A9 **      + 		LDA	#>Buffer2
    8 04C7:8D ** **   + 		STA	DisplayBuffer+1
    9 04CA:9C ** **   + 		STZ	DisplayFlags
   10                 + 
  144 04CD:58           	CLI
  145                   
  146 04CE:20 ** **     	jsr clear.screen	; prevent garbage on screen while se
  147 04D1:20 ** **     	jsr black.screen
  148                   ;	DISPLAY_ON
  149                   
  150                   ; clear stretch and tilt
  151 04D4:A2 03        	ldx #3
  152 04D6:             .02
  153 04D6:9E 1C FC     	stz $fc1c,x
  154 04D9:CA           	dex
  155 04DA:10 FA        	bpl .02
  156                   
  157 04DC:20 ** **     	jsr clear.screen
  158      FALSE        	#ifdef MULTIPLAYER
  174                   	#else
  175 04DF:             .33
  176 04DF:20 ** **     	jsr delay
  177 04E2:20 ** **     	jsr get.controls
  178 04E5:A5 17        	lda control.level
  179 04E7:D0 F6        	bne .33
  180                   
  181                   	#endif
  182                   
  183                   
  184                   
  185                   
  186 04E9:4C ** **     	jmp game.start		;enter actual game
  187                   
  188                   
  189                   ; SYSTEM FUNCTIONS 
  190                   
  191                   ; ---------------------- game.frame ------------------
  192                   ; call this after all game logic is done and all sprit
  193                   ; this does the comlynx overhead, does the screen buff
  194                   ; does the pause/flip/restart/music on-off overhead, a
  195                   ; it will return with a new, blank screen (cleared to 
  196 04EC:             game.frame
  197 04EC:E6 0C        	inc count	;this is used by the system and the game (i
  198 04EE:20 ** **     	jsr show.score		;display the score
  199 04F1:20 ** **     	jsr do.screen		;display the screen
  200 04F4:20 ** **     	jsr fade		;color scene fade operation
  201 04F7:20 ** **     	jsr check.controls	;process pause/options
  202      TRUE         	#ifdef SCREEN_CLEAR
  203 04FA:20 ** **     	jsr clear.screen	;clear screen for the next go-around
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page    5
                        sys.src                         07:11:20  

  204                   	#else
  215                   	#endif
  216 04FD:60           	rts
  217                   
  218                   
  219                   
  220                   ; ---------------- do.sprite -------------
  221                   ; display a sprite list
  222                   ; call with x,y pointing to start of sprite list (high
  223 04FE:             do.sprite
  224 04FE:86 09        	stx tmp+1
  225 0500:84 08        	sty tmp
  226                   	RESPRITE tmp,1
    1      TRUE       + 		#IF	1 <> 0
    2 0502:A5 08      + 		  LDA	tmp
    3 0504:8D 10 FC   + 		  STA	SCBNEXTL
    4 0507:A5 09      + 		  LDA	tmp+1
    5 0509:8D 11 FC   + 		  STA	SCBNEXTH
    6                   		#ELSE
   11                 + 		#ENDIF
   12 050C:9C 90 FD   + 		STZ	SDONEACK
   13 050F:A9 01      + 		LDA	#$01
   14 0511:8D 91 FC   + 		STA	SPRGO
   15                   		WAITSUZY
    1      0514       + WAITSUZY.000F1	.= *
    2 0514:A9 01      + 		lda #SUZY_SPACE
    3 0516:0C F9 FF   + 		tsb MAPCTL		
    4 0519:9C 91 FD   + 		STZ	CPUSLEEP
    5 051C:1C F9 FF   + 		trb MAPCTL		
    6 051F:AD 92 FC   + 		LDA	SPRSYS		
    7 0522:4A         + 		LSR	A		
    8 0523:B0 EF      + 		BCS	WAITSUZY.000F1		
    9 0525:9C 90 FD   + 		STZ	SDONEACK
   10                 + 
   16                 + 
  227 0528:60           	rts
  228                   
  229                   ; --------------- clear.screen -------------
  230                   ; clears screen to all pixel #0
  231 0529:             clear.screen
  232 0529:9C 04 FC     	stz HOFFL
  233 052C:9C 05 FC     	stz HOFFH
  234 052F:9C 06 FC     	stz VOFFL
  235 0532:9C 07 FC     	stz VOFFH
  236                   	SPRITES black,0
    1      FALSE        		#IF	0 <> 0
    6                 + 		#ELSE
    7 0535:A9 **      + 		  LDA	#<black
    8 0537:8D 10 FC   + 		  STA	SCBNEXTL
    9 053A:A9 **      + 		  LDA	#>black
   10 053C:8D 11 FC   + 		  STA	SCBNEXTH
   11                 + 		#ENDIF
   12 053F:AD ** **   + 		LDA	RenderBuffer
   13 0542:8D 08 FC   + 		STA	VIDBASL
   14 0545:AD ** **   + 		LDA	RenderBuffer+1
   15 0548:8D 09 FC   + 		STA	VIDBASH
   16 054B:9C 90 FD   + 		STZ	SDONEACK
   17 054E:A9 01      + 		LDA	#$01
   18 0550:8D 91 FC   + 		STA	SPRGO
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page    6
                        sys.src                         07:11:20  

   19                   		WAITSUZY
    1      0553       + WAITSUZY.00111	.= *
    2 0553:A9 01      + 		lda #SUZY_SPACE
    3 0555:0C F9 FF   + 		tsb MAPCTL		
    4 0558:9C 91 FD   + 		STZ	CPUSLEEP
    5 055B:1C F9 FF   + 		trb MAPCTL		
    6 055E:AD 92 FC   + 		LDA	SPRSYS		
    7 0561:4A         + 		LSR	A		
    8 0562:B0 EF      + 		BCS	WAITSUZY.00111		
    9 0564:9C 90 FD   + 		STZ	SDONEACK
   10                 + 
   20                 + 
  237 0567:A5 0F        	lda hscroll
  238 0569:A4 10        	ldy hscroll+1
  239                   	HOFF16
    1 056B:8D 04 FC   + 		STA	HOFFL
    2 056E:8C 05 FC   + 		STY	HOFFH
    3                 + 
  240 0571:A5 0D        	lda vscroll
  241 0573:A4 0E        	ldy vscroll+1
  242                   	VOFF16
    1 0575:8D 06 FC   + 		STA	VOFFL
    2 0578:8C 07 FC   + 		STY	VOFFH
    3                 + 
  243 057B:60           	rts
  244                   
  245                   ; ---- SCREEN DISPLAY ----
  246                   
  247 057C:             do.screen
  248                   	DBUF_DISPLAY
    1 057C:08         + 		PHP
    2 057D:78         + 		SEI
    3 057E:AD ** **   + 		LDA	RenderBuffer
    4 0581:AE ** **   + 		ldx	DisplayBuffer
    5 0584:8D ** **   + 		STA	DisplayBuffer
    6 0587:8E ** **   + 		stx	RenderBuffer
    7 058A:AD ** **   + 		LDA	RenderBuffer+1
    8 058D:AE ** **   + 		ldx	DisplayBuffer+1
    9 0590:8D ** **   + 		STA	DisplayBuffer+1
   10 0593:8E ** **   + 		stx	RenderBuffer+1
   11 0596:28         + 		PLP
   12                 + 
  249 0597:A2 04        	ldx #FRAME_RATE
  250 0599:86 08        	stx tmp
  251 059B:             wait.for.more.frames
  252                   	WAITEOF
    1 059B:A9 **      + 		LDA	#DISPLAY_EOFFLAG
    2 059D:1C ** **   + 		TRB	DisplayFlags
    3      05A0       + systemp		.=	*
    4 05A0:2C ** **   + 		BIT	DisplayFlags
    5 05A3:F0 FB      + 		BEQ	systemp
    6                 + 
  253 05A5:AD ** **     	lda DisplayFrameCount
  254 05A8:C5 08        	cmp tmp
  255 05AA:90 EF        	bcc wait.for.more.frames
  256 05AC:9C ** **     	stz DisplayFrameCount
  257 05AF:A5 11        	lda new.colors
  258 05B1:F0 **        	beq no.screen
  259                   	RGB16 old.colors.rgb
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page    7
                        sys.src                         07:11:20  

    1 05B3:A9 **      + 		LDA	#<old.colors.rgb
    2 05B5:85 00      + 		STA	sysptr
    3 05B7:A9 **      + 		LDA	#>old.colors.rgb
    4 05B9:85 01      + 		STA	sysptr+1
    5 05BB:A0 1F      + 		LDY	#31
    6 05BD:B1 00      + 		LDA	(sysptr),Y
    7 05BF:99 A0 FD   + 		STA	GREEN0,Y
    8 05C2:88         + 		DEY
    9 05C3:10 F8      + 		BPL	*-6
   10                 + 
  260 05C5:64 11        	stz new.colors
  261 05C7:             no.screen
  262                   
  263                   ; warning - this is used as a null interrupt
  264 05C7:             MyReturn
  265 05C7:60           	rts
  266                   
  267                   ;one frame delay (for use in check.controls
  268 05C8:             delay
  269 05C8:A2 04        	ldx #FRAME_RATE
  270 05CA:86 08        	stx tmp
  271 05CC:             continue.delay
  272                   	WAITEOF
    1 05CC:A9 **      + 		LDA	#DISPLAY_EOFFLAG
    2 05CE:1C ** **   + 		TRB	DisplayFlags
    3      05D1       + systemp		.=	*
    4 05D1:2C ** **   + 		BIT	DisplayFlags
    5 05D4:F0 FB      + 		BEQ	systemp
    6                 + 
  273 05D6:AD ** **     	lda DisplayFrameCount
  274 05D9:C5 08        	cmp tmp
  275 05DB:90 EF        	bcc continue.delay
  276 05DD:9C ** **     	stz DisplayFrameCount
  277 05E0:60           	rts
  278                   
  279                   
  280                   
  281      FALSE        	#ifdef MULTIPLAYER
  516                   	#else ;of ifdef MULTIPLAYER
  517                   ;================= SINGLE PLAYER =====================
  518                   
  519                   ;----------------- check.controls --------------
  520                   
  521                   ; control button processing: pause/restart/flip
  522                   
  523 05E1:             check.controls.pause.loop
  524 05E1:20 C8 05     	jsr delay
  525                   
  526                   ;entry point
  527 05E4:             check.controls
  528 05E4:20 ** **     	jsr get.controls	;get joystic/control info for next f
  529 05E7:             check.controls.player.loop
  530                   ;set the timers
  531 05E7:A5 18        	lda control.edge
  532 05E9:29 F0        	and #$f0
  533 05EB:C9 F0        	cmp #$f0
  534 05ED:D0 **        	bne .00
  535 05EF:A9 03        	lda #DEBOUNCE
  536 05F1:85 1B        	sta pause.timer
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page    8
                        sys.src                         07:11:20  

  537 05F3:             .00
  538 05F3:A5 18        	lda control.edge
  539 05F5:29 04        	and #OPTION2_BUTTON
  540 05F7:F0 **        	beq .01
  541 05F9:A9 03        	lda #DEBOUNCE
  542 05FB:85 1C        	sta opt2.timer
  543 05FD:             .01
  544                   ;1st flip check
  545 05FD:A5 18        	lda control.edge
  546 05FF:29 04        	and #OPTION2_BUTTON
  547 0601:F0 **        	beq .02
  548 0603:A5 17        	lda control.level
  549 0605:29 F0        	and #$f0
  550 0607:C9 F0        	cmp #$f0
  551 0609:D0 **        	bne .02
  552 060B:20 ** **     	jsr do.flip
  553 060E:             .02
  554                   ;reset check
  555 060E:A5 17        	lda control.level
  556 0610:29 F8        	and #OPTION1_BUTTON+$f0
  557 0612:C9 F8        	cmp #OPTION1_BUTTON+$f0
  558 0614:D0 **        	bne .03
  559 0616:4C ** **     	jmp do.reset
  560 0619:             .03
  561                   ;2nd flip check
  562 0619:A5 17        	lda control.level
  563 061B:29 04        	and #OPTION2_BUTTON
  564 061D:F0 **        	beq .04
  565 061F:A5 18        	lda control.edge
  566 0621:29 F0        	and #$f0
  567 0623:C9 F0        	cmp #$f0
  568 0625:D0 **        	bne .04
  569 0627:A5 18        	lda control.edge	;this prevents double flip if in sam
  570 0629:29 04        	and #OPTION2_BUTTON
  571 062B:D0 **        	bne .04
  572 062D:20 ** **     	jsr do.flip
  573 0630:             .04
  574                   ;check pause timeout
  575 0630:A5 1B        	lda pause.timer
  576 0632:F0 **        	beq .05
  577 0634:C6 1B        	dec pause.timer
  578 0636:D0 **        	bne .05
  579 0638:20 ** **     	jsr toggle.pause
  580 063B:             .05
  581                   ;check option timeout
  582 063B:A5 1C        	lda opt2.timer
  583 063D:F0 **        	beq .06
  584 063F:C6 1C        	dec opt2.timer
  585 0641:D0 **        	bne .06
  586      FALSE        	#ifdef MUSIC_TOGGLE
  588                   	#else
  589 0643:A5 1A        	lda edge
  590 0645:09 04        	ora #OPTION2_BUTTON
  591 0647:85 1A        	sta edge
  592                   	#endif
  593 0649:             .06
  594 0649:A5 1D        	lda pause.flag
  595 064B:D0 94        	bne check.controls.pause.loop
  596 064D:60           	rts
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page    9
                        sys.src                         07:11:20  

  597                   
  598      FALSE        	#ifdef MUSIC_TOGGLE
  604                   	#endif
  605                   
  606 064E:             do.flip
  607 064E:64 1B        	stz pause.timer
  608 0650:64 1C        	stz opt2.timer
  609                   	FLIP
    1 0652:AD ** **   + 		LDA	DISPCTL_RAM
    2 0655:49 02      + 		EOR	#DISP_FLIP
    3 0657:8D ** **   + 		STA	DISPCTL_RAM
    4 065A:AD ** **   + 		LDA	SPRSYS_RAM
    5 065D:49 08      + 		EOR	#LEFTHAND
    6 065F:8D ** **   + 		STA	SPRSYS_RAM
    7 0662:8D 92 FC   + 		STA	SPRSYS
    8                 + 
  610 0665:60           	rts
  611                   
  612                   ;updates level, edge, control.level and control.edge
  613                   ;called once per frame, packs pause into joystick fiel
  614                   ;this packing is done for the sake of comlynx (one byt
  615                   ;this is called by the system, the game gets info from
  616                   ;control.edge
  617                   ;the game should never actually see the pause mode, so
  618                   ;take it into account
  619 0666:             get.controls
  620                   	GETJOY			;get joystick info from hardware
    1 0666:AD B0 FC   + 	  LDA JOYSTICK
    2                 + 
  621 0669:85 08        	sta tmp
  622                   	GETSWITCH		;get pause button
    1 066B:AD B1 FC   + 	  LDA SWITCHES
    2                 + 
  623 066E:29 01        	and #PAUSE_SWITCH
  624 0670:F0 **        	beq .03
  625 0672:A5 08        	lda tmp			;all 1's in joystick means pause
  626 0674:09 F0        	ora #$f0
  627 0676:85 08        	sta tmp
  628 0678:             .03
  629 0678:A5 08        	lda tmp
  630                   
  631                   ;massage for use by sys controls
  632 067A:48           	pha
  633 067B:29 F0        	and #$f0
  634 067D:C9 F0        	cmp #$f0
  635 067F:F0 **        	beq .10
  636 0681:68           	pla
  637 0682:29 0F        	and #$0f
  638 0684:80 **        	bra .11
  639 0686:             .10
  640 0686:68           	pla
  641 0687:             .11
  642 0687:A8           	tay
  643 0688:45 17        	eor control.level	;check for any changes
  644 068A:84 17        	sty control.level	;store new joystick info
  645 068C:25 17        	and control.level	;mask for leading edge only
  646 068E:85 18        	sta control.edge	;store to edge buffer
  647                   
  648 0690:A5 08        	lda tmp
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   10
                        sys.src                         07:11:20  

  649                   ;massage for use by game
  650 0692:48           	pha
  651 0693:29 F0        	and #$f0
  652 0695:C9 F0        	cmp #$f0
  653 0697:D0 **        	bne .00
  654 0699:68           	pla
  655 069A:29 0F        	and #$0f
  656 069C:80 **        	bra .01
  657 069E:             .00
  658 069E:68           	pla
  659 069F:             .01
  660      TRUE         	#ifndef MUSIC_TOGGLE
  661 069F:29 FB        	and #$fb		;don't let the data through now
  662                   	#endif
  663 06A1:A8           	tay
  664 06A2:45 19        	eor level	;check for any changes
  665 06A4:84 19        	sty level	;store new joystick info
  666 06A6:25 19        	and level	;mask for leading edge only
  667 06A8:85 1A        	sta edge	;store to edge buffer
  668 06AA:60           	rts
  669                   
  670                   	#endif ;of else for ifdef MULTIPLAYER
  671                   
  672                   
  673                   
  674 06AB:             toggle.pause
  675 06AB:A5 1D        	lda pause.flag
  676 06AD:49 FF        	eor #$ff
  677 06AF:85 1D        	sta pause.flag
  678 06B1:D0 **        	bne show.paused
  679                   
  680 06B3:             clear.paused
  681      FALSE        	#ifdef MUSIC_TOGGLE
  688                   	#else
  689                   	MUTE
    1 06B3:20 ** **   + 	JSR Mute
    2                 + 
  690                   	#endif
  691 06B6:AD ** **     	lda pause.save.1
  692 06B9:8D AC FD     	sta GREENC		;save old screen colors
  693 06BC:AD ** **     	lda pause.save.2
  694 06BF:8D BC FD     	sta BLUEREDC
  695 06C2:AD ** **     	lda pause.save.3
  696 06C5:8D B8 FD     	sta BLUERED8
  697 06C8:AD ** **     	lda pause.save.4
  698 06CB:8D A8 FD     	sta GREEN8
  699 06CE:60           	rts
  700                   	
  701 06CF:             show.paused
  702      FALSE        	#ifdef MUSIC_TOGGLE
  707                   	#else
  708                   	MUTE
    1 06CF:20 ** **   + 	JSR Mute
    2                 + 
  709                   	#endif
  710 06D2:AD AC FD     	lda GREENC		;save old screen colors
  711 06D5:8D ** **     	sta pause.save.1
  712 06D8:AD BC FD     	lda BLUEREDC
  713 06DB:8D ** **     	sta pause.save.2
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   11
                        sys.src                         07:11:20  

  714 06DE:AD B8 FD     	lda BLUERED8
  715 06E1:8D ** **     	sta pause.save.3
  716 06E4:AD A8 FD     	lda GREEN8
  717 06E7:8D ** **     	sta pause.save.4
  718 06EA:A9 FF        	lda #$ff		;make message white on black
  719 06EC:8D AC FD     	sta GREENC
  720 06EF:8D BC FD     	sta BLUEREDC
  721 06F2:9C A8 FD     	stz GREEN8
  722 06F5:9C B8 FD     	stz BLUERED8
  723                   ; reset screen offsets to center "Paused"
  724 06F8:9C 04 FC     	stz HOFFL
  725 06FB:9C 05 FC     	stz HOFFH
  726 06FE:9C 06 FC     	stz VOFFL
  727 0701:9C 07 FC     	stz VOFFH
  728                   ; display the "Paused Message"
  729                   	DBUF_DISPLAY
    1 0704:08         + 		PHP
    2 0705:78         + 		SEI
    3 0706:AD ** **   + 		LDA	RenderBuffer
    4 0709:AE ** **   + 		ldx	DisplayBuffer
    5 070C:8D ** **   + 		STA	DisplayBuffer
    6 070F:8E ** **   + 		stx	RenderBuffer
    7 0712:AD ** **   + 		LDA	RenderBuffer+1
    8 0715:AE ** **   + 		ldx	DisplayBuffer+1
    9 0718:8D ** **   + 		STA	DisplayBuffer+1
   10 071B:8E ** **   + 		stx	RenderBuffer+1
   11 071E:28         + 		PLP
   12                 + 
  730                   	SPRITES paused.scb,0
    1      FALSE        		#IF	0 <> 0
    6                 + 		#ELSE
    7 071F:A9 **      + 		  LDA	#<paused.scb
    8 0721:8D 10 FC   + 		  STA	SCBNEXTL
    9 0724:A9 **      + 		  LDA	#>paused.scb
   10 0726:8D 11 FC   + 		  STA	SCBNEXTH
   11                 + 		#ENDIF
   12 0729:AD ** **   + 		LDA	RenderBuffer
   13 072C:8D 08 FC   + 		STA	VIDBASL
   14 072F:AD ** **   + 		LDA	RenderBuffer+1
   15 0732:8D 09 FC   + 		STA	VIDBASH
   16 0735:9C 90 FD   + 		STZ	SDONEACK
   17 0738:A9 01      + 		LDA	#$01
   18 073A:8D 91 FC   + 		STA	SPRGO
   19                   		WAITSUZY
    1      073D       + WAITSUZY.001F1	.= *
    2 073D:A9 01      + 		lda #SUZY_SPACE
    3 073F:0C F9 FF   + 		tsb MAPCTL		
    4 0742:9C 91 FD   + 		STZ	CPUSLEEP
    5 0745:1C F9 FF   + 		trb MAPCTL		
    6 0748:AD 92 FC   + 		LDA	SPRSYS		
    7 074B:4A         + 		LSR	A		
    8 074C:B0 EF      + 		BCS	WAITSUZY.001F1		
    9 074E:9C 90 FD   + 		STZ	SDONEACK
   10                 + 
   20                 + 
  731                   	DBUF_DISPLAY
    1 0751:08         + 		PHP
    2 0752:78         + 		SEI
    3 0753:AD ** **   + 		LDA	RenderBuffer
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   12
                        sys.src                         07:11:20  

    4 0756:AE ** **   + 		ldx	DisplayBuffer
    5 0759:8D ** **   + 		STA	DisplayBuffer
    6 075C:8E ** **   + 		stx	RenderBuffer
    7 075F:AD ** **   + 		LDA	RenderBuffer+1
    8 0762:AE ** **   + 		ldx	DisplayBuffer+1
    9 0765:8D ** **   + 		STA	DisplayBuffer+1
   10 0768:8E ** **   + 		stx	RenderBuffer+1
   11 076B:28         + 		PLP
   12                 + 
  732 076C:60           	rts
  733                   
  734 076D:00           pause.save.1	.by 0
  735 076E:00           pause.save.2	.by 0
  736 076F:00           pause.save.3	.by 0
  737 0770:00           pause.save.4	.by 0
  738                   
  739                   ; wait for awhile & cold boot
  740 0771:             do.reset
  741                   	STOPMUSIC		;music off
    1 0771:20 ** **   + 	JSR StopMusic
    2                 + 
  742 0774:20 29 05     	jsr clear.screen
  743 0777:20 ** **     	jsr black.screen
  744 077A:A2 3C        	ldx #60
  745 077C:86 08        	stx tmp
  746 077E:             .00
  747                   	WAITEOF
    1 077E:A9 **      + 		LDA	#DISPLAY_EOFFLAG
    2 0780:1C ** **   + 		TRB	DisplayFlags
    3      0783       + systemp		.=	*
    4 0783:2C ** **   + 		BIT	DisplayFlags
    5 0786:F0 FB      + 		BEQ	systemp
    6                 + 
  748 0788:AD ** **     	lda DisplayFrameCount
  749 078B:C5 08        	cmp tmp
  750 078D:90 EF        	bcc .00
  751 078F:4C 00 04     	jmp cold.start
  752                   
  753                   
  754                   
  755                   
  756                   
  757                   
  758      TRUE         	#ifdef CHEAP_PAUSED
  759                   ; this is the cheap version of paused
  760 0792:             paused.scb
  761 0792:45           	.by TWO_PER_PIXEL+NONCOLL_SPRITE
  762 0793:10           	.by RELOAD_HV
  763 0794:00           	.by 0
  764 0795:00 00 00 00  	.wo 0,paused.data,32,38
  764      20 00 26 00  
  764                   
  765 079D:00 04 00 04  	.wo $400,$400		;expand to big message
  765                   
  766 07A1:08 C0        	.by $08,$c0		;the rest of the palette doesn't matter
  767                   
  768 07A3:             paused.data
  769                   ; Handy Sprite Image Data
  770                   ; Bits per Pixel = 2
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   13
                        sys.src                         07:11:20  

  771                   ; Next data is down-right
  772 07A3:03 7A 84     	.BYTE	$03,$7a,$84
  773 07A6:09 C3 53 53  	.BYTE	$09,$c3,$53,$53,$f9,$9a,$9a,$9a,$50
  773      F9 9A 9A 9A  
  773      50           
  774 07AF:09 C3 33 33  	.BYTE	$09,$c3,$33,$33,$f9,$99,$59,$59,$90
  774      F9 99 59 59  
  774      90           
  775 07B8:09 C3 53 53  	.BYTE	$09,$c3,$53,$53,$f9,$9a,$9a,$59,$90
  775      F9 9A 9A 59  
  775      90           
  776 07C1:09 C3 2B 33  	.BYTE	$09,$c3,$2b,$33,$f9,$95,$99,$59,$90
  776      F9 95 99 59  
  776      90           
  777 07CA:09 C3 2B 33  	.BYTE	$09,$c3,$2b,$33,$fa,$9a,$9a,$9a,$50
  777      FA 9A 9A 9A  
  777      50           
  778 07D3:03 7A 84     	.BYTE	$03,$7a,$84
  779 07D6:00           	.BYTE	$00
  780                   ; 52 total image bytes
  781                   	#else
  851                   	#endif
  852                   
  853                   
  854                   
  855                   
  856                   
  857                   
  858                   
  859                   ; ------------------ start.tune -------------------
  860                   ; Starts playing tune
  861                   ; x high byte of music address
  862                   ; a low byte of music address
  863                   ; y tune poke (some timing magic)
  864                   
  865 07D7:             start.tune
  866 07D7:5A           	phy
  867                   	PLAYMUSIC
    1 07D8:20 ** **   + 	JSR PlayMusic
    2                 + 
  868 07DB:7A           	ply
  869 07DC:8C 18 FD     	sty TIMER6
  870 07DF:60           	rts
  871                   
  872                   
  873                   ; ---------------- black.screen -------------
  874                   ; clears screen to black (no fade), but does not draw 
  875 07E0:             black.screen
  876 07E0:A2 1F        	ldx #32-1
  877 07E2:             .00
  878 07E2:9E ** **     	stz new.colors.rgb,x
  879 07E5:9E ** **     	stz old.colors.rgb,x
  880 07E8:CA           	dex
  881 07E9:10 F7        	bpl .00
  882                   	WAITEOF
    1 07EB:A9 **      + 		LDA	#DISPLAY_EOFFLAG
    2 07ED:1C ** **   + 		TRB	DisplayFlags
    3      07F0       + systemp		.=	*
    4 07F0:2C ** **   + 		BIT	DisplayFlags
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   14
                        sys.src                         07:11:20  

    5 07F3:F0 FB      + 		BEQ	systemp
    6                 + 
  883                   	RGB16 old.colors.rgb
    1 07F5:A9 **      + 		LDA	#<old.colors.rgb
    2 07F7:85 00      + 		STA	sysptr
    3 07F9:A9 **      + 		LDA	#>old.colors.rgb
    4 07FB:85 01      + 		STA	sysptr+1
    5 07FD:A0 1F      + 		LDY	#31
    6 07FF:B1 00      + 		LDA	(sysptr),Y
    7 0801:99 A0 FD   + 		STA	GREEN0,Y
    8 0804:88         + 		DEY
    9 0805:10 F8      + 		BPL	*-6
   10                 + 
  884 0807:A9 01        	lda #1
  885 0809:85 11        	sta new.colors
  886 080B:60           	rts
  887                   
  888                   ; --------------- fade.to.black -------------
  889                   ; initiates fade to all black operation
  890 080C:             fade.to.black
  891 080C:A9 00        	lda #0
  892                   ; warning! fall through to set.colors
  893                   
  894                   
  895                   ; --------------- set.colors ----------------
  896                   ; set color palette from table
  897                   ; note that this initiates a fade from the current pal
  898                   ; color set number in accum
  899 080E:             set.colors
  900 080E:0A           	asl
  901 080F:AA           	tax
  902 0810:BD ** **     	lda color.pnts,x
  903 0813:85 08        	sta tmp
  904 0815:BD ** **     	lda color.pnts+1,x
  905 0818:85 09        	sta tmp+1
  906 081A:A0 1F        	ldy #32-1
  907 081C:84 12        	sty fading	;non-zero
  908 081E:             .00
  909 081E:B1 08        	lda (tmp),y
  910 0820:99 ** **     	sta new.colors.rgb,y
  911 0823:88           	dey
  912 0824:10 F8        	bpl .00
  913 0826:60           	rts
  914                   
  915                   ; this is called by the system to fade to different co
  916 0827:             fade
  917 0827:A5 13        	lda slow.fade	;set to $ff to fade slowly
  918 0829:10 **        	bpl .00
  919 082B:A5 0C        	lda count
  920 082D:29 07        	and #7
  921 082F:F0 **        	beq .00
  922 0831:60           	rts
  923 0832:             .00
  924 0832:A5 12        	lda fading
  925 0834:F0 **        	beq done.fade
  926 0836:64 12        	stz fading
  927 0838:A0 01        	ldy #1
  928 083A:A2 0F        	ldx #15
  929 083C:             fade.1
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   15
                        sys.src                         07:11:20  

  930 083C:BD ** **     	lda new.colors.g,x
  931 083F:29 0F        	and #$f
  932 0841:85 08        	sta tmp
  933 0843:BD ** **     	lda old.colors.g,x
  934 0846:20 ** **     	jsr fader
  935 0849:9D ** **     	sta old.colors.g,x
  936                   
  937 084C:BD ** **     	lda new.colors.br,x
  938 084F:29 0F        	and #$f
  939 0851:85 08        	sta tmp
  940 0853:BD ** **     	lda old.colors.br,x
  941 0856:20 ** **     	jsr fader
  942 0859:85 09        	sta tmp+1
  943                   
  944 085B:BD ** **     	lda new.colors.br,x
  945 085E:4A           	lsr
  946 085F:4A           	lsr
  947 0860:4A           	lsr
  948 0861:4A           	lsr
  949 0862:29 0F        	and #$f
  950 0864:85 08        	sta tmp
  951 0866:BD ** **     	lda old.colors.br,x
  952 0869:4A           	lsr
  953 086A:4A           	lsr
  954 086B:4A           	lsr
  955 086C:4A           	lsr
  956 086D:20 ** **     	jsr fader
  957 0870:0A           	asl
  958 0871:0A           	asl
  959 0872:0A           	asl
  960 0873:0A           	asl
  961 0874:29 F0        	and #$f0
  962 0876:05 09        	ora tmp+1
  963 0878:9D ** **     	sta old.colors.br,x
  964 087B:CA           	dex
  965 087C:10 BE        	bpl fade.1
  966 087E:A9 01        	lda #1
  967 0880:85 11        	sta new.colors
  968 0882:             done.fade
  969 0882:60           	rts
  970                   
  971 0883:             fader
  972 0883:29 0F        	and #$f			;trim current fade
  973 0885:C5 08        	cmp tmp			;compare with target
  974 0887:F0 **        	beq fader.2		;done
  975 0889:B0 **        	bcs fader.1		;don't go past target
  976 088B:1A           	ina
  977 088C:29 0F        	and #$f
  978 088E:84 12        	sty fading		;y is non-zero
  979 0890:60           	rts
  980 0891:             fader.1
  981 0891:3A           	dea
  982 0892:84 12        	sty fading		;y is non-zero
  983 0894:             fader.2
  984 0894:60           	rts
  985                   
  986                   
  987      00FF         num		.eq $ff
  988      0008         dig.wid		.eq 8
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   16
                        sys.src                         07:11:20  

  989      0070         scpos		.eq 160-{SCORE_SIZE*2*dig.wid}
  990                   
  991                   ; this is called by the system to display the score
  992                   ; the score is right justified in the upper right corn
  993                   ; leading zeros are trimmed, and a score of all 0 prod
  994                   
  995 0895:             show.score
  996 0895:9C 04 FC     	stz HOFFL		;clear scrolling
  997 0898:9C 05 FC     	stz HOFFH
  998 089B:9C 06 FC     	stz VOFFL
  999 089E:9C 07 FC     	stz VOFFH
 1000 08A1:64 08        	stz tmp			;blank leading zeros
 1001 08A3:A9 70        	lda #scpos
 1002 08A5:8D ** **     	sta score.scb+7
 1003                   
 1004 08A8:A2 02        	ldx #SCORE_SIZE-1
 1005 08AA:             show.score.loop
 1006 08AA:B5 14        	lda score,x
 1007 08AC:20 ** **     	jsr show.score.byte
 1008 08AF:CA           	dex
 1009 08B0:10 F8        	bpl show.score.loop
 1010 08B2:60           	rts
 1011                   
 1012 08B3:             show.score.byte
 1013 08B3:DA           	phx
 1014 08B4:48           	pha
 1015 08B5:4A           	lsr
 1016 08B6:4A           	lsr
 1017 08B7:4A           	lsr
 1018 08B8:4A           	lsr
 1019 08B9:20 ** **     	jsr show.score.nib
 1020 08BC:68           	pla
 1021 08BD:29 0F        	and #$f
 1022 08BF:20 ** **     	jsr show.score.nib
 1023 08C2:FA           	plx
 1024 08C3:60           	rts
 1025                   
 1026 08C4:             show.score.nib
 1027 08C4:A6 08        	ldx tmp
 1028 08C6:D0 **        	bne score.nib.1
 1029 08C8:C9 00        	cmp #0
 1030 08CA:D0 **        	bne score.nib.1
 1031 08CC:             clear.score.nib
 1032 08CC:A9 0A        	lda #10			;blank leading zeros
 1033 08CE:80 **        	bra score.nib.2
 1034 08D0:             score.nib.1
 1035 08D0:A2 01        	ldx #1
 1036 08D2:86 08        	stx tmp
 1037 08D4:             score.nib.2
 1038 08D4:AA           	tax
 1039 08D5:BD ** **     	lda num.tab.lo,x
 1040 08D8:8D ** **     	sta score.scb+5
 1041 08DB:BD ** **     	lda num.tab.hi,x
 1042 08DE:8D ** **     	sta score.scb+6
 1043                   
 1044                   	RESPRITE score.scb,0
    1      FALSE        		#IF	0 <> 0
    6                 + 		#ELSE
    7 08E1:A9 **      + 		  LDA	#<score.scb
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   17
                        sys.src                         07:11:20  

    8 08E3:8D 10 FC   + 		  STA	SCBNEXTL
    9 08E6:A9 **      + 		  LDA	#>score.scb
   10 08E8:8D 11 FC   + 		  STA	SCBNEXTH
   11                 + 		#ENDIF
   12 08EB:9C 90 FD   + 		STZ	SDONEACK
   13 08EE:A9 01      + 		LDA	#$01
   14 08F0:8D 91 FC   + 		STA	SPRGO
   15                   		WAITSUZY
    1      08F3       + WAITSUZY.00271	.= *
    2 08F3:A9 01      + 		lda #SUZY_SPACE
    3 08F5:0C F9 FF   + 		tsb MAPCTL		
    4 08F8:9C 91 FD   + 		STZ	CPUSLEEP
    5 08FB:1C F9 FF   + 		trb MAPCTL		
    6 08FE:AD 92 FC   + 		LDA	SPRSYS		
    7 0901:4A         + 		LSR	A		
    8 0902:B0 EF      + 		BCS	WAITSUZY.00271		
    9 0904:9C 90 FD   + 		STZ	SDONEACK
   10                 + 
   16                 + 
 1045 0907:AD ** **     	lda score.scb+7
 1046 090A:18           	clc
 1047 090B:69 08        	adc #dig.wid
 1048 090D:8D ** **     	sta score.scb+7
 1049 0910:60           	rts
 1050                   
 1051 0911:             score.scb
 1052 0911:45           	.by TWO_PER_PIXEL+NONCOLL_SPRITE
 1053 0912:30           	.by RELOAD_HVST
 1054 0913:00           	.by 0
 1055 0914:00 ** ** **  	.wo 0,num0.data
 1055                   
 1056 0918:00 00 02 00  	.wo 0,2
 1056                   
 1057 091C:00 01        	.wo $0100
 1058 091E:00 01        	.wo $0100
 1059 0920:00 00 00 00  	.wo 0,0
 1059                   
 1060 0924:08 C0        	.by $08,$c0
 1061                   
 1062                   
 1063 0926:             num0.data
 1064                   
 1065                   ; Handy Sprite Image Data
 1066                   ; Bits per Pixel = 2
 1067                   ; Next data is down-right
 1068 0926:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1068                   
 1069 092A:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1069      00           
 1070 092F:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1070      68 20 00     
 1071 0936:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1071      68 20 00     
 1072 093D:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1072      68 20 00     
 1073 0944:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1073      68 20 00     
 1074 094B:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1074      68 20 00     
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   18
                        sys.src                         07:11:20  

 1075 0952:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1075      00           
 1076 0957:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1076                   
 1077 095B:00           	.BYTE	$00
 1078                   ; 54 total image bytes
 1079 095C:             num1.data
 1080                   
 1081                   ; Handy Sprite Image Data
 1082                   ; Bits per Pixel = 2
 1083                   ; Next data is down-right
 1084 095C:04 08 34 00  	.BYTE	$04,$08,$34,$00
 1084                   
 1085 0960:06 80 14 34  	.BYTE	$06,$80,$14,$34,$10,$00
 1085      10 00        
 1086 0966:05 88 8A 82  	.BYTE	$05,$88,$8a,$82,$00
 1086      00           
 1087 096B:06 80 14 34  	.BYTE	$06,$80,$14,$34,$10,$00
 1087      10 00        
 1088 0971:06 09 04 34  	.BYTE	$06,$09,$04,$34,$10,$00
 1088      10 00        
 1089 0977:06 09 04 34  	.BYTE	$06,$09,$04,$34,$10,$00
 1089      10 00        
 1090 097D:05 12 18 48  	.BYTE	$05,$12,$18,$48,$00
 1090      00           
 1091 0982:05 82 5A 08  	.BYTE	$05,$82,$5a,$08,$00
 1091      00           
 1092 0987:03 3A 00     	.BYTE	$03,$3a,$00
 1093 098A:00           	.BYTE	$00
 1094                   ; 47 total image bytes
 1095                   
 1096 098B:             num2.data
 1097                   
 1098                   ; Handy Sprite Image Data
 1099                   ; Bits per Pixel = 2
 1100                   ; Next data is down-right
 1101 098B:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1101                   
 1102 098F:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1102      00           
 1103 0994:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1103      68 20 00     
 1104 099B:05 22 1A 08  	.BYTE	$05,$22,$1a,$08,$00
 1104      00           
 1105 09A0:06 80 14 50  	.BYTE	$06,$80,$14,$50,$50,$00
 1105      50 00        
 1106 09A6:05 0A 18 48  	.BYTE	$05,$0a,$18,$48,$00
 1106      00           
 1107 09AB:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1107      68 20 00     
 1108 09B2:05 82 5A 08  	.BYTE	$05,$82,$5a,$08,$00
 1108      00           
 1109 09B7:03 3A 00     	.BYTE	$03,$3a,$00
 1110 09BA:00           	.BYTE	$00
 1111                   ; 48 total image bytes
 1112 09BB:             num3.data
 1113                   
 1114                   ; Handy Sprite Image Data
 1115                   ; Bits per Pixel = 2
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   19
                        sys.src                         07:11:20  

 1116                   ; Next data is down-right
 1117 09BB:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1117                   
 1118 09BF:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1118      00           
 1119 09C4:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1119      68 20 00     
 1120 09CB:05 22 1A 08  	.BYTE	$05,$22,$1a,$08,$00
 1120      00           
 1121 09D0:06 09 04 54  	.BYTE	$06,$09,$04,$54,$10,$00
 1121      10 00        
 1122 09D6:05 22 1A 08  	.BYTE	$05,$22,$1a,$08,$00
 1122      00           
 1123 09DB:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1123      68 20 00     
 1124 09E2:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1124      00           
 1125 09E7:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1125                   
 1126 09EB:00           	.BYTE	$00
 1127                   ; 49 total image bytes
 1128 09EC:             num4.data
 1129                   
 1130                   ; Handy Sprite Image Data
 1131                   ; Bits per Pixel = 2
 1132                   ; Next data is down-right
 1133 09EC:04 10 44 00  	.BYTE	$04,$10,$44,$00
 1133                   
 1134 09F0:06 08 14 54  	.BYTE	$06,$08,$14,$54,$10,$00
 1134      10 00        
 1135 09F6:06 80 14 74  	.BYTE	$06,$80,$14,$74,$10,$00
 1135      10 00        
 1136 09FC:07 0A 1A 08  	.BYTE	$07,$0a,$1a,$08,$68,$20,$00
 1136      68 20 00     
 1137 0A03:07 82 18 28  	.BYTE	$07,$82,$18,$28,$60,$a0,$00
 1137      60 A0 00     
 1138 0A0A:05 82 6A 08  	.BYTE	$05,$82,$6a,$08,$00
 1138      00           
 1139 0A0F:05 22 18 28  	.BYTE	$05,$22,$18,$28,$00
 1139      00           
 1140 0A14:06 11 04 74  	.BYTE	$06,$11,$04,$74,$10,$00
 1140      10 00        
 1141 0A1A:04 10 54 00  	.BYTE	$04,$10,$54,$00
 1141                   
 1142 0A1E:00           	.BYTE	$00
 1143                   ; 51 total image bytes
 1144 0A1F:             num5.data
 1145                   
 1146                   ; Handy Sprite Image Data
 1147                   ; Bits per Pixel = 2
 1148                   ; Next data is down-right
 1149 0A1F:03 3A 00     	.BYTE	$03,$3a,$00
 1150 0A22:05 82 5A 08  	.BYTE	$05,$82,$5a,$08,$00
 1150      00           
 1151 0A27:05 82 18 88  	.BYTE	$05,$82,$18,$88,$00
 1151      00           
 1152 0A2C:05 82 48 28  	.BYTE	$05,$82,$48,$28,$00
 1152      00           
 1153 0A31:05 22 1A 08  	.BYTE	$05,$22,$1a,$08,$00
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   20
                        sys.src                         07:11:20  

 1153      00           
 1154 0A36:06 80 34 34  	.BYTE	$06,$80,$34,$34,$10,$00
 1154      10 00        
 1155 0A3C:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1155      68 20 00     
 1156 0A43:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1156      00           
 1157 0A48:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1157                   
 1158 0A4C:00           	.BYTE	$00
 1159                   ; 46 total image bytes
 1160                   
 1161 0A4D:             num6.data
 1162                   
 1163                   ; Handy Sprite Image Data
 1164                   ; Bits per Pixel = 2
 1165                   ; Next data is down-right
 1166 0A4D:04 08 44 00  	.BYTE	$04,$08,$44,$00
 1166                   
 1167 0A51:06 80 14 54  	.BYTE	$06,$80,$14,$54,$10,$00
 1167      10 00        
 1168 0A57:05 0A 18 48  	.BYTE	$05,$0a,$18,$48,$00
 1168      00           
 1169 0A5C:05 82 18 48  	.BYTE	$05,$82,$18,$48,$00
 1169      00           
 1170 0A61:05 82 4A 08  	.BYTE	$05,$82,$4a,$08,$00
 1170      00           
 1171 0A66:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1171      68 20 00     
 1172 0A6D:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1172      68 20 00     
 1173 0A74:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1173      00           
 1174 0A79:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1174                   
 1175 0A7D:00           	.BYTE	$00
 1176                   ; 49 total image bytes
 1177                   
 1178 0A7E:             num7.data
 1179                   
 1180                   ; Handy Sprite Image Data
 1181                   ; Bits per Pixel = 2
 1182                   ; Next data is down-right
 1183 0A7E:03 3A 00     	.BYTE	$03,$3a,$00
 1184 0A81:05 82 5A 08  	.BYTE	$05,$82,$5a,$08,$00
 1184      00           
 1185 0A86:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1185      68 20 00     
 1186 0A8D:05 22 1A 08  	.BYTE	$05,$22,$1a,$08,$00
 1186      00           
 1187 0A92:06 08 14 30  	.BYTE	$06,$08,$14,$30,$50,$00
 1187      50 00        
 1188 0A98:06 09 04 30  	.BYTE	$06,$09,$04,$30,$50,$00
 1188      50 00        
 1189 0A9E:06 09 04 34  	.BYTE	$06,$09,$04,$34,$10,$00
 1189      10 00        
 1190 0AA4:06 09 04 34  	.BYTE	$06,$09,$04,$34,$10,$00
 1190      10 00        
 1191 0AAA:04 08 34 00  	.BYTE	$04,$08,$34,$00
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   21
                        sys.src                         07:11:20  

 1191                   
 1192 0AAE:00           	.BYTE	$00
 1193                   ; 49 total image bytes
 1194                   
 1195 0AAF:             num8.data
 1196                   
 1197                   ; Handy Sprite Image Data
 1198                   ; Bits per Pixel = 2
 1199                   ; Next data is down-right
 1200 0AAF:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1200                   
 1201 0AB3:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1201      00           
 1202 0AB8:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1202      68 20 00     
 1203 0ABF:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1203      68 20 00     
 1204 0AC6:05 88 8E 82  	.BYTE	$05,$88,$8e,$82,$00
 1204      00           
 1205 0ACB:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1205      68 20 00     
 1206 0AD2:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1206      68 20 00     
 1207 0AD9:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1207      00           
 1208 0ADE:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1208                   
 1209 0AE2:00           	.BYTE	$00
 1210                   ; 52 total image bytes
 1211                   
 1212 0AE3:             num9.data
 1213                   
 1214                   ; Handy Sprite Image Data
 1215                   ; Bits per Pixel = 2
 1216                   ; Next data is down-right
 1217 0AE3:04 80 54 00  	.BYTE	$04,$80,$54,$00
 1217                   
 1218 0AE7:05 0A 38 28  	.BYTE	$05,$0a,$38,$28,$00
 1218      00           
 1219 0AEC:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1219      68 20 00     
 1220 0AF3:07 82 18 28  	.BYTE	$07,$82,$18,$28,$68,$20,$00
 1220      68 20 00     
 1221 0AFA:05 0A 4A 08  	.BYTE	$05,$0a,$4a,$08,$00
 1221      00           
 1222 0AFF:06 80 34 34  	.BYTE	$06,$80,$34,$34,$10,$00
 1222      10 00        
 1223 0B05:06 08 14 30  	.BYTE	$06,$08,$14,$30,$50,$00
 1223      50 00        
 1224 0B0B:05 88 8A 0A  	.BYTE	$05,$88,$8a,$0a,$00
 1224      00           
 1225 0B10:04 80 44 00  	.BYTE	$04,$80,$44,$00
 1225                   
 1226 0B14:00           	.BYTE	$00
 1227                   ; 50 total image bytes
 1228 0B15:             nada.data
 1229 0B15:00 00 00 00  	.by 0,0,0,0
 1229                   
 1230                   
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   22
                        sys.src                         07:11:20  

 1231 0B19:             num.tab.lo
 1232 0B19:26 5C 8B BB  	.by <num0.data,<num1.data,<num2.data,<num3.data,<num4
 1232      EC           
 1233 0B1E:1F 4D 7E AF  	.by <num5.data,<num6.data,<num7.data,<num8.data,<num9
 1233      E3           
 1234 0B23:15           	.by <nada.data
 1235                   
 1236 0B24:             num.tab.hi
 1237 0B24:09 09 09 09  	.by >num0.data,>num1.data,>num2.data,>num3.data,>num4
 1237      09           
 1238 0B29:0A 0A 0A 0A  	.by >num5.data,>num6.data,>num7.data,>num8.data,>num9
 1238      0A           
 1239 0B2E:0B           	.by >nada.data
 1240                   
 1241                   
 1242                   
 1243                   
 1244                   
 1245                   ; ---------------- start.sound ----------------
 1246                   ; sound effect rountine
 1247                   ; makes sound based on the value in A
 1248 0B2F:             start.sound
 1249 0B2F:AA           	tax
 1250 0B30:BC ** **     	ldy sound.pri,x
 1251 0B33:BD ** **     	lda sound.hi,x
 1252 0B36:48           	pha
 1253 0B37:BD ** **     	lda sound.lo,x
 1254 0B3A:FA           	plx
 1255                   	PLAYHSFX
    1 0B3B:20 ** **   + 		JSR	StartHSFX
    2                 + 
 1256 0B3E:60           	rts
 1257                   
 1258                   
 1259                   ; ------------- random -------------
 1260                   ; random number generator
 1261                   ; returns with number in Acc (does not affect other re
 1262                   ; (sequence of 64K numbers)
 1263 0B3F:             random
 1264 0B3F:5A           	phy
 1265 0B40:A4 06        	ldy random.ndx
 1266 0B42:B9 3F 0B     	lda random,y
 1267 0B45:59 00 04     	eor cold.start,y	;some place in code
 1268 0B48:45 06        	eor random.ndx
 1269 0B4A:E6 06        	inc random.ndx
 1270 0B4C:D0 **        	bne .00
 1271 0B4E:E6 07        	inc random.ndx+1
 1272 0B50:             .00
 1273 0B50:45 07        	eor random.ndx+1
 1274 0B52:7A           	ply
 1275 0B53:60           	rts
 1276                   
 1277                   
 1278                   
 1279                   ;----------------- add.score ------------------------
 1280                   ; add to score
 1281                   ; enter with BCD value ($00 to $99) in Acc
 1282 0B54:             add.score
 1283 0B54:A2 00        	ldx #0
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   23
                        sys.src                         07:11:20  

 1284                   ; note: falls through to add.big.score
 1285                   
 1286                   
 1287                   
 1288                   ;----------------- add.big.score ---------------------
 1289                   ; enter here to add large numbers to score
 1290                   ; enter with BCD value ($00 to $99) in Acc
 1291                   ; Reg X should contain the exponent: 1=times100, 2=tim
 1292 0B56:             add.big.score
 1293 0B56:F8           	sed
 1294 0B57:18           	clc
 1295 0B58:65 14        	adc score
 1296 0B5A:85 14        	sta score
 1297 0B5C:90 **        	bcc done.score
 1298 0B5E:             add.score.1
 1299 0B5E:08           	php
 1300 0B5F:E8           	inx
 1301 0B60:E0 03        	cpx #SCORE_SIZE		; prevents fatal type wrap-around
 1302 0B62:F0 **        	beq done.score.1
 1303 0B64:28           	plp
 1304 0B65:B5 14        	lda score,x
 1305 0B67:69 00        	adc #0
 1306 0B69:95 14        	sta score,x
 1307 0B6B:B0 F1        	bcs add.score.1
 1308 0B6D:             done.score
 1309 0B6D:D8           	cld	
 1310 0B6E:60           	rts
 1311 0B6F:             done.score.1
 1312 0B6F:28           	plp
 1313 0B70:D8           	cld
 1314 0B71:60           	rts
 1315                   
 1316 0B72:             black.Data
 1317                   ; Handy Sprite Image Data
 1318                   ; Bits per Pixel = 1
 1319                   ; Next data is down-right
 1320 0B72:02 08        	.BYTE	$02,$08
 1321 0B74:02 08        	.BYTE	$02,$08
 1322 0B76:00           	.BYTE	$00
 1323                   ; 5 total image bytes
 1324 0B77:             black
 1325                   ; Handy Sprite
 1326 0B77:01           	.BYTE	ONE_PER_PIXEL+BACKNONCOLL_SPRITE ; Control 0
 1327 0B78:30           	.BYTE	RELOAD_HVST ; Control 1
 1328 0B79:00           	.BYTE	$00 ; Control 2
 1329 0B7A:00 00        	.WORD	$0000	; Next Sprite
 1330 0B7C:72 0B        	.WORD	black.Data	; ImageData
 1331 0B7E:00 00        	.WORD	0	; HPos
 1332 0B80:00 00        	.WORD	0	; VPos
 1333 0B82:00 50        	.WORD	80*256	; HSize
 1334 0B84:00 33        	.WORD	51*256	; VSize
 1335 0B86:00 00        	.WORD	$0000	; Stretch
 1336 0B88:00 00        	.WORD	$0000	; Tilt
 1337                   	; Palette
 1338 0B8A:00           	.BYTE	$00
 1339                   
 1340                   
 1341 0B8B:             beg.sys
 1342                   ; system code source includes
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   24
                        sys.src                         07:11:20  

 1343                   	.in 6502:src/sysdata.src
    1                   ; Tuesday 27-Mar-90 10:58:04
    2                   * === sysdata.src ====================================
    3                   * 
    4                   * System Data Allocations  --  the 6502 Side of Handy
    5                   * 
    6                   * Copyright (c) 1988,1990 Epyx, Inc.
    7                   * All Rights Reserved
    8                   * CONFIDENTIAL and PROPRIETARY
    9                   * 
   10                   * Date		Name		Description
   11                   * ---------	--------------	---------------------------
   12                   * 27-Mar-90	SHL		Removed BufferAddrL, BufferAddrH
   13                   * 22-Mar-90	SHL		Added INTSET_RAM shadow for IRQs
   14                   * 9-Feb-90	SHL		Removed Apple emulation compatibility
   15                   * 30 May 89	-RJ		Added IODAT_RAM
   16                   * 24 May 89	-RJ		Added AUTO_TIMEOUT_USER support code
   17                   * 20 Apr 89	-RJ		Added IODIR_RAM
   18                   * 19 Apr 89	-RJ		Moved DisplayFrameCount to display.sr
   19                   * 20 Mar 89	-RJ		Added DisplayFrameCount
   20                   * 13 Feb 89	-RJ		Added DisplayBuffer
   21                   * 26 Jan 88	-RJ		Ended Interruptus
   22                   * 24 Dec 88	-RJ		Added Interruptus
   23                   * 22 Dec 88	-RJ		Added DISPCTL_RAM, RenderBuffer, 
   24                   *				BufferAddrL/H, and DisplayFlags with its defs
   25                   *				Added note about .ORGing to non-zpage
   26                   * Early 88	=RJ Mical=	Created this file!
   27                   * 
   28                   * ====================================================
   29                   
   30                   
   31                   * NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE
   32                   * 
   33                   * This file should be included before any of the 6502:
   34                   * 
   35                   * Note that you should .ORG to a non-zero page address
   36                   * this file.  This is because this file includes data 
   37                   * don't need to be in zero-page memory.
   38                   * 
   39                   * NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE
   40                   
   41                   
   42                   * Here are the declarations of the local copies of wri
   43                   * (and read-doesn't-equal-write registers such as SPRS
   44                   * Whenever you want to make a change to one of the har
   45                   * that's write-only, you should read from this RAM cop
   46                   * and then write the value out to both the RAM copy an
   47 0B8B:             SPRSYS_RAM	.DS 1
   48 0B8C:             DISPCTL_RAM	.DS 1
   49 0B8D:             IODAT_RAM	.DS 1
   50 0B8E:             IODIR_RAM	.DS 1
   51                   
   52                   
   53                   * Display buffer pointers for use by the system displa
   54 0B8F:             RenderBuffer	.DS 2
   55 0B91:             DisplayBuffer	.DS 2
   56                   
   57                   * Shadow of INTSET used in IRQ handler
   58 0B93:             INTSET_RAM	.DS 1
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   25
                        6502:src/sysdata.src            07:11:20  

   59                   
   60                   
   61      FALSE        	#IFDEF AUTO_TIMEOUT_USER
   63                   	#ENDIF
   64                   
   65                   
   66                   * The DisplayFlags field is a field that may enjoy mul
   67                   * read-modify-write operations peformed by both interr
   68                   * Because of this, any code must make sure that interr
   69                   * beginning a read-modify-write cycle, or use the TSB/
   70 0B94:             DisplayFlags	.DS	1
   71                   * Here's the definitions of DisplayFlags
   72      0080         DISPLAY_EOFFLAG		.EQ $80	; Set every EOF
   73      0040         DISPLAY_EOLFLAG		.EQ $40	; Set every EOL
   74                   
   75                   
   76                   
 1344                   	.in 6502:src/hsfx.src
    1                   ; Tue Sep 18 17:43:53 1990
    2                   * === hsfx.src =======================================
    3                   *
    4                   * Handy Sound Effects Driver  --  Handy Software
    5                   *
    6                   * Confidential and Proprietary
    7                   * Copyright (C) 1989, Epyx, Inc.
    8                   *
    9                   * Date		Name		Description
   10                   * ---------	--------------	---------------------------
   11                   * 04-May-90	SHL		If not integrated, voice bias reset o
   12                   *				channel.  If integrating, voice bias ramped to
   13                   *				zero.  No longer tries to play sounds if voice
   14                   *				owned by someone else.
   15                   * 19-Apr-90	SHL		AllocAudio and GrabAudio routines now
   16                   *				inly if GRABAUDIO_USER is set.
   17                   *				General code tightening and cleanup.
   18                   *				Moved top_of_loop0,1 variables to hsfx.var .
   19                   *				Moved hsfx_temp to zero page.
   20                   * 18-Apr-90	SHL		InitHSFX now zeroes all HSFX variable
   21                   *				FreeAudio now zeroes bias on stopped channel
   22                   * 01-Apr-90	SHL & G Colgate	Added USER_HSFX switch and
   23                   * 26-Mar-90	SHL		Removed PHA, PHX instructions from hs
   24                   *				Changed driver exit to match new IRQ handler
   25                   * 6 Oct 89	SHL		Modified driver to catch dropped frame
   26                   *				Modified START_DISABLE and END_DISABLE macros
   27                   *				to use the new flag audio_lockout
   28                   * 14 Sep 89	SJ		Fix to register clear in StartHSFX
   29                   * 5 Sept 89	SJ		Changed public calls to lock out just 
   30                   * 31 Aug 89	SJ		Changed code to use HSFX_CHANNELCOUNT 
   31                   *				Made variables relocatable in HSFX.var
   32                   *				User programs now must include HSFX.var also.
   33                   *				Tightened up key frame loop in update_frame.
   34                   * 30 Aug 89	Stephen Jungels	Clear launch_channel flag 
   35                   *				Simplified channel killing code.
   36                   *				Modified grunt main loops.
   37                   *				Changed ResetHSFX to call FreeAudio.
   38                   * 11 Aug 89	-RJ		Restore I flag at end of int. driver 
   39                   *				clearing audio_interruptus
   40                   * 1 June 89	-RJ		Added some pre-CES bullet-proofing to
   41                   *				channel number in FreeAudio and GrabAudio
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   26
                        6502:src/hsfx.src               07:11:20  

   42                   * 1 June 89	SHL		Moved hsfx_driver core to hsfx_driver
   43                   *				called by both hsfx_driver and hmusic_driver
   44                   *				allowing SEPARATE_HMUSIC_HSFX to work
   45                   * 31 May 89	SHL		Added the required 5th element to Cha
   46                   * 13 May 89	-RJ		Added SEPARATE_HMUSIC_HSFX support
   47                   * 11 May 89	-RJ		FrameClock and FramePreload are chang
   48                   *				AudioClock and AudioPreload.  These are now
   49                   *				set using AUDIO_CLOCK_MASK and AUDIO_PRELOAD.
   50                   *				Removed HFIX1 references.  Made InitHSFX
   51                   *				always disable interrupts
   52                   * 1 May 89	-RJ		Changed all IntTable references to sys
   53                   *				which is defined now in the sys.mac file
   54                   * 30 Apr 89	-RJ		Got rid of old CES_SLOWCLOCK stuff
   55                   * 5 Apr 89	-RJ		Added audio_interruptus.  The hsfx dri
   56                   *				interrupt code now clears interrupt disable
   57                   *				as soon as its taken steps to prevent
   58                   *				reentrancy, thereby allowing other more
   59                   *				important interrupts to be processed.
   60                   * 22 Mar 89	-RJ		Moved declaration of audio_ptr into t
   61                   *				Changed order of steps in ResetHSFX.
   62                   *				Added cancellation of launch_channel in Reset.
   63                   *				Tightened code in calc_next_audio
   64                   * 21 Mar 89	-RJ		Changed name of effect_in_use to Chan
   65                   *				By request, changed name of temp to hsfx_temp.
   66                   *				Tightened up loop in ResetHSFX
   67                   * 20 Mar 89	-RJ		Merged RG's changes into this file, a
   68                   *				many comments, general cleanup
   69                   * 19 Mar 89	-RJ		Added many calls to HFIX1 macros as n
   70                   * Feb 89	RG		Tightened code, folded music into HSFX
   71                   * 4 Jan 89	=RJ Mical=	Stripped out sample program, cha
   72                   *				to match harddefs.i
   73                   *				Added AUDIO_TIMER definition and more
   74                   * Late 88	RG Goudy	Created this file!
   75                   *
   76                   * ====================================================
   77                   
   78                   
   79                   
   80                   
   81      TRUE            #IFNDEF START_DISABLE
   82                   
   83      0001         AUDIO_DISABLE	.EQU	1
   84                   ; Define AUDIO_DISABLE to disable audio interrupts *on
   85                   ; routines.  Undefine AUDIO_DISABLE to lock out *all* 
   86                   
   87                   	#MACRO START_DISABLE
   88 MACRO             		#IFDEF AUDIO_DISABLE
   89 MACRO             		 INC	audio_lockout
   90 MACRO             		#ELSE
   91 MACRO             		 PHP
   92 MACRO             		 SEI
   93 MACRO             		#ENDIF
   94                   	#ENDM	; START_DISABLE
   95                   
   96                   	#MACRO END_DISABLE
   97 MACRO             		#IFDEF AUDIO_DISABLE
   98 MACRO             		 DEC	audio_lockout
   99 MACRO             		#ELSE
  100 MACRO             		 PLP
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   27
                        6502:src/hsfx.src               07:11:20  

  101 MACRO             		#ENDIF
  102                   	#ENDM	; END_DISABLE
  103                   
  104                   
  105                      #ENDIF	; OF IFNDEF START_DISABLE
  106                   
  107                   
  108                   
  109                   		BEGIN_ZPAGE
    1      0B95       + TEMPORG	  .= *
    2 0B95:           + 	  .ORG NEXTZPG
    3                 + 
  110 001E:             audio_ptr	.DS 2		; grab some zero page variables
  111 0020:             hsfx_temp	.DS 1
  112                   		END_ZPAGE
    1      0021       + NEXTZPG	  .= *
    2      FALSE        	  #IF NEXTZPG > $0100
    4                 + 	  #ENDIF
    5 0021:           + 	  .ORG TEMPORG
    6                 + 
  113                   
  114                   
  115                   
  116                   * If HMUSIC is out there and if the programmer hasn't 
  117                   * SEPARATE_HMUSIC_HSFX then define hsfxSysCancel, whic
  118                   * little more than a subroutine call for HMUSIC
  119      TRUE         	#IFDEF HANDYMUSIC
  120      TRUE         	  #IFNDEF SEPARATE_HMUSIC_HSFX
  121      0001         hsfxSysCancel	.EQU	1
  122                   	  #ENDIF
  123                   	#ENDIF
  124                   
  125                   
  126                   
  127 0B95:             InitHSFX
  128                   * ====================================================
  129                   * Sound Effects Driver Initialization
  130                   * You should call this routine only once, during the i
  131                   * portion of your code
  132                   * Warning from RG:  if you muck with it and it doesn't
  133                   * (yes, straight to bed with no dinner).
  134                   *
  135                   * If you are using the Handy music driver you are supp
  136                   * the audio system by calling InitMusic.  InitMusic ca
  137                   * aren't required to call both.
  138                   
  139                   
  140      FALSE         #IFNDEF hsfxSysCancel
  148                    #ENDIF
  149                   
  150 0B95:A9 9E        	  lda #AUDIO_CLOCK_MASK+ENABLE_INT+ENABLE_RELOAD+ENAB
  151 0B97:A0 40        	  ldy #AUDIO_PRELOAD
  152 0B99:8D 19 FD     	  sta TIMER0+{AUDIO_TIMER*4}+TIM_CONTROLA
  153 0B9C:8C 18 FD     	  sty TIMER0+{AUDIO_TIMER*4}+TIM_BACKUP
  154                   
  155      FALSE         #IFNDEF hsfxSysCancel
  157                    #ENDIF
  158                   
  159                   * ... and intentionally fall into ResetHSFX
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   28
                        6502:src/hsfx.src               07:11:20  

  160                   
  161                   
  162                   
  163 0B9F:             ResetHSFX
  164                   * ====================================================
  165                   * This routine turns off the audio channels and clears
  166                   * usage of all the channels.  You can call this routin
  167                   * whenever you like, as often as you like.
  168                   
  169                   * Warning:  this code is fallen into from above
  170                   
  171 0B9F:08           	 php
  172 0BA0:78           	  sei
  173                   
  174 0BA1:A2 **        	  ldx #HSFXVarEnd-HSFXVarStart	; clear all HSFX varia
  175 0BA3:9E ** **     .00	    stz HSFXVarStart-1,x
  176 0BA6:CA           	    dex
  177 0BA7:D0 FA        	   bne .00
  178                   
  179 0BA9:A2 03        	  ldx #HSFX_CHANNELCOUNT-1	; free each audio channel
  180 0BAB:20 ** **     .10	    jsr FreeAudio
  181 0BAE:CA           	    dex
  182 0BAF:10 FA        	   bpl .10
  183                   
  184 0BB1:28           	 plp
  185 0BB2:60           	rts
  186                   
  187                   
  188 0BB3:             StartHSFX
  189                   * ====================================================
  190                   * The StartHSFX routine is called to add a sound effec
  191                   * Call with the address of your HSFX table in A,X (low
  192                   * with the priority of this sound effect in Y.
  193                   *
  194                   * If your sound effect is successfully added, carry is
  195                   * has the audio channel number of your sound effect.  
  196                   * couldn't be added, carry is set on return and X will
  197                   * Channel 4 is a mock HSFX channel, the priority of wh
  198                   * ChannelInUse) will always be zero and therefore will
  199                   * priority of a sound effect submitted to StartHSFX.  
  200                   * convenience of being able to check at a later time w
  201                   * sound effect is still active without requiring the o
  202                   * whether the call to StartHSFX succeeded or failed in
  203                   *
  204                   * On return:
  205                   *    carry clear = success
  206                   *      carry set = failure
  207                   *              X = channel number (0 - 3) of sound eff
  208                   
  209                   
  210                   	START_DISABLE	; disable sound IRQs
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0BB3:EE ** **   + 		 INC	audio_lockout
    3                   		#ELSE
    6                 + 		#ENDIF
    7                 + 
  211                   
  212 0BB6:85 1E        	sta audio_ptr		; hsfx table address lsb
  213 0BB8:86 1F        	stx audio_ptr+1		; hsfx table address msb
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   29
                        6502:src/hsfx.src               07:11:20  

  214                   
  215 0BBA:20 ** **     	jsr find_lesser_channel
  216 0BBD:B0 **        	bcs .00
  217                   
  218 0BBF:A2 04        	ldx #HSFX_CHANNELCOUNT	; Return mock channel number
  219                   
  220                   	END_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0BC1:CE ** **   + 		 DEC	audio_lockout
    3                   		#ELSE
    5                 + 		#ENDIF
    6                 + 
  221                   
  222 0BC4:38           	sec			; Return result:  no channel available
  223 0BC5:60           	rts
  224                   
  225                   
  226 0BC6:9D ** **     .00	sta ChannelInUse,x	; Store priority of this channe
  227 0BC9:A5 1E        	lda audio_ptr
  228 0BCB:9D ** **     	sta hsfx_basel,x
  229 0BCE:A5 1F        	lda audio_ptr+1
  230 0BD0:9D ** **     	sta hsfx_baseh,x
  231                   
  232 0BD3:8A           	txa			; Clear accumulators & interpolators
  233 0BD4:18           	clc
  234 0BD5:69 3C        	adc #HSFX_CHANNELCOUNT*{HSFX_REGSIZE*HSFX_REGCOUNT-1}
  235 0BD7:38           	sec
  236 0BD8:AA           .11	  tax
  237 0BD9:9E ** **     	  stz freql,x
  238 0BDC:E9 04        	  sbc #HSFX_CHANNELCOUNT
  239 0BDE:B0 F8        	 bcs .11		; X comes out of loop with correct index
  240                   
  241 0BE0:20 ** **     	jsr update_frame	; read in first key frame
  242 0BE3:20 ** **     	jsr calc_next_audio	; set up for first hardware load
  243                   
  244 0BE6:A9 80        	lda #$80		; set signal to start sound effect
  245 0BE8:9D ** **     	sta launch_channel,x
  246                   
  247                   	END_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0BEB:CE ** **   + 		 DEC	audio_lockout
    3                   		#ELSE
    5                 + 		#ENDIF
    6                 + 
  248                   
  249 0BEE:18           	clc			; tell caller that channel was gotten
  250 0BEF:60           	rts
  251                   
  252                   
  253                   
  254 0BF0:             StopHSFX
  255                   * ====================================================
  256                   * This routine is called to remove a sound effect from
  257                   * Call with the priority of the sound effect to stop i
  258                   *
  259                   * On return:
  260                   *    A, X and Y are trashed
  261                   *    carry clear = a sound effect with this priority w
  262                   *    carry set = no sound effect with this priority wa
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   30
                        6502:src/hsfx.src               07:11:20  

  263                   
  264                   
  265                   	START_DISABLE		; kill sound IRQs
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0BF0:EE ** **   + 		 INC	audio_lockout
    3                   		#ELSE
    6                 + 		#ENDIF
    7                 + 
  266                   
  267 0BF3:98           	tya
  268 0BF4:A2 04        	ldx #HSFX_CHANNELCOUNT
  269                   
  270 0BF6:CA           .11	  dex
  271 0BF7:30 **        	  bmi .20
  272 0BF9:DD ** **     	  cmp ChannelInUse,x
  273 0BFC:D0 F8        	 bne .11
  274                   
  275 0BFE:20 ** **     	jsr freeChannelX	 ; found channel with desired priori
  276                   
  277                   	END_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0C01:CE ** **   + 		 DEC	audio_lockout
    3                   		#ELSE
    5                 + 		#ENDIF
    6                 + 
  278 0C04:18           	clc
  279 0C05:60           	rts
  280                   
  281                   .20	END_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0C06:CE ** **   + 		 DEC	audio_lockout
    3                   		#ELSE
    5                 + 		#ENDIF
    6                 + 
  282 0C09:38           	sec
  283 0C0A:60           	rts
  284                   
  285                   
  286                   
  287 0C0B:             FreeAudio
  288                   * ====================================================
  289                   * This routine is called to free an audio channel that
  290                   * using AllocAudio or GrabAudio.  It's used also by th
  291                   * free up the channel at the end of a note.
  292                   *
  293                   * Call with the channel number that you want to free i
  294                   *
  295                   * On return:
  296                   *    carry wil be clear, which equals success
  297                   
  298      FALSE         #IFDEF SOUND_DEBUG
  303                    #ENDIF
  304                   
  305                   
  306                   	START_DISABLE	; kill sound IRQs
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0C0B:EE ** **   + 		 INC	audio_lockout
    3                   		#ELSE
    6                 + 		#ENDIF
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   31
                        6502:src/hsfx.src               07:11:20  

    7                 + 
  307                   
  308 0C0E:20 ** **     	jsr freeChannelX
  309                   
  310                   	END_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0C11:CE ** **   + 		 DEC	audio_lockout
    3                   		#ELSE
    5                 + 		#ENDIF
    6                 + 
  311 0C14:18           	clc
  312 0C15:60           	rts
  313                   
  314                   
  315                   
  316      FALSE         #IFDEF GRABAUDIO_USER
  367                    #ENDIF ; of #IFDEF GRABAUDIO_USER
  368                   
  369                   
  370                   
  371                   * find_lesser_channel and freeChannelX don't affect th
  372                   
  373                   
  374 0C16:             find_lesser_channel
  375                   * ====================================================
  376                   * The find_lesser_channel routine feels through the pr
  377                   * channels, looking for one that's the most less than 
  378                   * priority of interest.
  379                   *
  380                   * On entry:  the priority to beat is in Y
  381                   * On exit:  The lowest priority channel number is retu
  382                   *	of the channel is less than or equal to request	then
  383                   
  384      TRUE          #IF HSFX_CHANNELCOUNT>1
  385                   
  386 0C16:5A           	phy
  387                   
  388 0C17:A2 03        	ldx #HSFX_CHANNELCOUNT-1
  389 0C19:A0 02        	ldy #HSFX_CHANNELCOUNT-2
  390 0C1B:BD ** **     .40	  lda ChannelInUse,x
  391 0C1E:D9 ** **     	  cmp ChannelInUse,y
  392 0C21:90 **        	  blt .41		; Branch if x-priority is less than y-prio
  393 0C23:98           	  tya		; else copy y to x
  394 0C24:AA           	  tax
  395 0C25:88           .41	  dey
  396 0C26:10 F3        	 bpl .40
  397                   
  398 0C28:68           	pla	
  399                   
  400                    #ELSE
  405                    #ENDIF
  406                   
  407 0C29:DD ** **     	cmp ChannelInUse,x	; compare with lowest priority cha
  408                   
  409 0C2C:60           	rts
  410                   
  411                   
  412                   
  413 0C2D:             freeChannelX
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   32
                        6502:src/hsfx.src               07:11:20  

  414                   * ====================================================
  415                   * Here, X has the index of the channel to be freed
  416 0C2D:A9 00        	lda #0
  417                   
  418 0C2F:             killChannelX
  419 0C2F:9D ** **     	sta ChannelInUse,x		; either free or grab channel
  420                   
  421 0C32:9E ** **     	stz launch_channel,x		; make sure we zero launch flag
  422 0C35:BC ** **     	ldy audio_offsets,x
  423 0C38:B9 25 FD     	lda AUDIO0+AUD_CONTROL,y
  424 0C3B:29 20        	and #ENABLE_INTEGRATE
  425 0C3D:99 25 FD     	sta AUDIO0+AUD_CONTROL,y	; kill channel
  426 0C40:D0 **        	bne .90
  427 0C42:99 22 FD     	sta AUDIO0+AUD_OUTPUT,y	; reset volume (DC bias) if n
  428 0C45:60           .90	rts
  429                   
  430                   
  431                   
  432                   
  433                   
  434                   
  435                   
  436                   * ====================================================
  437                   * ====                    ============================
  438                   * ====   Interrupt Code   ============================
  439                   * ====                    ============================
  440                   * ====================================================
  441                   
  442                   
  443      FALSE         #IFNDEF hsfxSysCancel
  481                    #ENDIF ; of IFNDEF hsfxSysCancel
  482                   
  483                   
  484                   
  485                   
  486                   
  487 0C46:             hsfx_driver_grunt
  488                   * ====================================================
  489                   * Here's the actual HSFX interrupt code
  490                   * The audio driver turns itself into "low-priority" in
  491                   * enabling interrupts as soon as it has protected itse
  492                   * reentered.  This will allow more important (especial
  493                   * interrupt routines to wrest control away from audio 
  494                   
  495      FALSE         #IFDEF USER_HSFX
  497                    #ENDIF
  498                   
  499                   * Lay our hands on the hardware of each active channel
  500                   * (although note that this loop won't actually start t
  501                   * for the channel if the timer isn't already running. 
  502                   * in the launch_channel loop below).
  503                   
  504 0C46:A2 03        	ldx #HSFX_CHANNELCOUNT-1
  505                   
  506 0C48:BC ** **     .00	  ldy audio_offsets,x
  507 0C4B:BD ** **     	  lda ChannelInUse,x	; Is this an active channel?
  508 0C4E:D0 **        	  bne .02
  509 0C50:B9 22 FD     	  lda AUDIO0+AUD_OUTPUT,y	; not active, ramp volume t
  510 0C53:F0 **        	  beq .01
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   33
                        6502:src/hsfx.src               07:11:20  

  511 0C55:10 **        	  bpl .03
  512 0C57:1A           	  inc a
  513 0C58:1A           	  inc a
  514 0C59:3A           .03	  dec a
  515 0C5A:99 22 FD     	  sta AUDIO0+AUD_OUTPUT,y
  516 0C5D:80 **        	  bra .01
  517                   
  518 0C5F:C9 FF        .02	  cmp #HSFX_NOCHANNEL	; does someone else own this
  519 0C61:F0 **        	  beq .01
  520                   
  521 0C63:BD ** **     .10	  lda volumeh,x
  522 0C66:99 20 FD     	  sta AUDIO0+AUD_VOLCNTRL,y	; Volume
  523                   
  524 0C69:BD ** **     	  lda preload_temp,x
  525 0C6C:99 24 FD     	  sta AUDIO0+AUD_BACKUP,y	; Frequency lsb
  526                   
  527 0C6F:BD ** **     	  lda data_temp,x
  528 0C72:99 21 FD     	  sta AUDIO0+AUD_FEEDBACK,y	; Update feedback
  529                   
  530 0C75:BD ** **     	  lda flagsl,x
  531 0C78:29 04        	  and #SHIFT_ALWAYS		; Store shifter value always?
  532 0C7A:D0 **        	  bne .20			; Branch if yes
  533 0C7C:1E ** **     	  asl shift_flag,x		; Store new shifter this time onl
  534 0C7F:90 **        	  bcc .22			; Branch if no
  535                   
  536 0C81:B9 27 FD     .20	  lda AUDIO0+AUD_OTHER,y	; Do masking as needed
  537 0C84:29 0F        	  and #$f
  538 0C86:1D ** **     	  ora shift_temp,x
  539 0C89:99 27 FD     	  sta AUDIO0+AUD_OTHER,y
  540                   
  541 0C8C:BD ** **     	  lda shiftl,x
  542 0C8F:99 23 FD     	  sta AUDIO0+AUD_SHIFT,y
  543                   
  544 0C92:B9 25 FD     .22	  lda AUDIO0+AUD_CONTROL,y	; patch in new control 
  545 0C95:29 58        	  and #ENABLE_COUNT+ENABLE_RELOAD+RESET_DONE
  546 0C97:1D ** **     	  ora clock_temp,x
  547 0C9A:99 25 FD     	  sta AUDIO0+AUD_CONTROL,y
  548                   
  549 0C9D:CA           .01	  dex
  550 0C9E:10 A8        	 bpl .00
  551                   
  552                   ;	jmp launch_channels		; fall through
  553                   
  554                   
  555                   * If two notes start with the same frequency they shou
  556                   * at very close to the same time to prevent them from 
  557                   * 180 degrees out of phase with each other.  Being out
  558                   * them to cancel each other out; we know this from exp
  559                   * notes should be launched as close together as possib
  560                   * avoid the out-of-phase cancellation problem.  This l
  561                   * and the overhead of the additional loop is well wort
  562                   
  563 0CA0:             launch_channels
  564 0CA0:78           	sei
  565 0CA1:A2 03        	ldx #HSFX_CHANNELCOUNT-1
  566                   
  567 0CA3:             launch_next_channel
  568 0CA3:BD ** **     .00	  lda launch_channel,x		; Launch this channel?
  569 0CA6:F0 **        	  beq .01			; Branch if not
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   34
                        6502:src/hsfx.src               07:11:20  

  570 0CA8:9E ** **     	  stz launch_channel,x		; finished launching
  571                   
  572 0CAB:BC ** **     	  ldy audio_offsets,x
  573 0CAE:B9 24 FD     	  lda AUDIO0+AUD_BACKUP,y	; Frequency lsb
  574 0CB1:99 26 FD     	  sta AUDIO0+AUD_COUNTER,y	; Copy prevents phase erro
  575                   
  576 0CB4:B9 25 FD     	  lda AUDIO0+AUD_CONTROL,y	; Start audio timer
  577 0CB7:09 18        	  ora #ENABLE_RELOAD+ENABLE_COUNT
  578 0CB9:99 25 FD     	  sta AUDIO0+AUD_CONTROL,y
  579                   
  580 0CBC:CA           .01	  dex
  581 0CBD:10 E4        	 bpl .00
  582                   
  583                   * Advance the HSFX values of each active channel
  584                   
  585 0CBF:             advance_channels
  586 0CBF:58           	cli
  587 0CC0:A2 03        	ldx #HSFX_CHANNELCOUNT-1
  588                   
  589 0CC2:BD ** **     .00	  lda ChannelInUse,x	; Is this an active channel?
  590 0CC5:F0 **        	  beq .01		; skip if not
  591 0CC7:C9 FF        	  cmp #HSFX_NOCHANNEL	; do we own this channel?
  592 0CC9:F0 **        	  beq .01
  593 0CCB:BD ** **     	  lda current_framel,x	; Do we match next key frame e
  594 0CCE:DD ** **     	  cmp next_keyframel,x
  595 0CD1:D0 **        	  bne .10		; ... no, do interpolation only
  596 0CD3:BD ** **     	  lda current_frameh,x
  597 0CD6:DD ** **     	  cmp next_keyframeh,x
  598 0CD9:D0 **        	  bne .10		; ... no, do interpolation only
  599 0CDB:20 ** **     	  jsr update_frame	; It's time to do something differ
  600 0CDE:80 **        	  bra .20		; First time, don't interpolate
  601                   
  602                   * Add the interpolators to the accumulators
  603                   
  604 0CE0:DA           .10	   phx
  605                   
  606 0CE1:18           .11	    clc
  607 0CE2:BD ** **     	    lda freq_interpl,x
  608 0CE5:7D ** **     	    adc freql,x
  609 0CE8:9D ** **     	    sta freql,x
  610 0CEB:BD ** **     	    lda freq_interph,x
  611 0CEE:7D ** **     	    adc freqh,x
  612 0CF1:9D ** **     	    sta freqh,x
  613                   
  614                   	    ; Bump x to next accumulator-interpolator pair
  615                   
  616      TRUE          #IF HSFX_REGSIZE*HSFX_CHANNELCOUNT > 4
  617 0CF4:8A           	    txa
  618 0CF5:18           	    clc
  619 0CF6:69 08        	    adc #HSFX_REGSIZE*HSFX_CHANNELCOUNT
  620 0CF8:AA           	    tax
  621                    #ELSE
  625                    #ENDIF
  626                   
  627                   ; Has index overshot into accumulator-interpolator pai
  628 0CF9:E0 20        	    cpx #HSFX_CHANNELCOUNT*HSFX_REGSIZE*HSFX_ACCUMCOU
  629 0CFB:90 E4        	    bcc .11		; Branch if not
  630 0CFD:FA           	   plx
  631                   
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   35
                        6502:src/hsfx.src               07:11:20  

  632 0CFE:20 ** **     .20	  jsr calc_next_audio	; Prepare data for hardware 
  633                   
  634 0D01:CA           .01	  dex
  635 0D02:10 BE        	 bpl .00
  636                   
  637 0D04:60           	rts
  638                   
  639                   
  640                   
  641                   
  642 0D05:             update_frame
  643                   * ====================================================
  644                   * Updates an HSFX channel's arrays based on the keyfra
  645                   * pointed to by hsfx_basel,h.
  646                   *
  647                   * On entry:
  648                   *   x = HSFX channel number
  649                   *   hsfx_basel,x points to low flag byte of current fr
  650                   *
  651                   * On exit:
  652                   *   accumulators & interpolators pre-loaded
  653                   *   next_keyframel,h set to frame number for next keyf
  654                   *   hsfx_basel,x points to low flag byte of next frame
  655                   *   This routine trashes A and Y, leaves X intact
  656                   
  657 0D05:BD ** **     	lda hsfx_basel,x	; Set up indirect pointer
  658 0D08:85 1E        	sta audio_ptr
  659 0D0A:BD ** **     	lda hsfx_baseh,x
  660 0D0D:85 1F        	sta audio_ptr+1
  661 0D0F:             loop_frame
  662 0D0F:A0 01        	  ldy #1
  663                   
  664 0D11:B2 1E        	  lda (audio_ptr)	; this is where current_frame gets 
  665 0D13:9D ** **     	  sta current_framel,x	; when a sound is started.
  666 0D16:B1 1E        	  lda (audio_ptr),y
  667 0D18:9D ** **     	  sta current_frameh,x
  668                   
  669 0D1B:C8           	  iny
  670 0D1C:B1 1E        	  lda (audio_ptr),y	; Find out what to do this time
  671 0D1E:9D ** **     	  sta flagsl,x
  672 0D21:C8           	  iny
  673 0D22:B1 1E        	  lda (audio_ptr),y
  674 0D24:9D ** **     	  sta flagsh,x
  675 0D27:C8           	  iny
  676                   
  677 0D28:0E ** **     	  asl top_of_loop0	; Returning to the top of a loop?
  678 0D2B:B0 **        	  bcs stuff0		; Yes, don't reload count byte
  679 0D2D:BD ** **     	  lda flagsh,x
  680 0D30:29 40        	  and #>NEXT0		; At the bottom of an inner loop?
  681 0D32:F0 **        	  beq next0_done	; Branch if not
  682 0D34:BD ** **     	  lda loop_count0,x	; Infinite loop?
  683 0D37:F0 **        	  beq infinite0		; Yes, don't count
  684 0D39:DE ** **     	  dec loop_count0,x	; Not infinite, so are we done?
  685 0D3C:F0 **        	  beq next0_done	; Branch if yes.
  686 0D3E:             infinite0
  687 0D3E:BD ** **     	  lda loop_adrl0,x	; Reload pointer to top of loop
  688 0D41:85 1E        	  sta audio_ptr
  689 0D43:BD ** **     	  lda loop_adrh0,x
  690 0D46:85 1F        	  sta audio_ptr+1
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   36
                        6502:src/hsfx.src               07:11:20  

  691 0D48:A9 80        	  lda #$80		; Set 'skip loading count' flag
  692 0D4A:8D ** **     	  sta top_of_loop0
  693 0D4D:80 C0        	 bra loop_frame		; Go do top of loop
  694                   
  695                   
  696 0D4F:             next0_done
  697                   
  698 0D4F:BD ** **     	  lda flagsh,x
  699 0D52:29 80        	  and #>LOOP0		; Starting an inner loop?
  700 0D54:F0 **        	  beq no_loop0		; Branch if not
  701 0D56:A5 1E        	  lda audio_ptr		; else save this table pointer value
  702 0D58:9D ** **     	  sta loop_adrl0,x
  703 0D5B:A5 1F        	  lda audio_ptr+1
  704 0D5D:9D ** **     	  sta loop_adrh0,x
  705 0D60:B1 1E        	  lda (audio_ptr),y	; Get # of loops to do
  706 0D62:9D ** **     	  sta loop_count0,x
  707 0D65:             stuff0
  708 0D65:C8           	  iny
  709 0D66:             no_loop0
  710                   
  711 0D66:0E ** **     	  asl top_of_loop1	; Returning to the top of a loop?
  712 0D69:B0 **        	  bcs stuff1		; Yes, don't reload count byte
  713 0D6B:BD ** **     	  lda flagsh,x
  714 0D6E:29 10        	  and #>NEXT1		; At the bottom of an outer loop?
  715 0D70:F0 **        	  beq next1_done	; Branch if not
  716 0D72:BD ** **     	  lda loop_count1,x	; Infinite loop?
  717 0D75:F0 **        	  beq infinite1		; Yes, so don't count
  718 0D77:DE ** **     	  dec loop_count1,x	; Not infinite, so are we done?
  719 0D7A:F0 **        	  beq next1_done	; Branch if yes
  720 0D7C:             infinite1
  721 0D7C:BD ** **     	  lda loop_adrl1,x	; Reload pointer to top of loop
  722 0D7F:85 1E        	  sta audio_ptr
  723 0D81:BD ** **     	  lda loop_adrh1,x
  724 0D84:85 1F        	  sta audio_ptr+1
  725 0D86:A9 80        	  lda #$80		; Set 'skip loading count' flag
  726 0D88:8D ** **     	  sta top_of_loop1
  727 0D8B:4C 0F 0D     	 jmp loop_frame		; Go do top of loop
  728                   
  729                   
  730 0D8E:             next1_done
  731 0D8E:BD ** **     	lda flagsh,x
  732 0D91:29 20        	and #>LOOP1		; Are we starting an outer loop?
  733 0D93:F0 **        	beq no_loop1		; Branch if not
  734 0D95:A5 1E        	lda audio_ptr		; Save this table pointer value
  735 0D97:9D ** **     	sta loop_adrl1,x
  736 0D9A:A5 1F        	lda audio_ptr+1
  737 0D9C:9D ** **     	sta loop_adrh1,x
  738 0D9F:B1 1E        	lda (audio_ptr),y	; Get # of loops to do
  739 0DA1:9D ** **     	sta loop_count1,x
  740 0DA4:             stuff1
  741 0DA4:C8           	iny
  742                   
  743 0DA5:             no_loop1		; now load appropriate accumulator/interpola
  744                   
  745                   			; The following piece of code takes the center 8 bi
  746                   			; from the middle of flagsl,h and puts them in orde
  747                   			; into hsfx_temp
  748 0DA5:BD ** **     	lda flagsl,x	; Get a temporary copy of this channel's
  749 0DA8:0A           	asl a
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   37
                        6502:src/hsfx.src               07:11:20  

  750 0DA9:5D ** **     	eor flagsh,x	; smush together upper flagsl bits + low
  751 0DAC:29 E0        	and #$e0
  752 0DAE:5D ** **     	eor flagsh,x
  753 0DB1:2A           	rol a		; bring flagsh bits to the top
  754 0DB2:2A           	rol a
  755 0DB3:2A           	rol a
  756 0DB4:2A           	rol a
  757 0DB5:85 20        	sta hsfx_temp
  758                   
  759 0DB7:DA           	 phx		; Stash the channel number
  760                   
  761                   			; NOTE: the BPL at top of the loop depends on the
  762                   			; ROL instruction above, and the ASL below
  763 0DB8:10 **        .22	    bpl .33		; copy key frame data for each flag b
  764 0DBA:B1 1E        	    lda (audio_ptr),y	; get new value
  765 0DBC:9D ** **     	    sta freql,x		; this presumes specific array order
  766 0DBF:C8           	    iny
  767 0DC0:B1 1E        	    lda (audio_ptr),y
  768 0DC2:9D ** **     	    sta freqh,x
  769 0DC5:C8           	    iny
  770 0DC6:             .33
  771      TRUE          #IF HSFX_REGSIZE*HSFX_CHANNELCOUNT > 4
  772 0DC6:18           	    clc
  773 0DC7:8A           	    txa	 ; Offset X to next accumulator/interpolator 
  774 0DC8:69 08        	    adc #HSFX_REGSIZE*HSFX_CHANNELCOUNT
  775 0DCA:AA           	    tax
  776                    #ELSE
  780                    #ENDIF
  781 0DCB:06 20        	    asl hsfx_temp	; stop when no more flags are set
  782 0DCD:D0 E9        	   bne .22
  783                   
  784 0DCF:FA           	 plx	; Restore the channel number
  785                   
  786 0DD0:BD ** **     	lda flagsh,x
  787 0DD3:29 04        	and #>SHIFT_ACCUM	; New absolute_shifter?
  788 0DD5:F0 **        	beq .55		;no
  789 0DD7:A9 80        	lda #$80
  790 0DD9:9D ** **     .55	sta shift_flag,x	; Set 'store once' flag
  791                   
  792 0DDC:BD ** **     	lda flagsl,x
  793 0DDF:29 08        	and #INTEGRATE		; This is a 'force on/off' flag
  794 0DE1:0A           	asl a			; Move into pos for hardware register
  795 0DE2:0A           	asl a
  796 0DE3:9D ** **     	sta integrate,x
  797                   
  798 0DE6:BD ** **     	lda flagsl,x
  799 0DE9:29 01        	and #END_OF_EFFECT	; Are we at end of this effect?
  800 0DEB:D0 **        	bne end_of_effect
  801                   
  802                   	; Advance hsfx_basel,h to point to next key frame ent
  803 0DED:98           	tya
  804 0DEE:18           	clc
  805 0DEF:65 1E        	adc audio_ptr
  806 0DF1:9D ** **     	sta hsfx_basel,x
  807 0DF4:A9 00        	lda #0
  808 0DF6:65 1F        	adc audio_ptr+1
  809 0DF8:9D ** **     	sta hsfx_baseh,x
  810                   
  811 0DFB:B1 1E        	lda (audio_ptr),y	;get next key frames' frame #
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   38
                        6502:src/hsfx.src               07:11:20  

  812 0DFD:9D ** **     	sta next_keyframel,x
  813 0E00:C8           	iny
  814 0E01:B1 1E        	lda (audio_ptr),y
  815 0E03:9D ** **     	sta next_keyframeh,x
  816                   
  817 0E06:60           	rts			;end of key frame entry
  818                   
  819                   
  820 0E07:             end_of_effect
  821 0E07:4C 2D 0C     	jmp freeChannelX
  822                   
  823                   
  824                   
  825                   
  826 0E0A:             calc_next_audio
  827                   * ====================================================
  828                   * This routuine converts the channel's accumulators in
  829                   * designed for easy hardware loading.  This is done be
  830                   * audio frame, so that at the start of the audio frame
  831                   * values can be picked up and jammed into the audio re
  832                   * delay, thereby creating purer sounds.
  833                   *
  834                   * This routine trashes A and Y, leaves X intact
  835                   
  836                   
  837                   * Select the clock by normalizing the frequency accumu
  838                   * (the algorithm and proof is actually a rather hairy 
  839 0E0A:A0 07        	ldy #7
  840 0E0C:BD ** **     	lda freql,x
  841 0E0F:85 20        	sta hsfx_temp
  842 0E11:BD ** **     	lda freqh,x
  843                   
  844 0E14:06 20        .00	  asl hsfx_temp
  845 0E16:2A           	  rol a
  846 0E17:88           	  dey
  847 0E18:B0 **        	  bcs .01
  848 0E1A:D0 F8        	 bne .00
  849                   
  850 0E1C:6A           .01	ror a
  851                   
  852 0E1D:             end_freq
  853 0E1D:9D ** **     	sta preload_temp,x
  854 0E20:98           	tya
  855 0E21:9D ** **     	sta clock_temp,x
  856                   
  857                   
  858                   * Preset the 12-bit shifter values
  859 0E24:BD ** **     	lda shifth,x
  860 0E27:0A           	asl a
  861 0E28:0A           	asl a
  862 0E29:0A           	asl a
  863 0E2A:0A           	asl a
  864 0E2B:9D ** **     	sta shift_temp,x
  865                   
  866                   * Preset the lower 8 feedback enables
  867 0E2E:BD ** **     	lda feedbackl,x
  868 0E31:0A           	asl
  869 0E32:85 20        	sta hsfx_temp
  870 0E34:BD ** **     	lda feedbackh,x
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   39
                        6502:src/hsfx.src               07:11:20  

  871 0E37:2A           	rol a
  872 0E38:06 20        	asl hsfx_temp
  873 0E3A:2A           	rol a
  874 0E3B:06 20        	asl hsfx_temp
  875 0E3D:2A           	rol a
  876 0E3E:06 20        	asl hsfx_temp
  877 0E40:2A           	rol a
  878 0E41:C9 80        	cmp #$80		; sec if high bit set
  879 0E43:5D ** **     	eor feedbackh,x		; merge in top two bits of feedbackh
  880 0E46:29 3F        	and #$3f
  881 0E48:5D ** **     	eor feedbackh,x
  882 0E4B:9D ** **     	sta data_temp,x
  883                   
  884                   * Grab the other feedback enable, or'ing it into the o
  885 0E4E:A9 00        	lda #0
  886 0E50:6A           	ror a			; bring carry into top bit
  887 0E51:1D ** **     	ora integrate,x		; OR with integration
  888 0E54:1D ** **     	ora clock_temp,x	; OR in with clock
  889 0E57:9D ** **     	sta clock_temp,x
  890                   
  891                   
  892                   * Increment this sound effect's current frame counter
  893 0E5A:FE ** **     	inc current_framel,x
  894 0E5D:D0 **        	bne .11
  895 0E5F:FE ** **     	inc current_frameh,x
  896                   
  897 0E62:60           .11	rts
  898                   
  899                   
  900                   
  901                   
  902                   
  903                   * === ================================================
  904                   * ===               ==================================
  905                   * ===      Data     ==================================
  906                   * ===               ==================================
  907                   * === ================================================
  908                   
  909                   
  910 0E63:00 08 10 18  audio_offsets	.by $00,$08,$10,$18 ; Offsets into the h
  910                   
  911                   
  912                   
 1345                   	.in 6502:src/hmusic.src
    1                   ; Tue Sep 18 17:44:11 1990
    2                   * == hmusic.src ======================================
    3                   *
    4                   * Handy Music Driver  --  Handy Software
    5                   *
    6                   * Confidential and Proprietary
    7                   * Copyright (C) 1989, Epyx, Inc.
    8                   *
    9                   * Date		Name		Description
   10                   * ---------	--------------	---------------------------
   11                   * 24-Apr-90	SHL		PlayMusic and AddMusic now kill any n
   12                   *				sound effects played by previous song
   13                   *				Minor code tightening
   14                   *				ring0_flag and ring1_flag arrays replaced by
   15                   *				ring_flag array
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   40
                        6502:src/hmusic.src             07:11:20  

   16                   * 18-Apr-90	SHL		InitHMusic now zeroes all HMUSIC vari
   17                   *				Rests now don't play a 1MHz tone
   18                   *				HMUSIC_DEFAULT_PRIORITY added to give music
   19                   *				a default priority level
   20                   * 26-Mar-90	SHL		Removed PHA, PHX from hmusic_driver
   21                   *				Changed driver exit to match new IRQ handler
   22                   * 6 Oct 89	SHL		Modified driver to catch dropped frame
   23                   * 11 Sept 89	SJ		Used song header offset definitions
   24                   *				Fixed variable initialization and moved vars
   25                   *				out of ROM
   26                   *				Kill a voice's note only if it has a defined
   27                   *				HSFX channel
   28                   *				Fixed handling of muted state
   29                   * 5 Sept 89	Stephen Jungels	Changed most public calls 
   30                   *				audio interrupts, not all interrupts
   31                   * 11 Aug 89	-RJ		Restore I flag at end of int. driver 
   32                   *				clearing audio_interruptus
   33                   * 13 Jul 89	RG		Added PLP to StartVoice return
   34                   * 16 Jun 89	-RJ		Reset Mute_flag in InitHMusic
   35                   *  8 Jun 89	Greg Omi	Added Mute function
   36                   *  1 Jun 89	Steve Landrum	Changed HMUSIC call into HSF
   37                   *				to hsfx_driver_grunt
   38                   * 31 May 89	-RJ		Removed ChannelInUse from this file
   39                   *  1 May 89	-RJ		Changed all IntTable references to sy
   40                   *				which is defined now in the sys.mac file
   41                   * 18 Apr 89	-RJ		Added PlayMusic
   42                   * 17 Apr 89	-RJ		Changed AddVoice to StartVoice
   43                   * 11 Apr 89	-RJ		Tightened up ESCAPE code a bit, got r
   44                   *				infinites, using loop count of 0 for same
   45                   *  9 Apr 89	-RJ		StopMusic and StopVoice disable inter
   46                   *				Added lots more comments while bug-hunting,
   47                   *				fixed many little bugs while bug-hunting.
   48                   *				skip_inner and _outer now not arrays, and
   49                   *				renamed to did_inner and _outer.  Changed
   50                   *				StopHSFX calls to FreeAudio.  mflagsl,h
   51                   *				now not arrays.  ignore_RING now not array and
   52                   *				renamed to did_ring_end
   53                   *  7 Apr 89	-RJ		Put in a deadbolt JSR StopHSFX once a
   54                   *				supposed to end.  Solves gating overshot errors
   55                   *  6 Apr 89	-RJ		The setNewVoice routine nows clears s
   56                   *				ring arrays for that voice.  Also, both
   57                   *				ring_return levels now share common code.
   58                   *  5 Apr 89	-RJ		Added audio_interruptus, now music in
   59                   *				code safely clears interrupt disable while
   60                   *				it's working, allowing other interrupts to
   61                   *				run without risking reentrancy
   62                   *  4 Apr 89	-RJ		InitMusic zeroes out VoiceInUse array
   63                   *  3 Apr 89	-RJ		Disable interrupts before setting Use
   64                   * 25 Mar 89	-RJ		Made mods too numerous to itemize.  M
   65                   *				significant:  StartMusic calls AddVoice;
   66                   *				AddVoice expects arg of song table voice index;
   67                   *				ClearUser calls into SetUser; StopMusic calls
   68                   *				StopVoice.  Altogether about 200 bytes smaller.
   69                   * 24 Mar 89	-RJ		Made countless changes, including:  r
   70                   *				technique for calling user programs, grouping
   71                   *				all reassignments of audioptr at top of mloop
   72                   * 23 Mar 89	-RJ		Changed AddVoice routine to expect th
   73                   *				voice number in A
   74                   * 22 Mar 89	-RJ		Changed name of voice_in_use to Voice
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   41
                        6502:src/hmusic.src             07:11:20  

   75                   * 21 Mar 89	-RJ Mical-	Added comments, name changes, t
   76                   *				in preparation for first release
   77                   * 24 Jan 89	RG Goudy	Created this file!
   78                   *
   79                   *=====================================================
   80                   
   81                   
   82                   ; Changes to do:
   83                   
   84                   
   85                   ; Major Bugs
   86                   
   87                   ; hspl dumps a direct copy of the muslist into the voi
   88                   ; it also sets a field to the total number of voices a
   89                   ; need.  HSPL should sort the voice offsets so that ma
   90                   ; come first, and the field should be set to the numbe
   91                   ; which we do need to know.
   92                   
   93                   ;The ADSR keyframes for each channel don't have to eat
   94                   ;Write a build ADSR routine that fills in the necessar
   95                   ;Define the ADSR keyframe flags using HSFX.i const def
   96                   
   97                   
   98                   		BEGIN_ZPAGE
    1      0E67       + TEMPORG	  .= *
    2 0E67:           + 	  .ORG NEXTZPG
    3                 + 
   99 0021:             frequency_ptr	.DS 2
  100 0023:             duration_ptr	.DS 2
  101 0025:             voiceoffsets_ptr .DS 2
  102                   		END_ZPAGE
    1      0027       + NEXTZPG	  .= *
    2      FALSE        	  #IF NEXTZPG > $0100
    4                 + 	  #ENDIF
    5 0027:           + 	  .ORG TEMPORG
    6                 + 
  103                   
  104                   
  105                   
  106 0E67:             InitHMusic
  107                   * ====================================================
  108                   * Call this routine to initialize the music driver.  T
  109                   * initializes the HSFX driver.
  110                   
  111 0E67:08           	 php		; Disable IRQs before writing to the vector tab
  112 0E68:78           	  sei
  113                   
  114 0E69:20 95 0B     	  jsr InitHSFX				; Init sound effects driver
  115                   
  116 0E6C:A2 **        	  ldx #HMusicVarEnd-HMusicVarStart	; zero all music v
  117 0E6E:9E ** **     .10	    stz HMusicVarStart-1,x
  118 0E71:CA           	    dex
  119 0E72:D0 FA        	   bne .10
  120                   
  121 0E74:A9 **        	  lda #<hmusic_driver			; link into IRQ vector table
  122 0E76:8D ** **     	  sta sysIntTable+{AUDIO_TIMER*2}
  123 0E79:A9 **        	  lda #>hmusic_driver
  124 0E7B:8D ** **     	  sta sysIntTable+{AUDIO_TIMER*2}+1
  125                   
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   42
                        6502:src/hmusic.src             07:11:20  

  126 0E7E:28           	 plp
  127                   
  128 0E7F:60           	rts
  129                   
  130                   
  131                   
  132 0E80:             PlayMusic
  133                   * ====================================================
  134                   * The PlayMusic routine initializes the specified song
  135                   * pointers to the offsets of the first 4 voices.  Then
  136                   *
  137                   * On entry:  the address of a song table is in A,X (lo
  138                   * On exit:  X has the highest instance number assigned
  139                   *           song doesn't specify any initial voices th
  140                   
  141                   	START_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0E80:EE ** **   + 		 INC	audio_lockout
    3                   		#ELSE
    6                 + 		#ENDIF
    7                 + 
  142                   
  143 0E83:20 ** **     	jsr setUpMusicPtrs
  144                   
  145 0E86:A9 00        	lda #0			; Zero out the 4 voice indices
  146 0E88:A0 07        	ldy #SONG_STARTUPVOICE3+1
  147 0E8A:91 1E        .0a	  sta (audio_ptr),Y
  148 0E8C:88           	  dey
  149 0E8D:10 FB        	 bpl .0a
  150                   
  151 0E8F:A0 08        	ldy #SONG_MAINVOICES		; Get total number of available
  152 0E91:B1 1E        	lda (audio_ptr),Y
  153 0E93:C9 05        	cmp #HMUSIC_CHANNELCOUNT+1
  154 0E95:90 **        	blt .10
  155 0E97:A9 04        	lda #HMUSIC_CHANNELCOUNT	; Clip to maximum
  156 0E99:0A           .10	asl				; Turn this into an index for moving
  157 0E9A:3A           	dec				; that many 2-byte offsets
  158 0E9B:A8           	tay
  159 0E9C:B1 25        .20	  lda (voiceoffsets_ptr),Y	; Copy the first n voic
  160 0E9E:91 1E        	  sta (audio_ptr),Y		; table's play-voice array
  161 0EA0:88           	  dey
  162 0EA1:10 F9        	 bpl	.20
  163                   
  164 0EA3:80 **        	bra addMusicEntry	; branch into middle of AddMusic
  165                   
  166                   
  167                   
  168 0EA5:             AddMusic
  169                   * ====================================================
  170                   * The AddMusic routine performs two functions:  it ins
  171                   * song data table into the hmusic driver, and if the s
  172                   * any voices that should start playing immediately (ty
  173                   * AddMusic launches those voices.
  174                   *
  175                   * Each voice launched by AddMusic (if any) gets a uniq
  176                   * in ascending order, starting from 0.
  177                   *
  178                   * If another song is playing when this routine is call
  179                   * the previous song are completely removed.
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   43
                        6502:src/hmusic.src             07:11:20  

  180                   *
  181                   * This routine sets up the hmusic variable hmusic_base
  182                   * of the hmusic routines and interrupt code to referen
  183                   *
  184                   * On entry:  the address of a song table is in A,X (lo
  185                   * On exit:  X has the highest instance number assigned
  186                   *           song doesn't specify any initial voices th
  187                   
  188                   	START_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0EA5:EE ** **   + 		 INC	audio_lockout
    3                   		#ELSE
    6                 + 		#ENDIF
    7                 + 
  189                   
  190 0EA8:20 ** **     	jsr setUpMusicPtrs
  191                   
  192 0EAB:             addMusicEntry
  193                   
  194 0EAB:9C ** **     	stz instance		; Unique ID for referencing voices
  195                   
  196 0EAE:A9 6A        	lda #HMUSIC_DEFAULT_PRIORITY+{{HMUSIC_CHANNELCOUNT-1}
  197 0EB0:8D ** **     	sta voice0		; initialize default priorities
  198      TRUE          #IF HMUSIC_CHANNELCOUNT>1
  199 0EB3:A9 68        	lda #HMUSIC_DEFAULT_PRIORITY+{{HMUSIC_CHANNELCOUNT-2}
  200 0EB5:8D ** **     	sta voice1
  201                    #ENDIF
  202      TRUE          #IF HMUSIC_CHANNELCOUNT>2
  203 0EB8:A9 66        	lda #HMUSIC_DEFAULT_PRIORITY+{{HMUSIC_CHANNELCOUNT-3}
  204 0EBA:8D ** **     	sta voice2
  205                    #ENDIF
  206      TRUE          #IF HMUSIC_CHANNELCOUNT>3
  207 0EBD:A9 64        	lda #HMUSIC_DEFAULT_PRIORITY+{{HMUSIC_CHANNELCOUNT-4}
  208 0EBF:8D ** **     	sta voice3
  209                    #ENDIF
  210                   
  211                   	;-- For each of the initial voices (if any), load up 
  212                   	;-- hmusic voice arrays using the song table data
  213                   
  214 0EC2:A2 03        	ldx #HMUSIC_CHANNELCOUNT-1	; Voice index
  215 0EC4:A0 00        	ldy #0				; Song table index
  216                   
  217 0EC6:9E ** **     .05	  stz VoiceInUse,x		; Start by presuming no voice
  218 0EC9:9E ** **     	  stz SFX_to_cancel,x		; Wipe out MSFX calls
  219 0ECC:A9 04        	  lda #HSFX_CHANNELCOUNT	; Set this voice to no chann
  220 0ECE:9D ** **     	  sta VoiceHSFXChannel,x
  221                   
  222 0ED1:B1 1E        	  lda (audio_ptr),y		; Get offset of individual voice
  223 0ED3:C8           	  iny
  224 0ED4:9D ** **     	  sta voicedata_ptrl,x
  225 0ED7:B1 1E        	  lda (audio_ptr),y
  226 0ED9:C8           	  iny
  227 0EDA:9D ** **     	  sta voicedata_ptrh,x
  228 0EDD:1D ** **     	  ora voicedata_ptrl,x	; Was offset zero?
  229 0EE0:F0 **        	  beq .09			; If so, voice not specified
  230 0EE2:20 ** **     	  jsr setNewVoice		; else set up to launch new voice
  231                   
  232 0EE5:CA           .09	  dex		; Next voice
  233 0EE6:10 DE        	 bpl .05	; Branch if another to do
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   44
                        6502:src/hmusic.src             07:11:20  

  234                   
  235 0EE8:             voiceReturn
  236 0EE8:AE ** **     	ldx instance		; Return highest number assigned
  237 0EEB:CA           	dex
  238                   
  239                   	END_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0EEC:CE ** **   + 		 DEC	audio_lockout
    3                   		#ELSE
    5                 + 		#ENDIF
    6                 + 
  240                   
  241 0EEF:18           	clc			; Return with success
  242 0EF0:60           	rts
  243                   
  244                   
  245                   
  246                   
  247 0EF1:             setUpMusicPtrs
  248 0EF1:48           	 pha
  249 0EF2:DA           	   phx
  250 0EF3:20 ** **     	    jsr stopAllVoices
  251 0EF6:FA           	   plx
  252 0EF7:68           	 pla
  253                   
  254 0EF8:85 1E        	sta audio_ptr		; Set up pointers to copy the voice of
  255 0EFA:8D ** **     	sta hmusic_base
  256 0EFD:86 1F        	stx audio_ptr+1
  257 0EFF:8E ** **     	stx hmusic_base+1
  258                   
  259 0F02:18           	clc
  260 0F03:69 09        	adc #<SONG_VOICEFX_OFFSETS
  261 0F05:85 25        	sta voiceoffsets_ptr
  262 0F07:8A           	txa
  263 0F08:69 00        	adc #>SONG_VOICEFX_OFFSETS
  264 0F0A:85 26        	sta voiceoffsets_ptr+1
  265                   
  266 0F0C:60           	rts
  267                   
  268                   
  269                   
  270                   
  271                   
  272 0F0D:             setNewVoice
  273                   * ====================================================
  274                   * Set up to launch a new voice.
  275                   *
  276                   * On entry:
  277                   *    - voicedata_ptrl,h has the song table offset of t
  278                   *    - X has the voice channel number
  279                   * On exit:
  280                   *    - A is trashed
  281                   *    - voicedata_ptrl,h points to the actual address o
  282                   *    - Everything is set up for hmusic to launch the n
  283                   
  284                   
  285 0F0D:18           	clc		; Turn the voice data offset into a voice data p
  286 0F0E:AD ** **     	lda hmusic_base
  287 0F11:7D ** **     	adc voicedata_ptrl,x
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   45
                        6502:src/hmusic.src             07:11:20  

  288 0F14:9D ** **     	sta voicedata_ptrl,x
  289 0F17:AD ** **     	lda hmusic_base+1
  290 0F1A:7D ** **     	adc voicedata_ptrh,x
  291 0F1D:9D ** **     	sta voicedata_ptrh,x
  292                   
  293 0F20:FE ** **     	inc VoiceInUse,x	; set VoiceInUse non-zero
  294                   
  295 0F23:9E ** **     	stz voice_endframel,x	; Set voice frame to 0, frames 
  296 0F26:9E ** **     	stz voice_endframeh,x	;  Fool the hmusic driver into 
  297 0F29:A9 FF        	lda #$ff		;   it's time to load the "next" (actually 
  298 0F2B:9D ** **     	sta frames_alivel,x	;    first) data for this voice
  299 0F2E:9D ** **     	sta frames_aliveh,x
  300                   
  301 0F31:AD ** **     	lda instance		; This voice gets the next instance num
  302 0F34:9D ** **     	sta VoiceInstance,x
  303 0F37:EE ** **     	inc instance		; Bump instance number for next voice
  304                   
  305 0F3A:9E ** **     	stz ring_flag,x		; Zero out any ring state
  306                   ;	stz ring1_flag,x
  307                   
  308 0F3D:9E ** **     	stz restore_ds,x	; Zero the decay/sustain restore fla
  309                   
  310 0F40:             musicReturn			; This RTS is referenced several times
  311 0F40:60           	rts
  312                   
  313                   
  314                   
  315      FALSE         #IFDEF STARTVOICE_USER
  361                    #ENDIF ; of #IFDEF STARTVOICE_USER
  362                   
  363                   
  364                   
  365                   
  366      TRUE          #IFDEF STOPMUSIC_USER
  367 0F41:             StopMusic
  368                   * ====================================================
  369                   * StopMusic immediately stops and silences all current
  370                   * voices.
  371                   *
  372                   * After the voices are stopped, the HMUSIC voice chann
  373                   * and the HSFX audio channels used by the voices are a
  374                   *
  375                   * This routine doesn't disturb the song in the hmusic 
  376                   * this routine, subseuent calls to StartVoice can be m
  377                   *
  378                   * Note:  the effects of this routine occur immediately
  379                   * next audio interrupt.
  380                   
  381                   	 START_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
    2 0F41:EE ** **   + 		 INC	audio_lockout
    3                   		#ELSE
    6                 + 		#ENDIF
    7                 + 
  382                   
  383 0F44:20 ** **     	  jsr stopAllVoices
  384                   
  385                   	 END_DISABLE
    1      TRUE       + 		#IFDEF AUDIO_DISABLE
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   46
                        6502:src/hmusic.src             07:11:20  

    2 0F47:CE ** **   + 		 DEC	audio_lockout
    3                   		#ELSE
    5                 + 		#ENDIF
    6                 + 
  386                   
  387 0F4A:60           	rts
  388                    #ENDIF ; of #IFDEF STOPMUSIC_USER
  389                   
  390                   
  391                   
  392 0F4B:             stopAllVoices
  393                   * ====================================================
  394                   * stopAllVoices immediately stops and silences all cur
  395                   * voices.
  396                   *
  397                   * After the voices are stopped, the HMUSIC voice chann
  398                   * and the HSFX audio channels used by the voices are a
  399                   *
  400                   * This routine doesn't disturb the song in the hmusic 
  401                   * this routine, subseuent calls to StartVoice can be m
  402                   *
  403                   * Note:  the effects of this routine occur immediately
  404                   * next audio interrupt.
  405                   
  406 0F4B:A2 03        	ldx #HMUSIC_CHANNELCOUNT-1
  407 0F4D:DA           .10	   phx
  408 0F4E:20 ** **     	    jsr stopVoiceX
  409 0F51:FA           	   plx
  410 0F52:CA           	  dex
  411 0F53:10 F8        	 bpl .10
  412                   
  413 0F55:60           	rts
  414                   
  415                   
  416      FALSE         #IFDEF STOPVOICE_USER
  450                    #ENDIF ; of #IFDEF STOPVOICE_USER
  451                   
  452                   
  453                   
  454 0F56:             stopVoiceX
  455 0F56:BD ** **     	lda VoiceInUse,x	; is voice already stopped?
  456 0F59:D0 **        	bne .00
  457 0F5B:60           	rts
  458                   
  459 0F5C:9E ** **     .00	stz VoiceInUse,x	; Remove from music queue
  460                   
  461 0F5F:             muteVoiceX
  462 0F5F:BC ** **     	ldy voice_offsets,x	; Get offset to this voice's data
  463 0F62:B9 ** **     	lda voice0,y		; Get the priority of this voice
  464 0F65:1D ** **     	ora SFX_to_cancel,x	; or the sound effect being playe
  465 0F68:A8           .10	tay
  466 0F69:4C F0 0B     	jmp StopHSFX		; Tell HSFX to kill current note/MSFX
  467                   
  468                   
  469                   
  470      FALSE         #IFDEF USERCALLS_USER
  508                    #ENDIF ; of #IFDEF USERCALLS_USER
  509                   
  510                   
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   47
                        6502:src/hmusic.src             07:11:20  

  511                   
  512      TRUE          #IFDEF MUTE_USER
  513 0F6C:             Mute
  514                   * ====================================================
  515                   * Turns off music but keeps playing silently
  516                   * toggles every time called
  517                   
  518 0F6C:48           	 pha
  519 0F6D:AD ** **     	  lda Mute_flag
  520 0F70:49 FF        	  eor #$ff
  521 0F72:8D ** **     	  sta Mute_flag
  522 0F75:F0 **        	  beq .30
  523 0F77:DA           	   phx
  524 0F78:5A           	     phy
  525 0F79:A2 03        	      ldx #HMUSIC_CHANNELCOUNT-1
  526                   
  527 0F7B:BC ** **     .10		ldy VoiceInUse,x	; Is this voice active?
  528 0F7E:F0 **        		beq .20			; Branch if not active
  529 0F80:DA           		 phx
  530 0F81:20 5F 0F     		  jsr muteVoiceX	; Tell HSFX to kill current note/MS
  531 0F84:FA           		 plx
  532 0F85:CA           .20		dex			; Try next voice
  533 0F86:10 F3        	       bpl .10			; Branch if there's more to try
  534                   
  535 0F88:7A           	     ply
  536 0F89:FA           	   plx
  537                   
  538 0F8A:68           .30	 pla
  539 0F8B:60           	rts
  540                   
  541                    #ENDIF	; of #IFDEF MUTE_USER
  542                   
  543                   
  544                   
  545                   * === ================================================
  546                   * ===                     ============================
  547                   * ===    Interrupt Code   ============================
  548                   * ===                     ============================
  549                   * === ================================================
  550                   
  551                   
  552                   
  553 0F8C:             hmusic_driver
  554                   * ====================================================
  555                   * Here's the hmusic driver interrupt code
  556                   * If you *have* to understand what this code does, goo
  557                   *
  558                   * The audio driver turns itself into "low-priority" in
  559                   * enabling interrupts as soon as it has protected itse
  560                   * reentered.  This will allow more important (especial
  561                   * interrupt routines to wrest control away from audio 
  562                   
  563                   	;-- Test if this is a music interrupt re-entering
  564                   	;-- If audio_interruptus is zero, this is a top-level
  565                   	;-- into the interrupt code so it's safe to proceed. 
  566                   	;-- if audio_interruptus isn't zero we're re-entering
  567                   	;-- got so pushed so deep in the queue that another a
  568                   	;-- interrupt occurred!  It's not safe to re-enter, s
  569                   	;-- (causing the audio to skip a beat, it's true).
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   48
                        6502:src/hmusic.src             07:11:20  

  570 0F8C:EE ** **     	inc audio_dropout	; count frame
  571 0F8F:AD ** **     	lda audio_lockout	; are we being locked out?
  572 0F92:D0 **        	bne .12
  573 0F94:AD ** **     	lda audio_interruptus	; are we interrupting ourself?
  574 0F97:F0 **        	beq .10
  575 0F99:EE ** **     .12	inc audio_dropout	; count frames we've dropped
  576                   
  577 0F9C:FA           	plx			; exit IRQ
  578 0F9D:68           	pla
  579 0F9E:40           	rti
  580                   
  581 0F9F:EE ** **     .10	inc audio_interruptus	; Mark that we are here
  582 0FA2:58           	cli			; and let other interrupts run
  583                   
  584 0FA3:             hmusic_interrupt_core
  585 0FA3:5A           	 phy
  586                   
  587      FALSE         #IFDEF	USERCALLS_USER
  589                    #ENDIF
  590                   
  591                   * For each active voice, check if we need to start the
  592                   * note's volume has fallen to zero
  593                   
  594 0FA4:A2 03        	  ldx #HMUSIC_CHANNELCOUNT-1	; Loop for voices
  595 0FA6:             voiceLoop
  596 0FA6:BD ** **     	    lda VoiceInUse,x	; Voice active?
  597 0FA9:F0 **        	    beq voiceLoopEnd	; Branch if not
  598                   
  599 0FAB:FE ** **     	    inc frames_alivel,x	; increment number of frames 
  600 0FAE:D0 **        	    bne .18
  601 0FB0:FE ** **     	    inc frames_aliveh,x
  602                   
  603 0FB3:BD ** **     .18	    lda frames_alivel,x		; is it time to get a new
  604 0FB6:DD ** **     	    cmp voice_endframel,x
  605 0FB9:D0 **        	    bne .17
  606 0FBB:BD ** **     	    lda frames_aliveh,x
  607 0FBE:DD ** **     	    cmp voice_endframeh,x
  608 0FC1:D0 **        	    bne .17
  609                   
  610 0FC3:BD ** **     	    lda VoiceHSFXChannel,x	; Get this voice's HSFX ch
  611 0FC6:C9 04        	    cmp #HSFX_CHANNELCOUNT	; does this voice have a c
  612 0FC8:B0 **        	    bcs .cd
  613 0FCA:DA           	     phx
  614 0FCB:BC ** **     	      ldy voice_offsets,x	; Get offset to this voice'
  615 0FCE:AA           	      tax
  616 0FCF:B9 ** **     	      lda voice0,y		; See if this voice still has cha
  617 0FD2:DD ** **     	      cmp ChannelInUse,x
  618 0FD5:D0 **        	      bne .ce
  619 0FD7:20 2D 0C     	      jsr freeChannelX		; free the channel
  620 0FDA:FA           .ce	     plx
  621                   
  622 0FDB:20 ** **     .cd	    jsr getNextData	; Load next note data
  623 0FDE:9E ** **     	    stz frames_alivel,x	; Reset the number of frames 
  624 0FE1:9E ** **     	    stz frames_aliveh,x
  625 0FE4:80 **        	    bra voiceLoopEnd
  626                   
  627 0FE6:BC ** **     .17	    ldy voice_offsets,x		; Get offset of voice's k
  628 0FE9:BD ** **     	    lda frames_alivel,x		; Are we in release stage?
  629 0FEC:D9 ** **     	    cmp releaseframe_v0,y
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   49
                        6502:src/hmusic.src             07:11:20  

  630 0FEF:BD ** **     	    lda frames_aliveh,x
  631 0FF2:F9 ** **     	    sbc releaseframe_v0+1,y
  632 0FF5:90 **        	    bcc voiceLoopEnd
  633                   
  634 0FF7:BD ** **     .22	    lda VoiceHSFXChannel,x	; Get HSFX channel of t
  635 0FFA:C9 04        	    cmp #HSFX_CHANNELCOUNT	; ignore if this voice has
  636 0FFC:B0 **        	    bcs voiceLoopEnd
  637 0FFE:DA           	     phx
  638 0FFF:AA           	      tax
  639 1000:B9 ** **     	      lda voice0,y		; See if we still own channel
  640 1003:DD ** **     	      cmp ChannelInUse,x
  641 1006:D0 **        	      bne .29
  642 1008:BD ** **     	      lda volumel,x		; check for volume close to zero
  643 100B:D9 ** **     	      cmp releaseframe_v0+8,y
  644 100E:BD ** **     	      lda volumeh,x
  645 1011:F0 **        	      beq .27
  646 1013:F9 ** **     	      sbc releaseframe_v0+9,y
  647 1016:90 **        	      bcc .29
  648                   
  649 1018:20 2D 0C     .27	      jsr freeChannelX		; close enough to zero, ki
  650                   
  651 101B:FA           .29	     plx
  652                   
  653 101C:             voiceLoopEnd	;-- Process the next channel
  654 101C:CA           	    dex
  655 101D:10 87        	   bpl voiceLoop
  656                   
  657 101F:             .10
  658                   * Check each of the voices.  If it's at the start of a
  659                   * launch the note's pre-calculated HSFX sound effect k
  660                   
  661 101F:A2 03        	  ldx #HMUSIC_CHANNELCOUNT-1
  662 1021:             voiceLaunchLoop
  663 1021:1E ** **     	    asl new_note,x	; Top bit of new_note set?
  664 1024:90 **        	    bcc .c0		; Branch if not
  665                   
  666      TRUE          #IFDEF MUTE_USER
  667 1026:2C ** **     	    bit Mute_flag	; Is the mute flag set?
  668 1029:30 **        	    bmi .c0		; Branch if negative to mute
  669                    #ENDIF
  670                   
  671 102B:DA           	     phx		; Launch new keyframe set for new note
  672 102C:BC ** **     	      ldy voice_offsets,x	; Get offset to this voice'
  673 102F:B9 ** **     	      lda voice0,y		; Get the priority of this voice
  674 1032:A8           	      tay			; Copy the priority for StartHSFX
  675                   
  676 1033:BD ** **     	      lda voice_offsets,x	; Get offset to this voice'
  677 1036:18           	      clc			; Add address of first keyframe
  678 1037:69 **        	      adc #<attackframe_v0
  679 1039:A2 **        	      ldx #>attackframe_v0	; Get high byte into X
  680 103B:90 **        	      bcc .b8
  681 103D:E8           	      inx
  682 103E:20 B3 0B     .b8	      jsr StartHSFX		; Start this note "sound effe
  683 1041:8A           	      txa			; Grab copy of channel
  684 1042:FA           	     plx
  685 1043:9D ** **     	    sta VoiceHSFXChannel,x	; Save copy of this voice'
  686                   
  687 1046:CA           .c0	    dex
  688 1047:10 D8        	   bpl voiceLaunchLoop
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   50
                        6502:src/hmusic.src             07:11:20  

  689                   
  690                   
  691      FALSE         #IFDEF	USERCALLS_USER
  700                    #ENDIF	; of #IFDEF USERCALLS_USER
  701                   
  702 1049:20 46 0C     	  jsr hsfx_driver_grunt	; Call HSFX driver
  703                   
  704 104C:7A           	 ply
  705                   
  706 104D:CE ** **     	dec audio_dropout	; count off frame
  707 1050:F0 **        	beq .00
  708 1052:4C A3 0F     	jmp hmusic_interrupt_core	; catch dropped frames
  709                   
  710 1055:9C ** **     .00	stz audio_interruptus	; reset flag so we know it's
  711 1058:FA           	plx			; exit IRQ
  712 1059:68           	pla
  713 105A:40           	rti
  714                   
  715                   
  716                   
  717 105B:             getNextData
  718                   * ====================================================
  719                   * Load up the data for the voice's next note.  This in
  720                   * or more CFW's until an honest note is found which is
  721                   * HSFX keyframes.
  722                   *
  723                   * On entry:  X has the voice channel number
  724 105B:BC ** **     	ldy voice_offsets,x	; Get offset to this voice's data
  725                   
  726 105E:1E ** **     	asl restore_ds,x	; Should we restore the decay and su
  727 1061:90 **        	bcc .10
  728                   
  729 1063:BD ** **     	lda save_decayl,x	; Restore time to start decay
  730 1066:99 ** **     	sta decayframe_v0,y
  731 1069:BD ** **     	lda save_decayh,x
  732 106C:99 ** **     	sta decayframe_v0+1,y
  733 106F:BD ** **     	lda save_sustainl,x	; Restore time to start sustain
  734 1072:99 ** **     	sta sustainframe_v0,y
  735 1075:BD ** **     	lda save_sustainh,x
  736 1078:99 ** **     	sta sustainframe_v0+1,y
  737                   
  738 107B:9C ** **     .10	stz did_innernext	; Reset loop skip flags
  739 107E:9C ** **     	stz did_outernext
  740 1081:9C ** **     	stz did_ring_end	; Reset ring end flag
  741                   
  742                   	;-- Check if there's an HSFX currently playing for th
  743 1084:BD ** **     	lda SFX_to_cancel,x	; Maybe active.  Got a cancel sta
  744 1087:F0 **        	beq mloop_frame		; If not, then skip
  745                   
  746                   	;-- There's currently an HSFX for this voice.  Kill i
  747 1089:99 ** **     	sta voice0,y		; Restore music priority from stash
  748 108C:A8           	tay			; and specifically stop sfx
  749 108D:DA           	 phx
  750 108E:20 F0 0B     	  jsr StopHSFX
  751 1091:FA           	 plx
  752 1092:9E ** **     	stz SFX_to_cancel,x	; Set sfx as stopped (clear stash
  753                   
  754                   
  755 1095:             mloop_frame
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   51
                        6502:src/hmusic.src             07:11:20  

  756                   * Here, we process the next block of data in the note 
  757 1095:BD ** **     	  lda voicedata_ptrl,x	; Get a z-page pointer to voic
  758 1098:85 1E        	  sta audio_ptr
  759 109A:BD ** **     	  lda voicedata_ptrh,x
  760 109D:85 1F        	  sta audio_ptr+1
  761                   
  762 109F:B2 1E        	  lda (audio_ptr)		; Find out what to do this time
  763 10A1:30 **        	  bmi do_CFW		; If high bit clear, this is a note
  764 10A3:4C ** **     	  jmp do_note		; else this is a CFW
  765                   
  766                   
  767                   
  768 10A6:             do_CFW
  769                   * ----------------------------------------------------
  770                   * Next note table entry is a Command Flags Word (not a
  771                   
  772 10A6:8D ** **     	  sta hmflagsl		; Grab a copy of these new command fl
  773 10A9:A0 01        	  ldy #1		; Y will be the voice data index
  774 10AB:B1 1E        	  lda (audio_ptr),y
  775 10AD:8D ** **     	  sta hmflagsh
  776 10B0:C8           	  iny
  777                   
  778                   * --- Rings ---
  779 10B1:AD ** **     	  lda hmflagsh		; is RING flag set?
  780 10B4:29 08        	  and #>RING
  781 10B6:F0 **        	  beq ring_considered	; Branch if not RING
  782                   
  783 10B8:4E ** **     	  lsr did_ring_end	; Did we loop to the CFW that sent
  784 10BB:B0 **        	  bcs post_ring		; Branch if returning to ring starte
  785                   
  786 10BD:BD ** **     	  lda ring_flag,x	; Are we already doing level 0 ring
  787 10C0:F0 **        	  beq first_RING
  788                   
  789 10C2:A5 1E        	  lda audio_ptr		; Nested ring, do level '1'
  790 10C4:9D ** **     	  sta ring1_returnl,x	: Stash the current note table
  791 10C7:A5 1F        	  lda audio_ptr+1	; pointer as our return location
  792 10C9:9D ** **     	  sta ring1_returnh,x	; at end of ring 1
  793                   
  794 10CC:A9 02        	  lda #2
  795 10CE:9D ** **     	  sta ring_flag,x	; Mark RING1 as active
  796 10D1:80 **        	  bra new_RING		; and go set up this new ring
  797                   
  798 10D3:             first_RING			; We've got the start of a level 0 ring
  799 10D3:A5 1E        	  lda audio_ptr		: Stash the current note table
  800 10D5:9D ** **     	  sta ring0_returnl,x	; pointer as our return locatio
  801 10D8:A5 1F        	  lda audio_ptr+1	; at end of ring 0
  802 10DA:9D ** **     	  sta ring0_returnh,x
  803                   
  804 10DD:FE ** **     	  inc ring_flag,x	; Mark RING0 as active
  805                   
  806 10E0:             new_RING			; Set up the pointers to handle this new ri
  807 10E0:B1 1E        	  lda (audio_ptr),y	; Get voice index
  808 10E2:0A           	  asl a			; Change to word index
  809 10E3:A8           	  tay
  810                   ;	  clc	; true from above
  811 10E4:B1 25        	  lda (voiceoffsets_ptr),y ; Get offset of voice data
  812 10E6:6D ** **     	  adc hmusic_base	; and use it to create new voice da
  813 10E9:9D ** **     	  sta voicedata_ptrl,x
  814 10EC:C8           	  iny
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   52
                        6502:src/hmusic.src             07:11:20  

  815 10ED:B1 25        	  lda (voiceoffsets_ptr),y
  816 10EF:6D ** **     	  adc hmusic_base+1
  817 10F2:9D ** **     	  sta voicedata_ptrh,x
  818                   
  819 10F5:4C 95 10     	 jmp mloop_frame	; Take it from the top with voice's 
  820                   
  821 10F8:             post_ring	;-- Just returned from the ring, so ignore i
  822 10F8:C8           	iny			; Skip ring index byte
  823                   
  824                   
  825 10F9:             ring_considered	;-- Done thinking about rings for now
  826                   
  827                   
  828                   * --- Loops ---
  829                   
  830                   ; Inner loop - bottom
  831                   
  832 10F9:AD ** **     	  lda did_innernext	; Did we get here after processin
  833 10FC:0D ** **     	  ora did_outernext	; either an inner or outer NEXT?
  834 10FF:D0 **        	  bne mnext0_done	; If so, skip processing NEXTs
  835                   
  836 1101:AD ** **     	  lda hmflagsh
  837 1104:29 10        	  and #>NEXT1		; At the bottom of an inner loop?
  838 1106:F0 **        	  beq mnext1_done	; No
  839                   
  840 1108:BD ** **     	  lda mloop_count1,x	; Infinite loop?
  841 110B:F0 **        	  beq takeloop1		; Yes, don't count
  842 110D:DE ** **     	  dec mloop_count1,x	; No, are we done?
  843 1110:F0 **        	  beq mnext1_done	; Yes, go check next flag
  844                   
  845 1112:             takeloop1
  846 1112:BD ** **     	  lda mloop_adrl1,x	; Reload pointer to top of loop
  847 1115:9D ** **     	  sta voicedata_ptrl,x
  848 1118:BD ** **     	  lda mloop_adrh1,x
  849 111B:9D ** **     	  sta voicedata_ptrh,x
  850 111E:EE ** **     	  inc did_innernext	; Set to skip LOOP1 we'll find th
  851 1121:4C 95 10     	 jmp mloop_frame	; and go do top of loop
  852 1124:             mnext1_done
  853                   
  854                   
  855                   
  856                   ; Outer loop - bottom
  857                   ;;;	  lda did_innernext	; Did we get here after proces
  858                   ;;;	  ora did_outernext	; either an inner or outer NEX
  859                   ;;;	  bne mnext0_done	; If so, skip processing outer N
  860                   
  861 1124:AD ** **     	  lda hmflagsh
  862 1127:29 40        	  and #>NEXT0		; Are we at the bottom of an outer loo
  863 1129:F0 **        	  beq mnext0_done	; Branch if not
  864                   
  865 112B:BD ** **     	  lda mloop_count0,x	; Infinite loop?
  866 112E:F0 **        	  beq takeloop0		; Yes, don't count
  867 1130:DE ** **     	  dec mloop_count0,x	; No, are we done?
  868 1133:F0 **        	  beq mnext0_done	; Yes, go check next flag
  869                   
  870 1135:             takeloop0	;-- Loop back to the top of the outer loop
  871 1135:BD ** **     	  lda mloop_adrl0,x	; Reload pointer to top of loop
  872 1138:9D ** **     	  sta voicedata_ptrl,x
  873 113B:BD ** **     	  lda mloop_adrh0,x
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   53
                        6502:src/hmusic.src             07:11:20  

  874 113E:9D ** **     	  sta voicedata_ptrh,x
  875 1141:EE ** **     	  inc did_outernext	; Set to skip LOOP0 we'll find th
  876 1144:4C 95 10     	 jmp mloop_frame	; and go do top of loop
  877 1147:             mnext0_done
  878                   
  879                   
  880                   
  881                   ; Outer loop stuff - top
  882 1147:AD ** **     	  lda hmflagsh
  883 114A:29 80        	  and #>LOOP0		; Are we starting an outer loop?
  884 114C:F0 **        	  beq mloop0_considered	; Branch if not
  885                   
  886 114E:AD ** **     	  lda did_innernext	; Did we get here after processin
  887 1151:0D ** **     	  ora did_outernext	; either an inner or outer NEXT?
  888 1154:D0 **        	  bne mstuff0		; If so, skip processing outer LOOP0
  889                   
  890 1156:A5 1E        	  lda audio_ptr		; Stash current data pointer
  891 1158:9D ** **     	  sta mloop_adrl0,x
  892 115B:A5 1F        	  lda audio_ptr+1
  893 115D:9D ** **     	  sta mloop_adrh0,x
  894 1160:B1 1E        	  lda (audio_ptr),y	; Get # of loops to do
  895 1162:9D ** **     	  sta mloop_count0,x	; (if 0, infinite loop!)
  896 1165:             mstuff0
  897 1165:C8           	  iny			; Bump index past loop count
  898                   
  899 1166:             mloop0_considered
  900                   
  901                   
  902                   
  903                   ; Inner loop - top
  904 1166:AD ** **     	  lda hmflagsh
  905 1169:29 20        	  and #>LOOP1		; Are we starting an inner loop?
  906 116B:F0 **        	  beq mloop1_considered	; Branch if not
  907                   
  908 116D:AD ** **     	  lda did_innernext	; If we've done an inner loop NEX
  909 1170:D0 **        	  bne mstuff1		; then skip processing this loop start
  910                   
  911 1172:A5 1E        	  lda audio_ptr		; Stash current data pointer
  912 1174:9D ** **     	  sta mloop_adrl1,x
  913 1177:A5 1F        	  lda audio_ptr+1
  914 1179:9D ** **     	  sta mloop_adrh1,x
  915 117C:B1 1E        	  lda (audio_ptr),y	; Get # of loops to do
  916 117E:9D ** **     	  sta mloop_count1,x	; (if 0, infinite loop!)
  917 1181:             mstuff1
  918 1181:C8           	  iny			; Bump index past loop count
  919                   
  920 1182:             mloop1_considered
  921                   
  922                   
  923                   * --- Gating ---
  924                   
  925 1182:AD ** **     	  lda hmflagsh
  926 1185:29 03        	  and #>ASD+AGD		; Either ASD or ADG gate value?
  927 1187:F0 **        	  beq asd_agd_considered	; Branch if not
  928                   
  929 1189:9D ** **     	  sta gating,x		; Save new gating flags
  930 118C:B1 1E        	  lda (audio_ptr),y	; and get new gating value
  931 118E:9D ** **     	  sta gatel,x
  932 1191:C8           	  iny
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   54
                        6502:src/hmusic.src             07:11:20  

  933 1192:B1 1E        	  lda (audio_ptr),y
  934 1194:9D ** **     	  sta gateh,x
  935 1197:C8           	  iny
  936                   
  937 1198:             asd_agd_considered
  938                   
  939                   
  940                   * --- Music HSFX ---
  941 1198:AD ** **     	  lda hmflagsl
  942 119B:29 20        	  and #MSFX		; Should this voice be a sound effect?
  943 119D:F0 **        	  beq msfx_considered	; Branch if not
  944                   
  945 119F:DA           	   phx
  946 11A0:5A           	     phy
  947                   
  948 11A1:BC ** **     	      ldy voice_offsets,x	; Get offset to this voice'
  949 11A4:B9 ** **     	      lda voice0,y		; Get this voice's current priori
  950 11A7:9D ** **     	      sta SFX_to_cancel,x	; Save for killing effect l
  951 11AA:85 20        	      sta hsfx_temp
  952 11AC:A9 00        	      lda #0			; Temporarily set this note's priority
  953 11AE:99 ** **     	      sta voice0,y		; to 0 to prevent HSFX conflict
  954                   
  955      TRUE         	#IFDEF MUTE_USER
  956 11B1:2C ** **     	      bit Mute_flag		; Is the mute flag set?
  957 11B4:30 **        	      bmi .b9			; Branch if negative to mute
  958                   	#ENDIF
  959                   
  960 11B6:7A           	     ply			; Restore argument index
  961 11B7:5A           	     phy
  962 11B8:B1 1E        	      lda (audio_ptr),y	; Get index into SFX offset t
  963 11BA:0A           	      asl a			; Make it a word index
  964 11BB:A8           	      tay
  965 11BC:B1 25        	      lda (voiceoffsets_ptr),y ; Get offset of first 
  966 11BE:18           	      clc
  967 11BF:6D ** **     	      adc hmusic_base		; and create the keyframe addr
  968 11C2:48           	       pha
  969 11C3:C8           		iny
  970 11C4:B1 25        		lda (voiceoffsets_ptr),y
  971 11C6:6D ** **     		adc hmusic_base+1
  972 11C9:AA           		tax			; High byte of address
  973 11CA:68           	       pla			; Low  byte of address
  974 11CB:A4 20        	      ldy hsfx_temp		; Priority of voice/effect
  975 11CD:20 B3 0B     	      jsr StartHSFX		; Start this note "sound effect"
  976                   
  977 11D0:7A           .b9	     ply
  978 11D1:C8           	    iny
  979 11D2:FA           	   plx
  980 11D3:BD ** **     	  lda voicedata_ptrl,x	; Restore our voice data point
  981 11D6:85 1E        	  sta audio_ptr		; (trashed by StartHSFX)
  982 11D8:BD ** **     	  lda voicedata_ptrh,x
  983 11DB:85 1F        	  sta audio_ptr+1
  984 11DD:             msfx_considered
  985                   
  986                   
  987                   * --- User Call ---
  988 11DD:AD ** **     	  lda hmflagsl
  989 11E0:29 10        	  and #USER		; Some USER data to send?
  990 11E2:F0 **        	  beq user_considered	; Branch if not
  991                   
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   55
                        6502:src/hmusic.src             07:11:20  

  992      FALSE        	#IFDEF	USERCALLS_USER
 1001                   	#ENDIF ; of #IFDEF USERCALLS_USER
 1002 11E4:C8           	  iny
 1003                   
 1004 11E5:             user_considered
 1005                   
 1006                   
 1007                   * --- Duration Table Selector ---
 1008 11E5:AD ** **     	  lda hmflagsl
 1009 11E8:29 08        	  and #DURATION		; New duration table?
 1010 11EA:F0 **        	  beq dur_tbl_considered
 1011                   
 1012 11EC:B1 1E        	  lda (audio_ptr),y	; Yes, get offset to duration tab
 1013 11EE:18           	  clc
 1014 11EF:6D ** **     	  adc hmusic_base	; and convert to absolute address
 1015 11F2:9D ** **     	  sta voice_dur_ptrl,x	; and store new address of dur
 1016 11F5:C8           	  iny
 1017 11F6:B1 1E        	  lda (audio_ptr),y
 1018 11F8:6D ** **     	  adc hmusic_base+1
 1019 11FB:9D ** **     	  sta voice_dur_ptrh,x
 1020 11FE:C8           	  iny
 1021                   
 1022 11FF:             dur_tbl_considered
 1023                   
 1024                   
 1025                   * --- Pitch Table Selector ---
 1026 11FF:AD ** **     	  lda hmflagsl
 1027 1202:29 04        	  and #PITCH		; New pitch table?
 1028 1204:F0 **        	  beq freq_tbl_considered
 1029                   
 1030 1206:B1 1E        	  lda (audio_ptr),y	; Yes, get offset to pitch table
 1031 1208:18           	  clc
 1032 1209:6D ** **     	  adc hmusic_base
 1033 120C:9D ** **     	  sta voice_freq_ptrl,x	; and convert to absolute add
 1034 120F:C8           	  iny			; and store new address of pitch table
 1035 1210:B1 1E        	  lda (audio_ptr),y
 1036 1212:6D ** **     	  adc hmusic_base+1
 1037 1215:9D ** **     	  sta voice_freq_ptrh,x
 1038 1218:C8           	  iny
 1039                   
 1040 1219:             freq_tbl_considered
 1041                   
 1042                   
 1043                   * --- Keyframe Raw Data ---
 1044                   * This is how the normal ADSR for a voice gets loaded.
 1045                   * the sound guys can slip in craazy sound effects with
 1046                   * First comes an optional byte that designates Standar
 1047                   * causes a bunch of keyframe fields to be cleared.
 1048                   * Next, escape data comes in 3 bytes:  offset into son
 1049                   * data, next two bytes are low and high data to go in 
 1050                   * Lastly the end of the escape data is designated eith
 1051                   * music note or a byte of $FF (meaning End Of Escape).
 1052                   
 1053 1219:AD ** **     	  lda hmflagsl
 1054 121C:29 02        	  and #ESCAPE		; Load raw data into keyframe set?
 1055 121E:F0 **        	  beq escape_considered	; Branch if not
 1056                   
 1057 1220:DA           	   phx
 1058 1221:BD ** **     	    lda voice_offsets,x	; Get offset to this voice's 
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   56
                        6502:src/hmusic.src             07:11:20  

 1059 1224:85 20        	    sta hsfx_temp
 1060                   
 1061 1226:B1 1E        	    lda (audio_ptr),y	; Get first ESCAPE argument
 1062 1228:C9 FF        	    cmp #$ff		; Clear some seldom used locations?
 1063 122A:D0 **        	    bne .44		; Branch if not
 1064                   
 1065 122C:5A           	     phy	; Clear several elements in this voice's key
 1066 122D:A0 **        	      ldy #clear_voice_end-clear_voice-1 ; Get max cl
 1067 122F:B9 ** **     .22		lda clear_voice,y	; Create offset to the voice's 
 1068                   ;		clc	; clear from above
 1069 1232:65 20        		adc hsfx_temp
 1070 1234:AA           		tax
 1071 1235:9E ** **     		stz voice0,x
 1072 1238:9E ** **     		stz voice0+1,x
 1073 123B:88           		dey
 1074 123C:10 F1        	       bpl .22
 1075 123E:7A           	     ply
 1076 123F:C8           	    iny
 1077                   
 1078 1240:B1 1E        .44	    lda (audio_ptr),y	; get next note or ESCAPE fl
 1079 1242:10 **        	    bpl end_escape	; High bit off = end of escape seq
 1080                   
 1081 1244:C8           	    iny			; Advance index past this byte
 1082                   
 1083                   	    ; If byte is the special "end of escape" value th
 1084 1245:C9 FF        	    cmp #$ff		; Note: only needed if two adjacent
 1085 1247:F0 **        	    beq end_escape	;  CFWs - i.e.: consecutive RING
 1086                   
 1087                   	    ;-- Else this is normal escape data, so get the d
 1088                   	    ;-- store it into the keyframe and try again
 1089 1249:29 7F        	    and #$7f		; Mask off upper bit
 1090 124B:18           	    clc
 1091 124C:65 20        	    adc hsfx_temp	; Add voice offset
 1092 124E:AA           	    tax
 1093 124F:B1 1E        	    lda (audio_ptr),y	; Copy value
 1094 1251:9D ** **     	    sta voice0,x
 1095 1254:C8           	    iny
 1096 1255:B1 1E        	    lda (audio_ptr),y
 1097 1257:9D ** **     	    sta voice0+1,x
 1098 125A:C8           	    iny
 1099 125B:80 E3        	    bra .44
 1100                   
 1101 125D:             end_escape
 1102 125D:FA           	   plx
 1103                   
 1104 125E:5A           	   phy
 1105 125F:BC ** **     	    ldy voice_offsets,x		; Get offset to this voice's
 1106 1262:B9 ** **     	    lda decayframe_v0,y		; back up decay times
 1107 1265:9D ** **     	    sta save_decayl,x
 1108 1268:B9 ** **     	    lda decayframe_v0+1,y
 1109 126B:9D ** **     	    sta save_decayh,x
 1110 126E:B9 ** **     	    lda sustainframe_v0,y	; back up sustain times
 1111 1271:9D ** **     	    sta save_sustainl,x
 1112 1274:B9 ** **     	    lda sustainframe_v0+1,y
 1113 1277:9D ** **     	    sta save_sustainh,x
 1114 127A:7A           	   ply
 1115                   
 1116                   
 1117 127B:             escape_considered
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   57
                        6502:src/hmusic.src             07:11:20  

 1118                   * --- Almost at End ---
 1119 127B:AD ** **     	  lda hmflagsl		; check for final CFW
 1120 127E:29 01        	  and #END_OF_VOICE
 1121 1280:D0 **        	  bne end_voice		; Branch if so
 1122                   
 1123 1282:98           	  tya			; skip bytes just processed
 1124 1283:18           	  clc
 1125 1284:65 1E        	  adc audio_ptr
 1126 1286:9D ** **     	  sta voicedata_ptrl,x
 1127 1289:A9 00        	  lda #0
 1128 128B:65 1F        	  adc audio_ptr+1
 1129 128D:9D ** **     	  sta voicedata_ptrh,x
 1130 1290:4C 95 10     	 jmp mloop_frame	; else go to top and do it all again
 1131                   
 1132                   
 1133 1293:             end_voice
 1134                   * --- End of Voice ---
 1135 1293:5E ** **     	  lsr ring_flag,x	; Is a 'RING' ending?
 1136 1296:D0 **        	  bne return_from_ring1	; Branch if RING1 ending
 1137 1298:B0 **        	  bcs return_from_ring0	; Branch if RING0 ending
 1138 129A:9E ** **     	  stz VoiceInUse,x	; else this voice is done!
 1139 129D:60           	rts			; RG sez:  Ttfn
 1140                   
 1141 129E:             return_from_ring1
 1142 129E:BD ** **     	  lda ring1_returnl,x	; Restore 'RING0' address
 1143 12A1:BC ** **     	  ldy ring1_returnh,x
 1144 12A4:80 **        	  bra ring_return
 1145                   
 1146 12A6:             return_from_ring0
 1147 12A6:BD ** **     	  lda ring0_returnl,x	; Restore main voice address
 1148 12A9:BC ** **     	  ldy ring0_returnh,x
 1149                   
 1150 12AC:             ring_return
 1151 12AC:9D ** **     	  sta voicedata_ptrl,x	; restore CFW to return from r
 1152 12AF:98           	  tya
 1153 12B0:9D ** **     	  sta voicedata_ptrh,x
 1154 12B3:EE ** **     	  inc did_ring_end
 1155 12B6:4C 95 10     	 jmp mloop_frame
 1156                   
 1157                   
 1158                   
 1159                   
 1160 12B9:             do_note
 1161                   * ----------------------------------------------------
 1162                   * Next note table entry is an actual note (not a Comma
 1163                   
 1164 12B9:DA           	 phx
 1165                   
 1166 12BA:29 0F        	  and #SONG_PITCHBITS	; turn note entry into frequenc
 1167 12BC:0A           	  asl a			;  0dddpppp -> 000pppp0
 1168 12BD:A8           	  tay
 1169                   
 1170 12BE:A9 04        	  lda #HSFX_CHANNELCOUNT	; mark that we have no chann
 1171 12C0:9D ** **     	  sta VoiceHSFXChannel,x
 1172                   
 1173 12C3:BD ** **     	  lda voice_freq_ptrl,x		; Set up note's frequency po
 1174 12C6:85 21        	  sta frequency_ptr
 1175 12C8:BD ** **     	  lda voice_freq_ptrh,x
 1176 12CB:85 22        	  sta frequency_ptr+1
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   58
                        6502:src/hmusic.src             07:11:20  

 1177                   
 1178 12CD:BD ** **     	  lda voice_dur_ptrl,x		; Set up note's duration poin
 1179 12D0:85 23        	  sta duration_ptr
 1180 12D2:BD ** **     	  lda voice_dur_ptrh,x
 1181 12D5:85 24        	  sta duration_ptr+1
 1182                   
 1183 12D7:BD ** **     	  lda voice_offsets,x		; get offset to voice's HSFX k
 1184 12DA:AA           	  tax
 1185                   
 1186 12DB:B1 21        	  lda (frequency_ptr),y		; Load up the frequency for 
 1187 12DD:9D ** **     	  sta attackfreq_v0,x
 1188 12E0:C8           	  iny
 1189 12E1:B1 21        	  lda (frequency_ptr),y
 1190 12E3:9D ** **     	  sta attackfreq_v0+1,x
 1191 12E6:1D ** **     	  ora attackfreq_v0,x		; check for zero frequency
 1192 12E9:48           	   pha				; save for later
 1193                   
 1194 12EA:B2 1E        	    lda (audio_ptr)		; turn note entry into duration 
 1195 12EC:29 70        	    and #SONG_DURATIONBITS	;  0dddpppp -> 0000ddd0
 1196 12EE:4A           	    lsr a
 1197 12EF:4A           	    lsr a
 1198 12F0:4A           	    lsr a
 1199 12F1:A8           	    tay
 1200                   
 1201 12F2:B1 23        	    lda (duration_ptr),y	; Jam value into the end not
 1202 12F4:9D ** **     	    sta endframe_v0,x
 1203 12F7:C8           	    iny
 1204 12F8:B1 23        	    lda (duration_ptr),y
 1205 12FA:9D ** **     	    sta endframe_v0+1,x
 1206                   
 1207 12FD:68           	   pla			; restore zero frequency check
 1208 12FE:FA           	 plx			; Restore the voice channel number
 1209                   
 1210 12FF:C9 00        	cmp #0			; test for pitch set to 0
 1211 1301:F0 **        	beq .00
 1212                   
 1213 1303:A9 80        	lda #$80	; if non-zero pitch, set flag marking new no
 1214 1305:9D ** **     	sta new_note,x
 1215                   
 1216 1308:B1 23        .00	lda (duration_ptr),y	; save duration value for mus
 1217 130A:9D ** **     	sta voice_endframeh,x
 1218 130D:88           	dey
 1219 130E:B1 23        	lda (duration_ptr),y
 1220 1310:9D ** **     	sta voice_endframel,x
 1221                   
 1222 1313:BC ** **     	ldy voice_offsets,x	; Get offset to this voice's keyf
 1223 1316:BD ** **     	lda gating,x		; Get gating flags, check for AGS or AG
 1224 1319:29 01        	and #>AGD		; AGD?
 1225 131B:D0 **        	bne .10			; Branch if AGD (not AGS)
 1226                   
 1227 131D:38           	sec			; Set up AGS
 1228 131E:BD ** **     	lda voice_endframel,x	;  (start of release = duration
 1229 1321:FD ** **     	sbc gatel,x
 1230 1324:99 ** **     	sta releaseframe_v0,y
 1231 1327:BD ** **     	lda voice_endframeh,x
 1232 132A:FD ** **     	sbc gateh,x
 1233                   ;	sta releaseframe_v0+1,y	; done below
 1234 132D:80 **        	bra .19
 1235                   
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   59
                        6502:src/hmusic.src             07:11:20  

 1236 132F:BD ** **     .10	lda gatel,x		; Set up AGD (start of release = gate
 1237 1332:99 ** **     	sta releaseframe_v0,y
 1238 1335:BD ** **     	lda gateh,x
 1239 1338:99 ** **     .19	sta releaseframe_v0+1,y
 1240                   
 1241 133B:B9 ** **     	lda sustainframe_v0,y	; Check that sustain starts bef
 1242 133E:D9 ** **     	cmp releaseframe_v0,y
 1243 1341:B9 ** **     	lda sustainframe_v0+1,y
 1244 1344:F9 ** **     	sbc releaseframe_v0+1,y
 1245 1347:90 **        	bcc .40
 1246                   
 1247 1349:A9 80        	lda #$80		; Mark need to restore decay and sus
 1248 134B:9D ** **     	sta restore_ds,x
 1249                   
 1250 134E:38           	sec			; Set sustain time to (release time - 1)
 1251 134F:B9 ** **     	lda releaseframe_v0,y
 1252 1352:E9 01        	sbc #1
 1253 1354:99 ** **     	sta sustainframe_v0,y
 1254 1357:B9 ** **     	lda releaseframe_v0+1,y
 1255 135A:E9 00        	sbc #0
 1256 135C:99 ** **     	sta sustainframe_v0+1,y
 1257                   
 1258 135F:B9 ** **     	lda decayframe_v0,y	; Check that decay starts before 
 1259 1362:D9 ** **     	cmp sustainframe_v0,y
 1260 1365:B9 ** **     	lda decayframe_v0+1,y
 1261 1368:F9 ** **     	sbc sustainframe_v0+1,y
 1262 136B:90 **        	bcc .40
 1263                   
 1264 136D:38           	sec			; Set decay time to (sustain time - 1)
 1265 136E:B9 ** **     	lda sustainframe_v0,y
 1266 1371:E9 01        	sbc #1
 1267 1373:99 ** **     	sta decayframe_v0,y
 1268 1376:B9 ** **     	lda sustainframe_v0+1,y
 1269 1379:E9 00        	sbc #0
 1270 137B:99 ** **     	sta decayframe_v0+1,y
 1271                   
 1272 137E:FE ** **     .40	inc voicedata_ptrl,x	; Point to next entry in voic
 1273 1381:D0 **        	bne .7d
 1274 1383:FE ** **     	inc voicedata_ptrh,x
 1275                   
 1276 1386:60           .7d	rts
 1277                   
 1278                   
 1279                   
 1280                   
 1281                   * === ================================================
 1282                   * ===               ==================================
 1283                   * ===      Data     ==================================
 1284                   * ===               ==================================
 1285                   * === ================================================
 1286                   
 1287                   
 1288                   
 1289                   
 1290                   * The voice_offsets describe the number of bytes betwe
 1291                   * first byte of voice 0's data and the first byte of v
 1292                   
 1293 1387:00           voice_offsets	.by 0
 1294                   
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   60
                        6502:src/hmusic.src             07:11:20  

 1295      TRUE         	#if HMUSIC_CHANNELCOUNT > 1
 1296 1388:00           		.by voice1-voice0
 1297      TRUE         	 #if HMUSIC_CHANNELCOUNT > 2
 1298 1389:00           		.by voice2-voice0
 1299      TRUE         	  #if HMUSIC_CHANNELCOUNT > 3
 1300 138A:00           		.by voice3-voice0
 1301                   	  #endif ; > 3
 1302                   	 #endif ; > 2
 1303                   	#endif ; > 1
 1304                   
 1305                   
 1306                   
 1307                   
 1308                   * NOTE:  =============================================
 1309                   * NOTE:  The position of the following note arrays is 
 1310                   * NOTE:  of the above code depends on the exact arrang
 1311                   * NOTE:  You would have to be mad to rearrange this st
 1312                   
 1313 138B:08           clear_voice	.by $08		; Attack  keyframe  shifter   acc
 1314 138C:0C           		.by $0c		; Attack  keyframe  volume    accumulator
 1315 138D:0E           		.by $0e		; Attack  keyframe  frequency interpolator
 1316 138E:10           		.by $10		; Attack  keyframe  feedback  interpolator
 1317 138F:18           		.by $18		; Decay   keyframe  frequency interpolator
 1318 1390:1A           		.by $1a		; Decay   keyframe  feedback  interpolator
 1319 1391:22           		.by $22		; Sustain keyframe  frequency interpolator
 1320 1392:24           		.by $24		; Sustain keyframe  feedback  interpolator
 1321 1393:26           		.by $26		; Sustain keyframe  volume    interpolator
 1322 1394:2C           		.by $2c		; Release keyframe  frequency interpolator
 1323 1395:2E           		.by $2e		; Release keyframe  feedback  interpolator
 1324 1396:             clear_voice_end
 1325                   
 1326                   
 1327                   * ----- HSFX flag sets ----- *
 1328                   
 1329      0F00         ALL_ACCUM	.EQU	FREQ_ACCUM+SHIFT_ACCUM+FBACK_ACCUM+VOL_
 1330      00B0         INTERP		.EQU	FREQ_INTERP+FBACK_INTERP+VOL_INTERP
 1331                   
 1332 1396:             voice0		; --- Voice 0 --------------------------------
 1333 1396:6A 00        		.wo HMUSIC_DEFAULT_PRIORITY+{{HMUSIC_CHANNELCOUNT-1}
 1334 1398:00 00        attackframe_v0	.wo 0		; === Time to start attack
 1335 139A:B0 0F        		.wo ALL_ACCUM+INTERP
 1336 139C:00 00        attackfreq_v0	.wo 0		; Frequency accumulator
 1337 139E:00 00        		.wo 0		; Shifter accumulator
 1338 13A0:00 00        		.wo 0		; Feedback accumulator
 1339 13A2:00 00        		.wo 0		; Volume accumulator
 1340 13A4:00 00        		.wo 0		; Frequency interpolation
 1341 13A6:00 00        		.wo 0		; Feedback interpolation
 1342 13A8:00 00        		.wo 0		; Volume interpolation
 1343 13AA:01 00        decayframe_v0	.wo 1		; === Time to start decay
 1344 13AC:B0 00        		.wo INTERP
 1345 13AE:00 00        		.wo 0		; Frequency interpolation
 1346 13B0:00 00        		.wo 0		; Feedback interpolation
 1347 13B2:00 00        		.wo 0		; Volume interpolation
 1348 13B4:01 00        sustainframe_v0	.wo 1		; === Time to start sustain
 1349 13B6:B0 00        		.wo INTERP
 1350 13B8:00 00        		.wo 0		; Frequency interpolation
 1351 13BA:00 00        		.wo 0		; Feedback interpolation
 1352 13BC:00 00        		.wo 0		; Volume interpolation
 1353 13BE:01 00        releaseframe_v0	.wo 1		; === Time to start release
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   61
                        6502:src/hmusic.src             07:11:20  

 1354 13C0:B0 00        		.wo INTERP
 1355 13C2:00 00        		.wo 0		; Frequency interpolation
 1356 13C4:00 00        		.wo 0		; Feedback interpolation
 1357 13C6:00 00        		.wo 0		; Volume interpolation
 1358 13C8:01 00        endframe_v0	.wo 1		; End release & end effect
 1359 13CA:01 00        		.wo END_OF_EFFECT
 1360 13CC:             voice1		; --- Voice 1 --------------------------------
 1361      TRUE         	#IF HMUSIC_CHANNELCOUNT > 1
 1362 13CC:68 00        		.wo HMUSIC_DEFAULT_PRIORITY+{{HMUSIC_CHANNELCOUNT-2}
 1363 13CE:00 00        attackframe_v1	.wo 0		; === Time to start attack
 1364 13D0:B0 0F        		.wo ALL_ACCUM+INTERP
 1365 13D2:00 00        		.wo 0		; Frequency accumulator
 1366 13D4:00 00        		.wo 0		; Shifter accumulator
 1367 13D6:00 00        		.wo 0		; Feedback accumulator
 1368 13D8:00 00        		.wo 0		; Volume accumulator
 1369 13DA:00 00        		.wo 0		; Frequency interpolation
 1370 13DC:00 00        		.wo 0		; Feedback interpolation
 1371 13DE:00 00        		.wo 0		; Volume interpolation
 1372 13E0:01 00        decayframe_v1	.wo 1		; === Time to start decay
 1373 13E2:B0 00        		.wo INTERP
 1374 13E4:00 00        		.wo 0		; Frequency interpolation
 1375 13E6:00 00        		.wo 0		; Feedback interpolation
 1376 13E8:00 00        		.wo 0		; Volume interpolation
 1377 13EA:01 00        sustainframe_v1	.wo 1		; === Time to start sustain
 1378 13EC:B0 00        		.wo INTERP
 1379 13EE:00 00        		.wo 0		; Frequency interpolation
 1380 13F0:00 00        		.wo 0		; Feedback interpolation
 1381 13F2:00 00        		.wo 0		; Volume interpolation
 1382 13F4:01 00        releaseframe_v1	.wo 1		; === Time to start release
 1383 13F6:B0 00        		.wo INTERP
 1384 13F8:00 00        		.wo 0		; Frequency interpolation
 1385 13FA:00 00        		.wo 0		; Feedback interpolation
 1386 13FC:00 00        		.wo 0		; Volume interpolation
 1387 13FE:01 00        endframe_v1	.wo 1		; End release & end effect
 1388 1400:01 00        		.wo END_OF_EFFECT
 1389                   	#ENDIF ; of #IF HMUSIC_CHANNELCOUNT > 1
 1390 1402:             voice2		; --- Voice 2 --------------------------------
 1391      TRUE         	#IF HMUSIC_CHANNELCOUNT > 2
 1392 1402:66 00        		.wo HMUSIC_DEFAULT_PRIORITY+{{HMUSIC_CHANNELCOUNT-3}
 1393 1404:00 00        attackframe_v2	.wo 0		; === Time to start attack
 1394 1406:B0 0F        		.wo ALL_ACCUM+INTERP
 1395 1408:00 00        		.wo 0		; Frequency accumulator
 1396 140A:00 00        		.wo 0		; Shifter accumulator
 1397 140C:00 00        		.wo 0		; Feedback accumulator
 1398 140E:00 00        		.wo 0		; Volume accumulator
 1399 1410:00 00        		.wo 0		; Frequency interpolation
 1400 1412:00 00        		.wo 0		; Feedback interpolation
 1401 1414:00 00        		.wo 0		; Volume interpolation
 1402 1416:01 00        decayframe_v2	.wo 1		; === Time to start decay
 1403 1418:B0 00        		.wo INTERP
 1404 141A:00 00        		.wo 0		; Frequency interpolation
 1405 141C:00 00        		.wo 0		; Feedback interpolation
 1406 141E:00 00        		.wo 0		; Volume interpolation
 1407 1420:01 00        sustainframe_v2	.wo 1		; === Time to start sustain
 1408 1422:B0 00        		.wo INTERP
 1409 1424:00 00        		.wo 0		; Frequency interpolation
 1410 1426:00 00        		.wo 0		; Feedback interpolation
 1411 1428:00 00        		.wo 0		; Volume interpolation
 1412 142A:01 00        releaseframe_v2	.wo 1		; === Time to start release
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   62
                        6502:src/hmusic.src             07:11:20  

 1413 142C:B0 00        		.wo INTERP
 1414 142E:00 00        		.wo 0		; Frequency interpolation
 1415 1430:00 00        		.wo 0		; Feedback interpolation
 1416 1432:00 00        		.wo 0		; Volume interpolation
 1417 1434:01 00        endframe_v2	.wo 1		; End release & end effect
 1418 1436:01 00        		.wo END_OF_EFFECT
 1419                   	#ENDIF ; of #IF HMUSIC_CHANNELCOUNT > 2
 1420 1438:             voice3		; --- Voice 3 --------------------------------
 1421      TRUE         	#IF HMUSIC_CHANNELCOUNT > 3
 1422 1438:64 00        		.wo HMUSIC_DEFAULT_PRIORITY+{{HMUSIC_CHANNELCOUNT-4}
 1423 143A:00 00        attackframe_v3	.wo 0		; === Time to start attack
 1424 143C:B0 0F        		.wo ALL_ACCUM+INTERP
 1425 143E:00 00        		.wo 0		; Frequency accumulator
 1426 1440:00 00        		.wo 0		; Shifter accumulator
 1427 1442:00 00        		.wo 0		; Feedback accumulator
 1428 1444:00 00        		.wo 0		; Volume accumulator
 1429 1446:00 00        		.wo 0		; Frequency interpolation
 1430 1448:00 00        		.wo 0		; Feedback interpolation
 1431 144A:00 00        		.wo 0		; Volume interpolation
 1432 144C:01 00        decayframe_v3	.wo 1		; === Time to start decay
 1433 144E:B0 00        		.wo INTERP
 1434 1450:00 00        		.wo 0		; Frequency interpolation
 1435 1452:00 00        		.wo 0		; Feedback interpolation
 1436 1454:00 00        		.wo 0		; Volume interpolation
 1437 1456:01 00        sustainframe_v3	.wo 1		; === Time to start sustain
 1438 1458:B0 00        		.wo INTERP
 1439 145A:00 00        		.wo 0		; Frequency interpolation
 1440 145C:00 00        		.wo 0		; Feedback interpolation
 1441 145E:00 00        		.wo 0		; Volume interpolation
 1442 1460:01 00        releaseframe_v3	.wo 1		; === Time to start release
 1443 1462:B0 00        		.wo INTERP
 1444 1464:00 00        		.wo 0		; Frequency interpolation
 1445 1466:00 00        		.wo 0		; Feedback interpolation
 1446 1468:00 00        		.wo 0		; Volume interpolation
 1447 146A:01 00        endframe_v3	.wo 1		; End release & end effect
 1448 146C:01 00        		.wo END_OF_EFFECT
 1449                   	#ENDIF ; of #IF HMUSIC_CHANNELCOUNT > 3
 1450                   * NOTE:  The position of the above note arrays is very
 1451                   * NOTE:  =============================================
 1452                   
 1453                   
 1454                   
 1455                   
 1346                   ;	.in 6502:src/sprite.src
 1347                   ;	.in 6502:src/controls.src
 1348                   	.in 6502:src/sys.src
    1                   ; Tue Sep 18 17:43:25 1990
    2                   * === sys.src ========================================
    3                   *
    4                   * General System Source Code  --  Handy Software
    5                   *
    6                   * Confidential and Proprietary
    7                   * Copyright (c) 1989,1990 Epyx, Inc.
    8                   *
    9                   * Date		Name		Description
   10                   * ---------	--------------	---------------------------
   11                   * 28-Mar-90	SHL		IRQ handler quick checks for serial I
   12                   *				if SERIALPORT_USER defined now.
   13                   * 22-Mar-90	SHL		IRQ handler only touches 1 IRQ at a t
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   63
                        6502:src/sys.src                07:11:20  

   14                   *				Individual handlers need not preserve X and A
   15                   *				IRQ handlers now required to PLX PLA RTI
   16                   *				instead of RTS
   17                   *				Renamed SafeIntRts to IntReturn, which now
   18                   *				does PLX PLA RTI
   19                   * 16-Mar-90	SHL		Modified BRK detect for 1 cycle impro
   20                   *				in the case of IRQ
   21                   * 15-Mar-90	SHL		Provided faster vector to Redeye inte
   22                   *				Serial interrupts now must PLX PLA RTI to
   23                   *				exit.
   24                   * 14-Mar-90	SHL		Added SafeIntRts
   25                   *				INITINT now vectors all IRQS to SafeIntRts
   26                   *				instead of user supplied RTS
   27                   * 26-Feb-90	SHL		Minor code tightening
   28                   * 9-Feb-90	SHL		INITINT is now required before any use
   29                   *				INITEOF, INITEOL or SET_DISPLAY... macros
   30                   *				This file can now be included before user
   31                   *				calls INITINT
   32                   * 7-Feb-90	SHL		Modified BRK_USER to force Howard Brea
   33                   * 31 May 89	-RJ		Added BRK_USER support code to UserIn
   34                   *				Removed InitSys routine
   35                   * 6 Apr 89	=RJ Mical=	Created this file!
   36                   *
   37                   * ====================================================
   38                   
   39                   
   40                   * This code is called whenever a non-NMI interrupt occ
   41                   * interrupt or execution of a software BRK).
   42                   
   43 146E:             UserIntHandler
   44 146E:48           		PHA
   45 146F:DA           		PHX
   46                   
   47      FALSE        	  #IFDEF BRK_USER
   57                   	  #ENDIF ; of #IFDEF BRK_USER
   58                   
   59 1470:             hardInt
   60                   		;------	We had a hardware interrupt.
   61                   		;------	Get the interrupt flags value, reset the bit
   62 1470:AD 81 FD     		LDA INTSET		; This gets the bits
   63                   
   64      FALSE        	  #IFDEF SERIALPORT_USER
   68                   	  #ENDIF
   69                   
   70 1473:8D 93 0B     .02		STA INTSET_RAM
   71                   
   72                   		;------	For least set bit in the interrupt value,
   73                   		;------	vector to the routine
   74 1476:A2 00        		LDX #0
   75 1478:A9 01        		lda #1
   76 147A:2C 93 0B     .00		  bit INTSET_RAM
   77 147D:D0 **        		  bne jumpIntTable
   78 147F:E8           		  INX
   79 1480:E8           		  INX
   80 1481:0A           		  asl a
   81 1482:D0 F6        		 bne .00
   82 1484:             IntReturn
   83                   		;------	At end of interrupt processing, restore the
   84                   		;------	registers and return from interrupt
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   64
                        6502:src/sys.src                07:11:20  

   85                   
   86 1484:FA           		PLX
   87 1485:68           		PLA
   88 1486:40           		RTI
   89                   
   90                   
   91                   
   92                   
   93                   * The above interrupt dispatcher does a JSR to this li
   94                   * This code jumps to the particular handler.  The inte
   95                   * should end with an RTS, which will return control to
   96                   
   97 1487:             jumpIntTable
   98 1487:8D 80 FD     		sta INTRST	; clear interrupt we're processing
   99 148A:7C ** **     		JMP	(sysIntTable,X)
  100                   
  101                   
  102      FALSE        	  #IFDEF BRK_USER
  108                   	  #ENDIF ; of #IFDEF BRK_USER
  109                   
  110                   
  111                   
 1349                   	.in 6502:src/display.src
    1                   ; Tue Sep 18 17:51:17 1990
    2                   * === display.src ====================================
    3                   *
    4                   * Display and Color IO Routines --  the 6502 Side of H
    5                   *
    6                   * Copyright (C) 1988,1989,1990 Epyx, Inc.
    7                   * All Rights Reserved
    8                   * CONFIDENTIAL and PROPRIETARY
    9                   *
   10                   * Date		Name		Description
   11                   * ---------	--------------	---------------------------
   12                   * 18-Sep-90	SHL		Added code to work around RICOH bug
   13                   *				and support for the NO_RICOH_PATCH switch
   14                   * 22-Mar-90	SHL		Removed PHA PHX and PLX PLA from IRQ 
   15                   * 20-Mar-90	SHL		Removed SEI, CLI from InitDisplayer, 
   16                   *				InitEOL
   17                   * 7-Feb-90	SHL		Apple compatibility removed
   18                   *				TIMEOUT macro moved to display.mac
   19                   *				General cleanup and prettification
   20                   * 3 July 89	-RJ		The RESET_TIMEOUT logic is moved from
   21                   *				input macros to the TIMEOUT macro here
   22                   * 16 Jun 89	Peter Engelbrite Timeout constant set to 1
   23                   * 24 May 89	-RJ		Added AUTO_TIMEOUT_USER support code
   24                   * 1 May 89	-RJ		Changed all IntTable references to sys
   25                   *				which is defined now in the sys.mac file
   26                   * 20 Apr 89	-RJ		Changed DisplayFrameCount so that it'
   27                   *				included and incremented if FRAMECOUNT_UP is
   28                   *				defined, included and decremented if
   29                   *				FRAMECOUNT_DOWN is defined, else nothing.
   30                   *				Moved DisplayFrameCount to this file.
   31                   * 20 Mar 89	-RJ		Added increment of DisplayFrameCount 
   32                   *				handler that's included for EOF_USER's
   33                   * 13 Feb 89	-RJ		Added InitDisplayer routine.  Added i
   34                   *				of DISPLAY to normal EOF handler (FrameEnd).
   35                   * 12 Feb 89	-RJ		EOF and EOL code save and restore A
   36                   * 26-Dec-88	-RJ		Added EOL code
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   65
                        6502:src/display.src            07:11:20  

   37                   * 23-Dec-88	-RJ		Added EOF code
   38                   * Early 88	=RJ Mical=	Created this file!
   39                   *
   40                   * ====================================================
   41                   
   42                   
   43                   
   44                   * If either FRAMECOUNT_UP or _DOWN is defined, then de
   45      TRUE         	#IFDEF	FRAMECOUNT_UP | FRAMECOUNT_DOWN
   46 148D:             DisplayFrameCount	.DS	1
   47                   	#ENDIF
   48                   
   49                   
   50      TRUE         	#IFDEF EOF_USER
   51                   * - - - - - - - - - - - - -  - - - - - - - - - - - - -
   52                   * - - - - - - - - - - - - -  - - - - - - - - - - - - -
   53                   * - - - - - - - - - - - - -  - - - - - - - - - - - - -
   54                   	;------	If an EOF user, create the elaborate version 
   55                   	;------	end-of-frame handler
   56                   
   57 148E:             InitEOF
   58                   		;------	Copy old vector into our exit JMP instructio
   59 148E:AD ** **     		LDA	sysIntTable+{2*2}
   60 1491:8D ** **     		STA	FrameEndExit+1
   61 1494:AD ** **     		LDA	sysIntTable+{2*2}+1
   62 1497:8D ** **     		STA	FrameEndExit+2
   63                   		;------	Install our vector into the interrupt table
   64 149A:A9 **        		LDA	#<FrameEnd
   65 149C:8D ** **     		STA	sysIntTable+{2*2}
   66 149F:A9 **        		LDA	#>FrameEnd
   67 14A1:8D ** **     		STA	sysIntTable+{2*2}+1
   68 14A4:60           		RTS
   69                   
   70 14A5:             FrameEnd
   71                   * End-of-Frame handler
   72 14A5:5A           		PHY
   73                   
   74                   		;------	The TIMEOUT macro will do nothing unless
   75                   		;------ AUTO_TIMEOUT_USER has been defined in which 
   76                   		;------	system will turn off after a given amount of
   77      TRUE         	  #IFNDEF NO_RICOH_PATCH
   78 14A6:AD F9 FF     		lda MAPCTL
   79 14A9:48           		pha
   80 14AA:09 01        		 ora #SUZY_SPACE
   81 14AC:8D F9 FF     		 sta MAPCTL
   82                   		 TIMEOUT
    1                 + 
   83 14AF:68           		pla
   84 14B0:8D F9 FF     		sta MAPCTL
   85                   	  #ELSE
   87                   	  #ENDIF ;NDEF NO_RICOH_PATCH
   88                   
   89                   		;------	Turn on the display, and then EOF flag
   90                   ;!!! New:  invoke the DISPLAY macro here during EOF pr
   91                   		DISPLAY
    1 14B3:AD 8C 0B   + 		LDA	DISPCTL_RAM
    2 14B6:8D 92 FD   + 		STA	DISPCTL
    3 14B9:29 02      + 		AND	#DISP_FLIP
    4 14BB:F0 **      + 		BEQ	DISPLAY.003B
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   66
                        6502:src/display.src            07:11:20  

    5 14BD:AD 91 0B   + 		LDA	DisplayBuffer
    6 14C0:18         + 		CLC
    7 14C1:69 DF      + 		ADC	#<DISPLAY_BUFSIZE-1
    8 14C3:AA         + 		TAX
    9 14C4:AD 92 0B   + 		LDA	DisplayBuffer+1
   10 14C7:69 1F      + 		ADC	#>DISPLAY_BUFSIZE-1
   11 14C9:80 **      + 		BRA	DISPLAY.003B2
   12 14CB:           + DISPLAY.003B
   13 14CB:AE 91 0B   + 		LDX	DisplayBuffer
   14 14CE:AD 92 0B   + 		LDA	DisplayBuffer+1
   15 14D1:           + DISPLAY.003B2
   16                   		DISP_AX
    1 14D1:08         + 		PHP
    2 14D2:78         + 		SEI
    3 14D3:8E 94 FD   + 		STX	DISPADRL
    4 14D6:8D 95 FD   + 		STA	DISPADRH
    5 14D9:28         + 		PLP
    6                 + 
   17                 + 
   92                   
   93      TRUE         	  #IFDEF FRAMECOUNT_UP
   94                   		;------	Increment the DisplayFrameCount
   95 14DA:EE 8D 14     		INC	DisplayFrameCount
   96                   	  #ELSE ; put this #ELSE here to avoid both UP and DO
  104                   	  #ENDIF
  105                   
  106 14DD:AD 94 0B     		LDA	DisplayFlags
  107 14E0:09 80        		ORA	#DISPLAY_EOFFLAG
  108 14E2:8D 94 0B     		STA	DisplayFlags
  109                   
  110 14E5:7A           		PLY
  111 14E6:             FrameEndExit
  112                   		;------	This vector ought to be patched by the Init 
  113 14E6:4C 84 14     		JMP	IntReturn
  114                   
  115                   
  116                   	#ELSE ; of #IFDEF EOF_USER
  160                   	#ENDIF	; of #IFDEF EOF_USER
  161                   
  162                   * - - - - - - - - - - - - -  - - - - - - - - - - - - -
  163                   
  164                   
  165                   
  166                   
  167      FALSE        	#IFDEF	EOL_USER
  192                   	#ENDIF	; of #IFDEF EOL_USER
  193                   
  194                   
  195                   
  196                   
 1350                   	.in 6502:src/cart.src
    1                   ; Wednesday 18-Apr-90 08:45:32
    2                   * === cart.src =======================================
    3                   * 
    4                   * Game Cartridge I/O Routines  --  Handy Software
    5                   * 
    6                   * Confidential and Proprietary
    7                   * Copyright (C) 1989, Epyx, Inc.
    8                   * 
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   67
                        6502:src/cart.src               07:11:20  

    9                   * Date		Name		Description
   10                   * ---------	-------------	----------------------------
   11                   * 11-Apr-90	SHL		Code optimized for size and speed
   12                   *				Registers for OpenFile0 and SetCartAddress
   13                   *				arguments changed: A = cartridge page,
   14                   *				X,Y = byte offset into page
   15                   *				SetCartPage now takes argument in A reg
   16                   *				GetDirAddress routine rewritten, returns
   17                   *				arguments as expected for OPENFILE routine
   18                   *				GetDirAddressFast routine removed
   19                   *
   20                   * 26-Feb-90	SHL		Removed all references to WRITECART_U
   21                   *				Minor code tightening
   22                   * 14-Feb-90	SHL		Fixed a horrible error that turns off
   23                   *				during file reads that cross page boundaries
   24                   * 7-Feb-90	SHL		Minor math touch-up work (slightly spe
   25                   * 7-Feb-90	SHL		Fixed bug in math usage in GetDirAddre
   26                   * 1 June 89	-RJ		Vectored RESTORE_CART usage to a subr
   27                   * 15 May 89	-RJ		Made SetCartOffset use of RCART_1 int
   28                   * 20 Apr 89	=RJ Mical=	Created this file!
   29                   * 
   30                   * ====================================================
   31                   
   32                   
   33                   
   34 14E9:             CartOffsetLow	.DS	1
   35      TRUE          #IF ROMPAGESIZE>256
   36 14EA:             CartOffsetHigh	.DS	1
   37                    #ENDIF
   38 14EB:             CartPage	.DS	1
   39 14EC:             CartIOCount	.DS	2
   40      TRUE         	#IFNDEF	ROM_NODIR
   41 14EE:             CartDirectory	.DS	ROMDIR_ENTRY_SIZE
   42                   	#ENDIF
   43                   
   44                   
   45                   
   46      TRUE         	#IFNDEF	ROM_NODIR
   47                   
   48 14F6:             OpenFile0
   49                   * ****************************************************
   50                   * OpenFile0 "opens" a file by reading its directory en
   51                   * CartDirectory buffer and then setting the hardware r
   52                   * first data byte.  On entry, the cartridge address of
   53                   * is specified with the page in X and the offset in A,
   54                   * 
   55                   * ON ENTRY:
   56                   *     - A has the cartridge page of the file's directo
   57                   *     - X,Y (low,high) has the offset of the file's di
   58                   * 
   59                   * ON EXIT:
   60                   *     - A, X and Y are trashed
   61                   *     - CartPage and CartOffsetLow,High are set
   62                   *     - CartDirectory contains the a copy of the file'
   63                   *     - The cart hardware is ready to read the first b
   64                   
   65                   		;------	Set up address of the directory specified by
   66 14F6:20 ** **     		JSR SetCartAddress
   67                   
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   68
                        6502:src/cart.src               07:11:20  

   68                   		;------	Read the directory
   69 14F9:A9 09        		LDA #<{ROMDIR_ENTRY_SIZE+1}
   70 14FB:8D EC 14     		STA CartIOCount
   71 14FE:A9 01        		LDA #>{ROMDIR_ENTRY_SIZE+$100}
   72 1500:8D ED 14     		STA CartIOCount+1
   73 1503:A9 EE        		LDA #<CartDirectory
   74 1505:85 00        		STA sysptr
   75 1507:A9 14        		LDA #>CartDirectory
   76 1509:85 01        		STA sysptr+1
   77 150B:20 ** **     		JSR readCart0Grunt
   78                   
   79                   		;------	Set up to read the first byte of the file
   80 150E:AD EE 14     		LDA CartDirectory+ROMDIR_PAGE
   81 1511:AE EF 14     		LDX CartDirectory+ROMDIR_OFFSET
   82      TRUE          #IF ROMPAGESIZE>256
   83 1514:AC F0 14     		LDY CartDirectory+ROMDIR_OFFSET+1
   84                    #ENDIF
   85                   
   86                   * ... and fall into SetCartAddress
   87                   
   88                   	#ENDIF	; of #IFNDEF ROM_NODIR
   89                   
   90                   
   91                   
   92 1517:             SetCartAddress
   93                   * ****************************************************
   94                   * This routine sets the cartridge ports to be ready to
   95                   * byte addressed by the page in X and the offset in A,
   96                   * 
   97                   * WARNING:  this routine is fallen into from above.
   98                   * 
   99                   * ON ENTRY:
  100                   *     - X has the page of the cartridge address
  101                   *     - A,Y (low,high) has the offset of the address
  102                   * 
  103                   * ON EXIT:
  104                   *     - A, X and Y are trashed
  105                   *     - CartPage and CartOffsetLow,High are set
  106                   *     - The cart hardware is ready to read the first b
  107                   
  108 1517:8D EB 14     		STA CartPage	; Save the cartridge 1 values
  109 151A:8E E9 14     		STX CartOffsetLow
  110      TRUE          #IF ROMPAGESIZE>256
  111 151D:8C EA 14     		STY CartOffsetHigh
  112                    #ENDIF
  113                   
  114 1520:20 ** **     		JSR SetCartPage
  115                   
  116                   * ... and fall into SetCartOffset to advance the cartr
  117                   * the desired offset
  118                   
  119                   
  120                   
  121 1523:             SetCartOffset
  122                   * ****************************************************
  123                   * This routine reads the cartridge (using port 0) unti
  124                   * advanced to the byte described by CartOffsetLow,High
  125                   * is currently at offset 0.  
  126                   * 
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   69
                        6502:src/cart.src               07:11:20  

  127                   * NOTE:  this code fallen into from above
  128                   * 
  129                   * ON ENTRY:
  130                   *     - CartOffsetLow,High has the offset
  131                   *     - Cart hardware is set to read byte 0 of the pag
  132                   * 
  133                   * ON EXIT:
  134                   *     - The cart hardware is advanced to the specified
  135                   
  136 1523:AC EA 14     	ldy CartOffsetHigh	; get desired offset
  137 1526:AE E9 14     	ldx CartOffsetLow
  138 1529:C8           	iny			; increment for zero checking
  139 152A:E8           	inx
  140 152B:80 **        	bra .10
  141                   
  142 152D:AD B2 FC     .20	    lda RCART_0		; count off bytes to advance cart
  143 1530:CA           .10	    dex
  144 1531:D0 FA        	   bne .20
  145 1533:88           .30	  dey
  146 1534:D0 F7        	 bne .20
  147                   
  148                   ;	jmp RestoreReturn	; fall through
  149                   
  150 1536:             RestoreReturn
  151                   	RESTORE_CART
    1 1536:AD 8D 0B   + 		LDA IODAT_RAM
    2      FALSE        	  #IFDEF RAMCART_USER
    4                 + 	  #ELSE
    5 1539:09 02      + 		ORA #CART_POWER_OFF	
    6                 + 	  #ENDIF
    7 153B:8D 8D 0B   + 		STA IODAT_RAM
    8 153E:8D 8B FD   + 		STA IODAT
    9                 + 
  152 1541:60           	rts
  153                   
  154                   
  155                   
  156      TRUE         	#IFNDEF	ROM_NODIR
  157                   
  158 1542:             ReadFile0
  159                   * ****************************************************
  160                   * This routine will read an entire game cartridge file
  161                   * that the cartridge 0 port is all set up to start rea
  162                   * that sysptr points to the directory entry of the fil
  163                   * CartDirectory buffer is filled out, and that CartPag
  164                   * CartOffsetLow,High reflect the state of port 0.  
  165                   * 
  166                   * ON ENTRY:
  167                   *    - If you have specified that the file directory h
  168                   *      which specifies that the directory has a RAM de
  169                   *         If the A register is non-zero, X,Y (low,high
  170                   *         the RAM destination for the file; if A is ze
  171                   *         destination is taken from the directory entr
  172                   *    - If you have not specified that the file directo
  173                   *      field you must specify RAM destination of the f
  174                   *         X,Y (low,high) has the RAM destination for t
  175                   *    - The cartridge 0 port is all set up to read the 
  176                   * 
  177                   * ON EXIT:
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   70
                        6502:src/cart.src               07:11:20  

  178                   *    - CartPage and CartOffsetLow,High are advanced to
  179                   *      the last byte read
  180                   *    - X,Y (low,high) has RAM address of the byte beyo
  181                   
  182                   
  183                   ;??? For now, presume that all data will be coming fro
  184                   ;??? entry.  Later, it will come from either there or 
  185                   ;??? list if the programmer is willing to burn the byt
  186                   
  187      TRUE         	#IFDEF	ROMDIR_DEST
  188 1542:C9 01        	cmp #1
  189 1544:B0 **        	bcs .30
  190 1546:AE F2 14     	ldx CartDirectory+ROMDIR_DEST	; get RAM destination f
  191 1549:AC F3 14     	ldy CartDirectory+ROMDIR_DEST+1
  192                   	#ENDIF
  193                   
  194 154C:AD F5 14     .30	lda CartDirectory+ROMDIR_SIZE+1	; set up count of 
  195 154F:1A           	ina
  196 1550:8D ED 14     	sta CartIOCount+1
  197 1553:AD F4 14     	lda CartDirectory+ROMDIR_SIZE
  198 1556:1A           	ina
  199 1557:8D EC 14     	sta CartIOCount
  200                   
  201 155A:86 00        	STX sysptr		; X,Y has the RAM destination pointer
  202 155C:84 01        	STY sysptr+1
  203                   
  204                   ;	jmp readCart0Grunt	; fall through
  205                   
  206                   
  207                   	#ENDIF	; of #IFNDEF ROM_NODIR
  208                   
  209                   
  210                   
  211 155E:             readCart0Grunt
  212                   * ****************************************************
  213                   * Grunt routine used by several cart-reading routines,
  214                   * have been tended to and everything is ready for the 
  215                   * 
  216                   * ON ENTRY:
  217                   *    - CartIOCount is initialized to number of bytes t
  218                   *      byte incremented once (for instance: to read $0
  219                   *      CartIOCount to $0224, to read $04ff bytes set C
  220                   *    - sysptr points to buffer for incoming data
  221                   *    - CartOffsetLow,High and CartPage to have valid n
  222                   * 
  223                   * ON EXIT:
  224                   *    - CartPage and CartOffsetLow,High are advanced to
  225                   *      the last byte read
  226                   *    - X,Y (low,high) have RAM address of the byte bey
  227                   
  228                   	SET_TO_READ_CART
    1 155E:AD 8D 0B   + 		LDA	IODAT_RAM
    2 1561:29 FD      + 		AND	#~CART_POWER_OFF 
    3      FALSE        	  #IFDEF RAMCART_USER
    5                 + 	  #ENDIF
    6 1563:8D 8D 0B   + 		STA	IODAT_RAM
    7 1566:8D 8B FD   + 		STA	IODAT
    8                 + 
  229                   
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   71
                        6502:src/cart.src               07:11:20  

  230 1569:AE E9 14     	ldx CartOffsetLow	; ROMPAGESIZE is assumed to be mult
  231      TRUE          #IF ROMPAGESIZE>256
  232 156C:38           	sec			; set Y to complement of CartOffsetHigh
  233 156D:AD EA 14     	lda CartOffsetHigh	;  to facilitate bounds checking
  234 1570:E9 04        	sbc #>ROMPAGESIZE
  235 1572:A8           	tay
  236                    #ENDIF
  237                   
  238 1573:CE EC 14     .30	      dec CartIOCount	; count down bytes to read
  239 1576:F0 **        	      beq .31
  240 1578:AD B2 FC     .32	      LDA RCART_0	; read and store byte
  241 157B:92 00        	      STA (sysptr)
  242 157D:E6 00        	      inc sysptr
  243 157F:F0 **        	      beq .44
  244                   
  245 1581:E8           .33	      inx		; bump the cart page counters
  246 1582:D0 EF        	     BNE .30
  247      TRUE          #IF ROMPAGESIZE>256
  248 1584:C8           	    iny
  249 1585:D0 EC        	   BNE .30
  250                    #ENDIF
  251                   
  252 1587:EE EB 14     	  inc CartPage		; get next page from cartridge
  253 158A:AD EB 14     	  lda CartPage
  254 158D:20 ** **     	  JSR SetCartPage
  255                   
  256 1590:A2 00        	  ldx #<{-ROMPAGESIZE}	; set count to read whole page
  257      TRUE          #IF ROMPAGESIZE>256
  258 1592:A0 FC        	  ldy #>{-ROMPAGESIZE}
  259                    #ENDIF
  260 1594:80 DD        	 BRA .30
  261                   
  262 1596:E6 01        .44	      INC sysptr+1	; not done frequently so pulled
  263 1598:80 E7        	      bra .33
  264                   
  265                   
  266 159A:CE ED 14     .31	      dec CartIOCount+1	; check to see if load is 
  267 159D:D0 D9        	      bne .32		; if not, get back in there
  268                   
  269 159F:8E E9 14     .80	stx CartOffsetLow	; ROMPAGESIZE is assumed to be m
  270      TRUE          #IF ROMPAGESIZE>256
  271 15A2:18           	clc			; restore true offset value
  272 15A3:98           	tya
  273 15A4:69 04        	ADC #>ROMPAGESIZE
  274 15A6:8D EA 14     	STA CartOffsetHigh
  275                    #ENDIF
  276                   
  277 15A9:A6 00        	ldx sysptr
  278 15AB:A4 01        	ldy sysptr+1
  279                   
  280 15AD:4C 36 15     	jmp RestoreReturn	; only affects A register
  281                   
  282                   
  283                   
  284                   * ****************************************************
  285                   * SetCartPage strobes the cartridge page number in A i
  286                   * The result of this also leaves the counter reset to 
  287                   *
  288                   * On return, A, X and Y are trashed, and ROM power is 
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   72
                        6502:src/cart.src               07:11:20  

  289                   
  290 15B0:             SetCartPage
  291 15B0:8D ** **     	sta .ff
  292                   
  293 15B3:AD 8D 0B     	lda IODAT_RAM
  294 15B6:09 0A        	ora #RESTLESS+CART_ADDR_DATA
  295 15B8:A8           	tay
  296 15B9:29 FD        	and #~CART_ADDR_DATA
  297                   
  298 15BB:38           	sec
  299 15BC:80 **        	bra .2
  300 15BE:90 **        .0	  bcc .1
  301 15C0:8C 8B FD     	  sty IODAT	; set CART_ADDR_DATA to clock in 1 bit
  302 15C3:18           	  clc
  303 15C4:E8           .1	  inx		; ldx #3, adds in CART_ADDR_STROBE
  304 15C5:8E 87 FD     	  stx SYSCTL1
  305 15C8:A2 02        .2	  ldx #POWERON
  306 15CA:8E 87 FD     	  stx SYSCTL1
  307 15CD:2E ** **     	  rol .ff
  308 15D0:8D 8B FD     	  sta IODAT	; reset CART_ADDR_DATA to clock 0 bit and
  309 15D3:D0 E9        	 bne .0
  310                   
  311 15D5:60           	rts
  312                   
  313 15D6:00           .ff	.BY 0
  314                   
  315                   
  316                   
  317                   
  318                   ;	#IFDEF	GETDIR_USER
  319                   ;
  320                   ;GetDirAddress
  321                   ;* ***************************************************
  322                   ;
  323                   ;		;------	Get copy of file number
  324                   ;		TAY
  325                   ;		INY	; Increment it so we can count down to zero
  326                   ;
  327                   ;		;------	Init the result fields to the file 0 entry
  328                   ;		LDX	#ROMDIR_FILE0_PAGE	; X will keep the page
  329                   ;		LDA	#<ROMDIR_FILE0_OFFSET
  330                   ;		STA	.FE
  331                   ;		LDA	#>ROMDIR_FILE0_OFFSET
  332                   ;		STA	.FF
  333                   ;
  334                   ;.10		;------	Loop until file number is reduced to zer
  335                   ;		DEY
  336                   ;		BEQ	.20
  337                   ;
  338                   ;		;------	Add the size of an entry to the current car
  339                   ;		LDA	#ROMDIR_ENTRY_SIZE
  340                   ;		CLC
  341                   ;		ADC	.FE
  342                   ;		STA	.FE
  343                   ;	bcc .11
  344                   ;	inc .ff
  345                   ;;		LDA	#0
  346                   ;;		ADC	.FF
  347                   ;;		STA	.FF
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   73
                        6502:src/cart.src               07:11:20  

  348                   ;
  349                   ;		;------	Compare the current offset with the largest
  350                   ;		;------	allowable offset
  351                   ;.11		LDA	#<ROMPAGESIZE-1
  352                   ;		CMP	.FE
  353                   ;		LDA	#>ROMPAGESIZE-1
  354                   ;		SBC	.FF
  355                   ;		BCS	.10		; Branch if offset <= largest allowed
  356                   ;
  357                   ;		;------	Offset too big.  Back offset down by one pa
  358                   ;		;------	bump page
  359                   ;		LDA	.FE
  360                   ;		SEC
  361                   ;		SBC	#<ROMPAGESIZE
  362                   ;		STA	.FE
  363                   ;		LDA	.FF
  364                   ;		SBC	#>ROMPAGESIZE
  365                   ;		STA	.FF
  366                   ;		INX
  367                   ;		BRA	.10		; Go do it again
  368                   ;
  369                   ;.20		;------	Return with the registers containing the
  370                   ;		LDA	.FE
  371                   ;		LDY	.FF
  372                   ;		RTS
  373                   ;
  374                   ;.FE		.DS	1
  375                   ;.FF		.DS	1
  376                   ;
  377                   ;	#ENDIF	; of #IFDEF GETDIR_USER
  378                   ;
  379                   ;
  380                   ;	#IFDEF	GETDIRFAST_USER
  381                   ;
  382                   ;GetDirAddressFast
  383                   ;* ***************************************************
  384                   ;
  385                   ;		;------	Create the offset from the start of the dir
  386                   ;		;------	this directory entry
  387                   ;		STA MATHD
  388                   ;		STZ MATHC
  389                   ;		LDA #ROMDIR_ENTRY_SIZE
  390                   ;		STA MATHB
  391                   ;		STZ MATHA	; MULTIPLY
  392                   ;
  393                   ;		;------	Create the page of this entry by adding the
  394                   ;		;------	ROM header to the directory entry offset an
  395                   ;		;------	dividing this by the size of a page
  396                   ;		LDA	#<ROMPAGESIZE
  397                   ;		WAITMATH
  398                   ;		STA	MATHP
  399                   ;		LDA	#>ROMPAGESIZE
  400                   ;		STA	MATHN
  401                   ;		LDA	#<ROM_HEADER_SIZE
  402                   ;		CLC
  403                   ;		ADC	MATHH
  404                   ;		TAX
  405                   ;		LDA	#>ROM_HEADER_SIZE
  406                   ;		ADC	MATHG
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   74
                        6502:src/cart.src               07:11:20  

  407                   ;		STX	MATHH
  408                   ;		STA	MATHG
  409                   ;		LDA	#0
  410                   ;		ADC	MATHF
  411                   ;		STA	MATHF
  412                   ;		STZ	MATHE	; DIVIDE
  413                   ;
  414                   ;		;------	Create the byte offset of the entry by subt
  415                   ;		;------	start byte offset from the real byte offset
  416                   ;		;------	Wouldn't have to do this if division remain
  417                   ;		WAITMATH
  418                   ;		lda	MATHH
  419                   ;		ldy	MATHG
  420                   ;
  421                   ;		ldx	#<ROMPAGESIZE
  422                   ;		stx	MATHB
  423                   ;		ldx	#>ROMPAGESIZE
  424                   ;		stx	MATHA	; MULTIPLY
  425                   ;
  426                   ;		SEC
  427                   ;		WAITMATH
  428                   ;		SBC	MATHH
  429                   ;		TAX
  430                   ;		tya
  431                   ;		SBC	MATHG
  432                   ;		TAY
  433                   ;		TXA
  434                   ;		LDX	MATHD
  435                   ;
  436                   ;		RTS
  437                   ;
  438                   ;.FD		.DS	1
  439                   ;.FE		.DS	1
  440                   ;
  441                   ;	#ENDIF	; of #IFDEF GETDIRFAST_USER
  442                   
  443                   
  444      TRUE         	#IFDEF GETDIR_USER | GETDIRFAST_USER
  445                   
  446                   * GetDirAddress calculates the ROM address of the dire
  447                   * specified in the A register
  448                   *
  449                   * ROMPAGESIZE is assumed to be one of 256, 512, 1024, 
  450                   *
  451                   * On exit:
  452                   *	A = page number
  453                   *	X,Y = byte offset into page
  454                   
  455 15D7:             GetDirAddress
  456      TRUE           #IF ROMDIR_ENTRY_SIZE=8
  457 15D7:9C ** **     	stz .ff
  458 15DA:0A           	asl a
  459 15DB:2E ** **     	rol .ff
  460 15DE:0A           	asl a
  461 15DF:2E ** **     	rol .ff
  462 15E2:0A           	asl a
  463 15E3:2E ** **     	rol .ff
  464                     #ELSE
  473                     #ENDIF
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   75
                        6502:src/cart.src               07:11:20  

  474                   
  475      TRUE           #IF ROM_HEADER_SIZE&$ff>0
  476 15E6:69 9A        	adc #<ROM_HEADER_SIZE
  477                     #ENDIF
  478 15E8:AA           	tax
  479      TRUE           #IF ROMDIR_ENTRY_SIZE=8
  480 15E9:AD ** **     	lda .ff
  481                     #ELSE
  483                     #ENDIF
  484 15EC:69 01        	adc #>ROM_HEADER_SIZE
  485      TRUE           #IF ROMPAGESIZE>256
  486 15EE:48           	 pha
  487 15EF:29 03        	  and #>{ROMPAGESIZE-1}
  488 15F1:A8           	  tay
  489 15F2:68           	 pla
  490 15F3:4A           	lsr a
  491      TRUE             #IF ROMPAGESIZE>512
  492 15F4:4A           	lsr a
  493      FALSE              #IF ROMPAGESIZE>1024
  495                         #ENDIF
  496                       #ENDIF
  497                     #ENDIF
  498                   
  499 15F5:60           	rts
  500                   
  501      TRUE           #IF ROMDIR_ENTRY_SIZE=8
  502 15F6:             .ff	.ds 1
  503                     #ENDIF
  504                   
  505                   	#ENDIF	; of #IFDEF GETDIR_USER | GETDIRFAST_USER
  506                   
  507                   
  508                   
  509                   
  510                   
  511                   
 1351      0A6C         len.sys		.eq *-beg.sys
 1352                   
   36                   	BEGIN_ZPAGE
    1      15F7       + TEMPORG	  .= *
    2 15F7:           + 	  .ORG NEXTZPG
    3                 + 
   37                   ; user zero page variables (use .ds only)
   38 0027:             my.var1	.ds 10
   39                   	END_ZPAGE
    1      0031       + NEXTZPG	  .= *
    2      FALSE        	  #IF NEXTZPG > $0100
    4                 + 	  #ENDIF
    5 0031:           + 	  .ORG TEMPORG
    6                 + 
   40                   
   41                   ; "game.start" must be the entry point for the game
   42                   
   43 15F7:             game.start
   44 15F7:A9 **        	lda #normal.pal
   45 15F9:20 0E 08     	jsr set.colors		;fade up from black
   46 15FC:A9 1E        	lda #30
   47 15FE:85 0F        	sta hscroll		;position "window on the world"
   48 1600:A9 1E        	lda #30
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   76
                                                        07:11:20  

   49 1602:85 0D        	sta vscroll
   50 1604:A0 40        	ldy #$40		;start the music
   51 1606:A2 **        	ldx #>tune.1
   52 1608:A9 **        	lda #<tune.1
   53 160A:20 D7 07     	jsr start.tune
   54                   
   55 160D:A9 **        	lda #zapsnd		;make a sound on powerup
   56 160F:20 2F 0B     	jsr start.sound
   57 1612:A9 5E        	lda #64+30		;center the face
   58 1614:8D ** **     	sta face+SCB_HPOS
   59 1617:A9 3D        	lda #31+30
   60 1619:8D ** **     	sta face+SCB_VPOS
   61                   ; ---- MAIN GAME LOOP ----
   62                   ; example
   63 161C:             loop
   64 161C:A5 0C        	lda count		;this counts once per game frame
   65 161E:29 7F        	and #$7f
   66 1620:D0 **        	bne .01			;once in a while
   67 1622:A9 **        	lda #gulp
   68 1624:20 2F 0B     	jsr start.sound
   69 1627:A9 01        	lda #$01
   70 1629:20 54 0B     	jsr add.score
   71 162C:             .01
   72                   ; display sprites
   73 162C:A5 19        	lda level	;joystick/firebutton levels
   74 162E:89 40        	bit #JOY_UP
   75 1630:F0 **        	beq .02
   76 1632:CE ** **     	dec face+SCB_VPOS	;move the face around
   77 1635:             .02
   78 1635:89 80        	bit #JOY_DOWN
   79 1637:F0 **        	beq .03
   80 1639:EE ** **     	inc face+SCB_VPOS
   81 163C:             .03
   82 163C:89 10        	bit #JOY_LEFT
   83 163E:F0 **        	beq .04
   84 1640:CE ** **     	dec face+SCB_HPOS
   85 1643:             .04
   86 1643:89 20        	bit #JOY_RIGHT
   87 1645:F0 **        	beq .05
   88 1647:EE ** **     	inc face+SCB_HPOS
   89 164A:             .05
   90 164A:A5 1A        	lda edge	;joystick/firebutton leading edges
   91 164C:89 04        	bit #OPTION2_BUTTON
   92 164E:F0 **        	beq .06
   93 1650:A9 **        	lda #lazsnd
   94 1652:20 2F 0B     	jsr start.sound
   95 1655:A9 50        	lda #$50
   96 1657:20 54 0B     	jsr add.score
   97 165A:             .06
   98 165A:A2 **        	ldx #>blob
   99 165C:A0 **        	ldy #<blob
  100 165E:20 FE 04     	jsr do.sprite	;display a sprite
  101 1661:A2 **        	ldx #>face
  102 1663:A0 **        	ldy #<face
  103 1665:20 FE 04     	jsr do.sprite	;display a sprite
  104 1668:20 EC 04     	jsr game.frame	;wait for next game frame (& display s
  105 166B:80 AF        	bra loop
  106                   
  107                   
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   77
                                                        07:11:20  

  108 166D:             tune.1
  109 166D:0A7D         	.pc music.dnl
  110                   
  111                   
  112                   ; this is a table of pointers to color palettes
  113                   ; the first one must be all 0's
  114                   ; the game should supplly the palettes
  115                   
  116 20EA:             color.pnts
  117 20EA:00 ** ** **  	.wo all.black,pal1,pal2
  117      ** **        
  118                   
  119 20F0:             all.black
  120      0000         black.pal	.eq 0
  121                   ;green
  122 20F0:00 00 00 00  	.by $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$
  122      00 00 00 00  
  122      00 00 00 00  
  122      00 00 00 00  
  122                   
  123                   ;bluered
  124 2100:00 00 00 00  	.by $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$
  124      00 00 00 00  
  124      00 00 00 00  
  124      00 00 00 00  
  124                   
  125                   
  126 2110:             pal1
  127      0001         normal.pal	.eq 1
  128                   ; Handy Color Palette
  129                   ; Greens
  130 2110:00 07 05 03  	.BYTE	$00,$07,$05,$03,$00,$00,$0f,$00
  130      00 00 0F 00  
  130                   
  131 2118:00 02 03 06  	.BYTE	$00,$02,$03,$06,$0b,$00,$04,$07
  131      0B 00 04 07  
  131                   
  132                   ; Blues-Reds
  133                   
  134 2120:F0 06 00 00  	.BYTE	$f0,$06,$00,$00,$06,$0f,$0f,$f0
  134      06 0F 0F F0  
  134                   
  135 2128:00 04 28 6B  	.BYTE	$00,$04,$28,$6b,$cf,$6d,$00,$00
  135      CF 6D 00 00  
  135                   
  136 2130:             pal2
  137      0002         star.pal	.eq 2
  138                   ;greys (starfield)
  139                   ;green
  140 2130:00 06 00 00  	.by $00,$06,$00,$00,$00,$00,$0f,$00,$02,$04,$07,$0b,$
  140      00 00 0F 00  
  140      02 04 07 0B  
  140      0F 06 09 0F  
  140                   
  141                   ;bluered
  142 2140:00 F6 F0 90  	.by $00,$f6,$f0,$90,$0a,$0f,$0f,$f0,$22,$44,$77,$bb,$
  142      0A 0F 0F F0  
  142      22 44 77 BB  
  142      FF 00 00 00  
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   78
                                                        07:11:20  

  142                   
  143                   
  144                   
  145                   
  146                   ; name for sounds
  147      0000         small.bang	.eq 0
  148      0001         mid.bang	.eq 1
  149      0002         big.bang	.eq 2
  150      0003         shoot		.eq 3
  151      0004         boing		.eq 4
  152      0005         zapsnd		.eq 5
  153      0006         gulp		.eq 6
  154      0007         lazsnd		.eq 7
  155      0008         shieldsnd	.eq 8
  156      0009         elevsnd		.eq 9
  157      000A         boggle		.eq 10
  158      000B         transnd		.eq 11
  159      000C         whoosh		.eq 12
  160      000D         giggle		.eq 13
  161      000E         my.bang		.eq 14
  162                   
  163                   ; these are sound priorities
  164 2150:             sound.pri
  165 2150:65 67 69 5B  	.by 101,103,105,91,33,201,249,49,53
  165      21 C9 F9 31  
  165      35           
  166 2159:F7           	.by 247
  167 215A:39           	.by 57
  168 215B:FB           	.by 251
  169 215C:37           	.by 55
  170 215D:3D           	.by 61
  171 215E:FD           	.by 253
  172                   
  173                   ; pointers to sounds
  174 215F:             sound.lo
  175 215F:00 ** **     	.by <small.bang.fxdata,<mid.bang.fxdata,<big.bang.fxd
  176 2162:00 ** **     	.by <shoot.fxdata,<boing.fxdata,<zap.fxdata
  177 2165:00           	.by <gulp.fxdata
  178 2166:00           	.by <laz.fxdata
  179 2167:00           	.by <shield.fxdata
  180 2168:00           	.by <elevator.fxdata
  181 2169:00           	.by <boggle.fxdata
  182 216A:00           	.by <trans.fxdata
  183 216B:00           	.by <whoosh.fxdata
  184 216C:00           	.by <giggle.fxdata
  185 216D:00           	.by <my.bang.fxdata
  186                   
  187 216E:             sound.hi
  188 216E:00 ** **     	.by >small.bang.fxdata,>mid.bang.fxdata,>big.bang.fxd
  189 2171:00 ** **     	.by >shoot.fxdata,>boing.fxdata,>zap.fxdata
  190 2174:00           	.by >gulp.fxdata
  191 2175:00           	.by >laz.fxdata
  192 2176:00           	.by >shield.fxdata
  193 2177:00           	.by >elevator.fxdata
  194 2178:00           	.by >boggle.fxdata
  195 2179:00           	.by >trans.fxdata
  196 217A:00           	.by >whoosh.fxdata
  197 217B:00           	.by >giggle.fxdata
  198 217C:00           	.by >my.bang.fxdata
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   79
                                                        07:11:20  

  199                   
  200 217D:             small.bang.fxdata
  201                   	;------ Next Frame
  202 217D:00 00        	.WORD	0	; Frame number
  203 217F:B8 0F        	.WORD	$0fb8	; Flags
  204 2181:FC 1F        	.WORD	$1ffc	; Freq accum
  205 2183:FF FF        	.WORD	$ffff	; Shifter accum
  206 2185:10 C0        	.WORD	$c010	; Feedback accum
  207 2187:00 00        	.WORD	$0000	; Volume accum
  208 2189:74 FC        	.WORD	$fc74	; Freq interp
  209 218B:03 00        	.WORD	$0003	; Feedback interp
  210 218D:55 03        	.WORD	$0355	; Volume interp
  211                   	;------ Next Frame
  212 218F:09 00        	.WORD	9	; Frame number
  213 2191:B8 0F        	.WORD	$0fb8	; Flags
  214 2193:08 00        	.WORD	$0008	; Freq accum
  215 2195:16 F0        	.WORD	$f016	; Shifter accum
  216 2197:30 C0        	.WORD	$c030	; Feedback accum
  217 2199:00 1E        	.WORD	$1e00	; Volume accum
  218 219B:0A 00        	.WORD	$000a	; Freq interp
  219 219D:DA F6        	.WORD	$f6da	; Feedback interp
  220 219F:93 FE        	.WORD	$fe93	; Volume interp
  221                   	;------ Next Frame
  222 21A1:1E 00        	.WORD	30	; Frame number
  223 21A3:01 00        	.WORD	$0001	; Flags
  224                   
  225 21A5:             mid.bang.fxdata
  226                   	;------ Next Frame
  227 21A5:00 00        	.WORD	0	; Frame number
  228 21A7:B8 0F        	.WORD	$0fb8	; Flags
  229 21A9:FC FF        	.WORD	$fffc	; Freq accum
  230 21AB:FF FF        	.WORD	$ffff	; Shifter accum
  231 21AD:10 C0        	.WORD	$c010	; Feedback accum
  232 21AF:00 00        	.WORD	$0000	; Volume accum
  233 21B1:91 E3        	.WORD	$e391	; Freq interp
  234 21B3:03 00        	.WORD	$0003	; Feedback interp
  235 21B5:1C 09        	.WORD	$091c	; Volume interp
  236                   	;------ Next Frame
  237 21B7:09 00        	.WORD	9	; Frame number
  238 21B9:B8 0F        	.WORD	$0fb8	; Flags
  239 21BB:10 00        	.WORD	$0010	; Freq accum
  240 21BD:16 F0        	.WORD	$f016	; Shifter accum
  241 21BF:30 C0        	.WORD	$c030	; Feedback accum
  242 21C1:00 52        	.WORD	$5200	; Volume accum
  243 21C3:1B 00        	.WORD	$001b	; Freq interp
  244 21C5:00 00        	.WORD	$0000	; Feedback interp
  245 21C7:B8 FF        	.WORD	$ffb8	; Volume interp
  246                   	;------ Next Frame
  247 21C9:2C 01        	.WORD	300	; Frame number
  248 21CB:01 00        	.WORD	$0001	; Flags
  249                   
  250 21CD:             big.bang.fxdata
  251                   	;------ Next Frame
  252 21CD:00 00        	.WORD	0	; Frame number
  253 21CF:B8 0F        	.WORD	$0fb8	; Flags
  254 21D1:FC FF        	.WORD	$fffc	; Freq accum
  255 21D3:FF FF        	.WORD	$ffff	; Shifter accum
  256 21D5:10 C0        	.WORD	$c010	; Feedback accum
  257 21D7:00 00        	.WORD	$0000	; Volume accum
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   80
                                                        07:11:20  

  258 21D9:E8 E3        	.WORD	$e3e8	; Freq interp
  259 21DB:03 00        	.WORD	$0003	; Feedback interp
  260 21DD:1C 0E        	.WORD	$0e1c	; Volume interp
  261                   	;------ Next Frame
  262 21DF:09 00        	.WORD	9	; Frame number
  263 21E1:B8 0F        	.WORD	$0fb8	; Flags
  264 21E3:1C 03        	.WORD	$031c	; Freq accum
  265 21E5:16 F0        	.WORD	$f016	; Shifter accum
  266 21E7:30 C0        	.WORD	$c030	; Feedback accum
  267 21E9:00 7F        	.WORD	$7f00	; Volume accum
  268 21EB:02 00        	.WORD	$0002	; Freq interp
  269 21ED:00 00        	.WORD	$0000	; Feedback interp
  270 21EF:C9 FF        	.WORD	$ffc9	; Volume interp
  271                   	;------ Next Frame
  272 21F1:58 02        	.WORD	600	; Frame number
  273 21F3:01 00        	.WORD	$0001	; Flags
  274                   
  275 21F5:             shoot.fxdata
  276                   	;------ Next Frame
  277 21F5:00 00        	.WORD	0	; Frame number
  278 21F7:90 0F        	.WORD	$0f90	; Flags
  279 21F9:08 00        	.WORD	$0008	; Freq accum
  280 21FB:83 FC        	.WORD	$fc83	; Shifter accum
  281 21FD:00 02        	.WORD	$0200	; Feedback accum
  282 21FF:00 7F        	.WORD	$7f00	; Volume accum
  283 2201:4F 00        	.WORD	$004f	; Freq interp
  284 2203:CD FD        	.WORD	$fdcd	; Volume interp
  285                   	;------ Next Frame
  286 2205:32 00        	.WORD	50	; Frame number
  287 2207:01 00        	.WORD	$0001	; Flags
  288                   
  289 2209:             boing.fxdata
  290                   	;------ Next Frame
  291 2209:00 00        	.WORD	0	; Frame number
  292 220B:90 0F        	.WORD	$0f90	; Flags
  293 220D:AC 04        	.WORD	$04ac	; Freq accum
  294 220F:9F FC        	.WORD	$fc9f	; Shifter accum
  295 2211:00 02        	.WORD	$0200	; Feedback accum
  296 2213:00 7F        	.WORD	$7f00	; Volume accum
  297 2215:D9 FF        	.WORD	$ffd9	; Freq interp
  298 2217:6F FD        	.WORD	$fd6f	; Volume interp
  299                   	;------ Next Frame
  300 2219:1E 00        	.WORD	30	; Frame number
  301 221B:01 00        	.WORD	$0001	; Flags
  302                   
  303 221D:             zap.fxdata
  304                   	;------ Next Frame
  305 221D:00 00        	.WORD	0	; Frame number
  306 221F:B8 0F        	.WORD	$0fb8	; Flags
  307 2221:00 00        	.WORD	$0000	; Freq accum
  308 2223:FF FF        	.WORD	$ffff	; Shifter accum
  309 2225:10 C0        	.WORD	$c010	; Feedback accum
  310 2227:00 00        	.WORD	$0000	; Volume accum
  311 2229:01 00        	.WORD	$0001	; Freq interp
  312 222B:58 FD        	.WORD	$fd58	; Feedback interp
  313 222D:C9 01        	.WORD	$01c9	; Volume interp
  314                   	;------ Next Frame
  315 222F:47 00        	.WORD	71	; Frame number
  316 2231:B8 0F        	.WORD	$0fb8	; Flags
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   81
                                                        07:11:20  

  317 2233:4C 00        	.WORD	$004c	; Freq accum
  318 2235:0F FC        	.WORD	$fc0f	; Shifter accum
  319 2237:40 03        	.WORD	$0340	; Feedback accum
  320 2239:00 7F        	.WORD	$7f00	; Volume accum
  321 223B:22 00        	.WORD	$0022	; Freq interp
  322 223D:00 00        	.WORD	$0000	; Feedback interp
  323 223F:73 FF        	.WORD	$ff73	; Volume interp
  324                   	;------ Next Frame
  325 2241:2C 01        	.WORD	300	; Frame number
  326 2243:01 00        	.WORD	$0001	; Flags
  327                   
  328 2245:             laz.fxdata
  329                   	;------ Next Frame
  330 2245:00 00        	.WORD	0	; Frame number
  331 2247:98 0F        	.WORD	$0f98	; Flags
  332 2249:24 00        	.WORD	$0024	; Freq accum
  333 224B:C0 FF        	.WORD	$ffc0	; Shifter accum
  334 224D:10 C0        	.WORD	$c010	; Feedback accum
  335 224F:00 0A        	.WORD	$0a00	; Volume accum
  336 2251:0C 00        	.WORD	$000c	; Freq interp
  337 2253:41 00        	.WORD	$0041	; Volume interp
  338                   	;------ Next Frame
  339 2255:4E 00        	.WORD	78	; Frame number
  340 2257:01 00        	.WORD	$0001	; Flags
  341                   
  342 2259:             shield.fxdata
  343                   	;------ Next Frame
  344 2259:00 00        	.WORD	0	; Frame number
  345 225B:98 0F        	.WORD	$0f98	; Flags
  346 225D:34 02        	.WORD	$0234	; Freq accum
  347 225F:C0 FF        	.WORD	$ffc0	; Shifter accum
  348 2261:10 C0        	.WORD	$c010	; Feedback accum
  349 2263:00 17        	.WORD	$1700	; Volume accum
  350 2265:03 00        	.WORD	$0003	; Freq interp
  351 2267:44 00        	.WORD	$0044	; Volume interp
  352                   	;------ Next Frame
  353 2269:40 00        	.WORD	64	; Frame number
  354 226B:98 0B        	.WORD	$0b98	; Flags
  355 226D:1C 03        	.WORD	$031c	; Freq accum
  356 226F:10 C0        	.WORD	$c010	; Feedback accum
  357 2271:00 28        	.WORD	$2800	; Volume accum
  358 2273:FD FF        	.WORD	$fffd	; Freq interp
  359 2275:00 00        	.WORD	$0000	; Volume interp
  360                   	;------ Next Frame
  361 2277:80 00        	.WORD	128	; Frame number
  362 2279:01 00        	.WORD	$0001	; Flags
  363                   
  364 227B:             elevator.fxdata
  365                   	;------ Next Frame
  366 227B:00 00        	.WORD	0	; Frame number
  367 227D:10 0F        	.WORD	$0f10	; Flags
  368 227F:00 00        	.WORD	$0000	; Freq accum
  369 2281:FE FF        	.WORD	$fffe	; Shifter accum
  370 2283:40 49        	.WORD	$4940	; Feedback accum
  371 2285:00 00        	.WORD	$0000	; Volume accum
  372 2287:00 01        	.WORD	$0100	; Volume interp
  373                   	;------ Next Frame
  374 2289:14 00        	.WORD	20	; Frame number
  375 228B:10 0F        	.WORD	$0f10	; Flags
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   82
                                                        07:11:20  

  376 228D:24 00        	.WORD	$0024	; Freq accum
  377 228F:FE FF        	.WORD	$fffe	; Shifter accum
  378 2291:00 4B        	.WORD	$4b00	; Feedback accum
  379 2293:00 14        	.WORD	$1400	; Volume accum
  380 2295:02 00        	.WORD	$0002	; Volume interp
  381                   	;------ Next Frame
  382 2297:E8 03        	.WORD	1000	; Frame number
  383 2299:01 00        	.WORD	$0001	; Flags
  384 229B:             gulp.fxdata
  385                   	;------ Next Frame
  386 229B:00 00        	.WORD	0	; Frame number
  387 229D:88 0F        	.WORD	$0f88	; Flags
  388 229F:04 00        	.WORD	$0004	; Freq accum
  389 22A1:87 FC        	.WORD	$fc87	; Shifter accum
  390 22A3:00 02        	.WORD	$0200	; Feedback accum
  391 22A5:00 7F        	.WORD	$7f00	; Volume accum
  392 22A7:85 00        	.WORD	$0085	; Freq interp
  393                   	;------ Next Frame
  394 22A9:1E 00        	.WORD	30	; Frame number
  395 22AB:98 0B        	.WORD	$0b98	; Flags
  396 22AD:9C 0F        	.WORD	$0f9c	; Freq accum
  397 22AF:00 02        	.WORD	$0200	; Feedback accum
  398 22B1:00 7F        	.WORD	$7f00	; Volume accum
  399 22B3:E4 FF        	.WORD	$ffe4	; Freq interp
  400 22B5:74 FF        	.WORD	$ff74	; Volume interp
  401                   	;------ Next Frame
  402 22B7:AA 00        	.WORD	170	; Frame number
  403 22B9:01 00        	.WORD	$0001	; Flags
  404                   
  405 22BB:             boggle.fxdata
  406                   	;------ Next Frame
  407 22BB:00 00        	.WORD	0	; Frame number
  408 22BD:B0 0F        	.WORD	$0fb0	; Flags
  409 22BF:AC 00        	.WORD	$00ac	; Freq accum
  410 22C1:80 FC        	.WORD	$fc80	; Shifter accum
  411 22C3:F0 01        	.WORD	$01f0	; Feedback accum
  412 22C5:00 7F        	.WORD	$7f00	; Volume accum
  413 22C7:07 00        	.WORD	$0007	; Freq interp
  414 22C9:01 00        	.WORD	$0001	; Feedback interp
  415 22CB:E7 FE        	.WORD	$fee7	; Volume interp
  416                   	;------ Next Frame
  417 22CD:64 00        	.WORD	100	; Frame number
  418 22CF:B0 0F        	.WORD	$0fb0	; Flags
  419 22D1:88 03        	.WORD	$0388	; Freq accum
  420 22D3:8B F4        	.WORD	$f48b	; Shifter accum
  421 22D5:A0 02        	.WORD	$02a0	; Feedback accum
  422 22D7:00 11        	.WORD	$1100	; Volume accum
  423 22D9:00 00        	.WORD	$0000	; Freq interp
  424 22DB:F5 FF        	.WORD	$fff5	; Feedback interp
  425 22DD:B5 FF        	.WORD	$ffb5	; Volume interp
  426                   	;------ Next Frame
  427 22DF:97 00        	.WORD	151	; Frame number
  428 22E1:01 00        	.WORD	$0001	; Flags
  429                   
  430 22E3:             trans.fxdata
  431                   	;------ Next Frame
  432 22E3:00 00        	.WORD	0	; Frame number
  433 22E5:98 0F        	.WORD	$0f98	; Flags
  434 22E7:60 00        	.WORD	$0060	; Freq accum
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   83
                                                        07:11:20  

  435 22E9:FF FF        	.WORD	$ffff	; Shifter accum
  436 22EB:10 C0        	.WORD	$c010	; Feedback accum
  437 22ED:00 00        	.WORD	$0000	; Volume accum
  438 22EF:67 00        	.WORD	$0067	; Freq interp
  439 22F1:AB 01        	.WORD	$01ab	; Volume interp
  440                   	;------ Next Frame
  441 22F3:4C 00        	.WORD	76	; Frame number
  442 22F5:98 0F        	.WORD	$0f98	; Flags
  443 22F7:3C 1F        	.WORD	$1f3c	; Freq accum
  444 22F9:FF FF        	.WORD	$ffff	; Shifter accum
  445 22FB:10 00        	.WORD	$0010	; Feedback accum
  446 22FD:00 7F        	.WORD	$7f00	; Volume accum
  447 22FF:24 E1        	.WORD	$e124	; Freq interp
  448 2301:00 81        	.WORD	$8100	; Volume interp
  449                   	;------ Next Frame
  450 2303:4D 00        	.WORD	77	; Frame number
  451 2305:98 0F        	.WORD	$0f98	; Flags
  452 2307:60 00        	.WORD	$0060	; Freq accum
  453 2309:FF FF        	.WORD	$ffff	; Shifter accum
  454 230B:10 C0        	.WORD	$c010	; Feedback accum
  455 230D:00 00        	.WORD	$0000	; Volume accum
  456 230F:1C 00        	.WORD	$001c	; Freq interp
  457 2311:65 02        	.WORD	$0265	; Volume interp
  458                   	;------ Next Frame
  459 2313:82 00        	.WORD	130	; Frame number
  460 2315:98 0F        	.WORD	$0f98	; Flags
  461 2317:3C 06        	.WORD	$063c	; Freq accum
  462 2319:FF FF        	.WORD	$ffff	; Shifter accum
  463 231B:10 00        	.WORD	$0010	; Feedback accum
  464 231D:00 7F        	.WORD	$7f00	; Volume accum
  465 231F:E0 FC        	.WORD	$fce0	; Freq interp
  466 2321:00 81        	.WORD	$8100	; Volume interp
  467                   	;------ Next Frame
  468 2323:83 00        	.WORD	131	; Frame number
  469 2325:98 0F        	.WORD	$0f98	; Flags
  470 2327:1C 03        	.WORD	$031c	; Freq accum
  471 2329:FF FF        	.WORD	$ffff	; Shifter accum
  472 232B:10 C0        	.WORD	$c010	; Feedback accum
  473 232D:00 00        	.WORD	$0000	; Volume accum
  474 232F:FE FF        	.WORD	$fffe	; Freq interp
  475 2331:08 01        	.WORD	$0108	; Volume interp
  476                   	;------ Next Frame
  477 2333:FA 00        	.WORD	250	; Frame number
  478 2335:01 00        	.WORD	$0001	; Flags
  479 2337:             whoosh.fxdata
  480                   	;------ Next Frame
  481 2337:00 00        	.WORD	0	; Frame number
  482 2339:38 0F        	.WORD	$0f38	; Flags
  483 233B:4C 00        	.WORD	$004c	; Freq accum
  484 233D:BF FC        	.WORD	$fcbf	; Shifter accum
  485 233F:90 CB        	.WORD	$cb90	; Feedback accum
  486 2341:00 64        	.WORD	$6400	; Volume accum
  487 2343:A0 3C        	.WORD	$3ca0	; Feedback interp
  488 2345:00 A6        	.WORD	$a600	; Volume interp
  489                   	;------ Next Frame
  490 2347:01 00        	.WORD	1	; Frame number
  491 2349:B8 0F        	.WORD	$0fb8	; Flags
  492 234B:4C 00        	.WORD	$004c	; Freq accum
  493 234D:B5 FC        	.WORD	$fcb5	; Shifter accum
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   84
                                                        07:11:20  

  494 234F:30 08        	.WORD	$0830	; Feedback accum
  495 2351:00 0A        	.WORD	$0a00	; Volume accum
  496 2353:FF FF        	.WORD	$ffff	; Freq interp
  497 2355:1A 05        	.WORD	$051a	; Feedback interp
  498 2357:50 01        	.WORD	$0150	; Volume interp
  499                   	;------ Next Frame
  500 2359:27 00        	.WORD	39	; Frame number
  501 235B:B8 0F        	.WORD	$0fb8	; Flags
  502 235D:04 00        	.WORD	$0004	; Freq accum
  503 235F:BF FC        	.WORD	$fcbf	; Shifter accum
  504 2361:10 CA        	.WORD	$ca10	; Feedback accum
  505 2363:00 3C        	.WORD	$3c00	; Volume accum
  506 2365:00 00        	.WORD	$0000	; Freq interp
  507 2367:80 01        	.WORD	$0180	; Feedback interp
  508 2369:00 3C        	.WORD	$3c00	; Volume interp
  509                   	;------ Next Frame
  510 236B:28 00        	.WORD	40	; Frame number
  511 236D:B8 0F        	.WORD	$0fb8	; Flags
  512 236F:04 00        	.WORD	$0004	; Freq accum
  513 2371:BF FC        	.WORD	$fcbf	; Shifter accum
  514 2373:90 CB        	.WORD	$cb90	; Feedback accum
  515 2375:00 78        	.WORD	$7800	; Volume accum
  516 2377:45 00        	.WORD	$0045	; Freq interp
  517 2379:F3 FD        	.WORD	$fdf3	; Feedback interp
  518 237B:29 FF        	.WORD	$ff29	; Volume interp
  519                   	;------ Next Frame
  520 237D:87 00        	.WORD	135	; Frame number
  521 237F:B8 0F        	.WORD	$0fb8	; Flags
  522 2381:FC 19        	.WORD	$19fc	; Freq accum
  523 2383:B1 FC        	.WORD	$fcb1	; Shifter accum
  524 2385:60 08        	.WORD	$0860	; Feedback accum
  525 2387:00 28        	.WORD	$2800	; Volume accum
  526 2389:A3 00        	.WORD	$00a3	; Freq interp
  527 238B:00 00        	.WORD	$0000	; Feedback interp
  528 238D:A3 FF        	.WORD	$ffa3	; Volume interp
  529                   	;------ Next Frame
  530 238F:D9 00        	.WORD	217	; Frame number
  531 2391:90 0F        	.WORD	$0f90	; Flags
  532 2393:7C 4E        	.WORD	$4e7c	; Freq accum
  533 2395:B1 FC        	.WORD	$fcb1	; Shifter accum
  534 2397:70 08        	.WORD	$0870	; Feedback accum
  535 2399:00 0A        	.WORD	$0a00	; Volume accum
  536 239B:AB 04        	.WORD	$04ab	; Freq interp
  537 239D:C4 FF        	.WORD	$ffc4	; Volume interp
  538                   	;------ Next Frame
  539 239F:FF 00        	.WORD	255	; Frame number
  540 23A1:01 00        	.WORD	$0001	; Flags
  541 23A3:             giggle.fxdata
  542                   ; HSFX Table for SFX_1 sound effect
  543                   	;------ Next Frame
  544 23A3:00 00        	.WORD	0	; Frame number
  545 23A5:18 0F        	.WORD	$0f18	; Flags
  546 23A7:FC 00        	.WORD	$00fc	; Freq accum
  547 23A9:B5 F0        	.WORD	$f0b5	; Shifter accum
  548 23AB:00 00        	.WORD	$0000	; Feedback accum
  549 23AD:00 4E        	.WORD	$4e00	; Volume accum
  550 23AF:9A FD        	.WORD	$fd9a	; Volume interp
  551                   	;------ Next Frame
  552 23B1:19 00        	.WORD	25	; Frame number
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   85
                                                        07:11:20  

  553 23B3:38 0F        	.WORD	$0f38	; Flags
  554 23B5:FC 00        	.WORD	$00fc	; Freq accum
  555 23B7:B5 F0        	.WORD	$f0b5	; Shifter accum
  556 23B9:10 00        	.WORD	$0010	; Feedback accum
  557 23BB:00 12        	.WORD	$1200	; Volume accum
  558 23BD:07 00        	.WORD	$0007	; Feedback interp
  559 23BF:D7 00        	.WORD	$00d7	; Volume interp
  560                   	;------ Next Frame
  561 23C1:32 00        	.WORD	50	; Frame number
  562 23C3:38 0F        	.WORD	$0f38	; Flags
  563 23C5:F8 00        	.WORD	$00f8	; Freq accum
  564 23C7:B9 F0        	.WORD	$f0b9	; Shifter accum
  565 23C9:C0 00        	.WORD	$00c0	; Feedback accum
  566 23CB:00 27        	.WORD	$2700	; Volume accum
  567 23CD:FE FF        	.WORD	$fffe	; Feedback interp
  568 23CF:B3 00        	.WORD	$00b3	; Volume interp
  569                   	;------ Next Frame
  570 23D1:50 00        	.WORD	80	; Frame number
  571 23D3:38 0F        	.WORD	$0f38	; Flags
  572 23D5:FC 00        	.WORD	$00fc	; Freq accum
  573 23D7:B5 F0        	.WORD	$f0b5	; Shifter accum
  574 23D9:80 00        	.WORD	$0080	; Feedback accum
  575 23DB:00 3C        	.WORD	$3c00	; Volume accum
  576 23DD:00 00        	.WORD	$0000	; Feedback interp
  577 23DF:D9 01        	.WORD	$01d9	; Volume interp
  578                   	;------ Next Frame
  579 23E1:64 00        	.WORD	100	; Frame number
  580 23E3:B8 0F        	.WORD	$0fb8	; Flags
  581 23E5:FC 00        	.WORD	$00fc	; Freq accum
  582 23E7:B5 F0        	.WORD	$f0b5	; Shifter accum
  583 23E9:80 00        	.WORD	$0080	; Feedback accum
  584 23EB:00 61        	.WORD	$6100	; Volume accum
  585 23ED:90 07        	.WORD	$0790	; Freq interp
  586 23EF:64 32        	.WORD	$3264	; Feedback interp
  587 23F1:80 F0        	.WORD	$f080	; Volume interp
  588                   	;------ Next Frame
  589 23F3:68 00        	.WORD	104	; Frame number
  590 23F5:01 00        	.WORD	$0001	; Flags
  591                   
  592 23F7:             my.bang.fxdata
  593                   ; HSFX Table for SFX_1 sound effect
  594                   	;------ Next Frame
  595 23F7:00 00        	.WORD	0	; Frame number
  596 23F9:90 0F        	.WORD	$0f90	; Flags
  597 23FB:FC 7F        	.WORD	$7ffc	; Freq accum
  598 23FD:F3 FF        	.WORD	$fff3	; Shifter accum
  599 23FF:F0 CB        	.WORD	$cbf0	; Feedback accum
  600 2401:00 00        	.WORD	$0000	; Volume accum
  601 2403:84 F3        	.WORD	$f384	; Freq interp
  602 2405:1C 0E        	.WORD	$0e1c	; Volume interp
  603                   	;------ Next Frame
  604 2407:09 00        	.WORD	9	; Frame number
  605 2409:90 0B        	.WORD	$0b90	; Flags
  606 240B:9C 0F        	.WORD	$0f9c	; Freq accum
  607 240D:10 C2        	.WORD	$c210	; Feedback accum
  608 240F:00 7F        	.WORD	$7f00	; Volume accum
  609 2411:08 00        	.WORD	$0008	; Freq interp
  610 2413:BE FF        	.WORD	$ffbe	; Volume interp
  611                   	;------ Next Frame
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   86
                                                        07:11:20  

  612 2415:F4 01        	.WORD	500	; Frame number
  613 2417:01 00        	.WORD	$0001	; Flags
  614                   
  615                   
  616                   
  617                   
  618                   
  619 2419:             blob.Data
  620                   ; Handy Sprite Image Data
  621                   ; Bits per Pixel = 3
  622                   ; Next data is down-right
  623 2419:04 10 09 00  	.BYTE	$04,$10,$09,$00
  623                   
  624 241D:07 18 C9 20  	.BYTE	$07,$18,$c9,$20,$02,$01,$20
  624      02 01 20     
  625 2424:06 18 11 80  	.BYTE	$06,$18,$11,$80,$21,$00
  625      21 00        
  626 242A:07 10 B1 48  	.BYTE	$07,$10,$b1,$48,$82,$84,$40
  626      82 84 40     
  627 2431:08 F8 24 94  	.BYTE	$08,$f8,$24,$94,$53,$48,$80,$08
  627      53 48 80 08  
  627                   
  628 2439:08 18 E1 49  	.BYTE	$08,$18,$e1,$49,$34,$91,$00,$90
  628      34 91 00 90  
  628                   
  629 2441:08 E8 04 B4  	.BYTE	$08,$e8,$04,$b4,$a4,$69,$20,$22
  629      A4 69 20 22  
  629                   
  630 2449:09 08 F1 6D  	.BYTE	$09,$08,$f1,$6d,$37,$1b,$48,$90,$40
  630      37 1B 48 90  
  630      40           
  631 2452:06 19 13 14  	.BYTE	$06,$19,$13,$14,$93,$48
  631      93 48        
  632 2458:09 F1 04 A4  	.BYTE	$09,$f1,$04,$a4,$e4,$8d,$22,$02,$40
  632      E4 8D 22 02  
  632      40           
  633 2461:07 10 A9 49  	.BYTE	$07,$10,$a9,$49,$b8,$26,$32
  633      B8 26 32     
  634 2468:08 D8 24 94  	.BYTE	$08,$d8,$24,$94,$db,$65,$88,$80
  634      DB 65 88 80  
  634                   
  635 2470:08 10 E1 4D  	.BYTE	$08,$10,$e1,$4d,$a4,$89,$20,$90
  635      A4 89 20 90  
  635                   
  636 2478:07 10 C1 08  	.BYTE	$07,$10,$c1,$08,$92,$91,$00
  636      92 91 00     
  637 247F:06 B8 04 80  	.BYTE	$06,$b8,$04,$80,$41,$48
  637      41 48        
  638 2485:05 90 04 60  	.BYTE	$05,$90,$04,$60,$44
  638      44           
  639 248A:00           	.BYTE	$00
  640                   ; 114 total image bytes
  641 248B:             blob
  642                   ; Handy Sprite
  643 248B:85           	.BYTE	THREE_PER_PIXEL+NONCOLL_SPRITE ; Control 0
  644 248C:30           	.BYTE	RELOAD_HVST ; Control 1
  645 248D:00           	.BYTE	$00 ; Control 2
  646 248E:00 00        	.WORD	$0000	; Next Sprite
  647 2490:19 24        	.WORD	blob.Data	; ImageData
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   87
                                                        07:11:20  

  648 2492:50 00        	.WORD	80	; HPos
  649 2494:33 00        	.WORD	51	; VPos
  650 2496:00 01        	.WORD	$0100	; HSize
  651 2498:00 01        	.WORD	$0100	; VSize
  652 249A:00 00        	.WORD	$0000	; Stretch
  653 249C:00 00        	.WORD	$0000	; Tilt
  654                   	; Palette
  655 249E:09 AB C0 00  	.BYTE	$09,$ab,$c0,$00
  655                   
  656 24A2:             face.Data
  657                   ; Handy Sprite Image Data
  658                   ; Bits per Pixel = 3
  659                   ; Next data is down-right
  660 24A2:04 50 31 00  	.BYTE	$04,$50,$31,$00
  660                   
  661 24A6:04 38 71 00  	.BYTE	$04,$38,$71,$00
  661                   
  662 24AA:06 30 31 82  	.BYTE	$06,$30,$31,$82,$49,$00
  662      49 00        
  663 24B0:05 20 79 21  	.BYTE	$05,$20,$79,$21,$00
  663      00           
  664 24B5:06 18 21 92  	.BYTE	$06,$18,$21,$92,$45,$e4
  664      45 E4        
  665 24BB:05 10 79 49  	.BYTE	$05,$10,$79,$49,$00
  665      00           
  666 24C0:05 10 79 51  	.BYTE	$05,$10,$79,$51,$00
  666      00           
  667 24C5:07 08 79 A1  	.BYTE	$07,$08,$79,$a1,$32,$23,$10
  667      32 23 10     
  668 24CC:07 08 79 A9  	.BYTE	$07,$08,$79,$a9,$56,$d4,$52
  668      56 D4 52     
  669 24D3:07 80 71 92  	.BYTE	$07,$80,$71,$92,$50,$94,$c4
  669      50 94 C4     
  670 24DA:0A A0 25 44  	.BYTE	$0a,$a0,$25,$44,$99,$25,$0b,$60,$8a,$40
  670      99 25 0B 60  
  670      8A 40        
  671 24E4:0A A8 26 54  	.BYTE	$0a,$a8,$26,$54,$32,$24,$38,$6b,$08,$52
  671      32 24 38 6B  
  671      08 52        
  672 24EE:0A B0 2A DB  	.BYTE	$0a,$b0,$2a,$db,$04,$89,$11,$61,$0a,$40
  672      04 89 11 61  
  672      0A 40        
  673 24F8:07 91 29 F4  	.BYTE	$07,$91,$29,$f4,$96,$10,$a4
  673      96 10 A4     
  674 24FF:07 11 7D 25  	.BYTE	$07,$11,$7d,$25,$82,$29,$00
  674      82 29 00     
  675 2506:07 11 7D 1D  	.BYTE	$07,$11,$7d,$1d,$8c,$45,$20
  675      8C 45 20     
  676 250D:0C 11 1D 0C  	.BYTE	$0c,$11,$1d,$0c,$0a,$1c,$12,$14,$9d,$b1,$14,$80
  676      0A 1C 12 14  
  676      9D B1 14 80  
  676                   
  677 2519:0B 11 8C A4  	.BYTE	$0b,$11,$8c,$a4,$54,$25,$44,$32,$34,$18,$52
  677      54 25 44 32  
  677      34 18 52     
  678 2524:0C 11 DA 51  	.BYTE	$0c,$11,$da,$51,$12,$4a,$91,$10,$8d,$06,$10,$80
  678      12 4A 91 10  
  678      8D 06 10 80  
  678                   
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   88
                                                        07:11:20  

  679 2530:0C A9 45 58  	.BYTE	$0c,$a9,$45,$58,$45,$92,$91,$49,$14,$46,$8a,$40
  679      45 92 91 49  
  679      14 46 8A 40  
  679                   
  680 253C:0E C8 51 5B  	.BYTE	$0e,$c8,$51,$5b,$64,$5f,$86,$d3,$22,$92,$d9,$12
  680      64 5F 86 D3  
  680      22 92 D9 12  
  680      21 00        
  681 254A:0C 80 14 2D  	.BYTE	$0c,$80,$14,$2d,$ac,$96,$d8,$6b,$35,$62,$11,$00
  681      AC 96 D8 6B  
  681      35 62 11 00  
  681                   
  682 2556:0D A0 52 A2  	.BYTE	$0d,$a0,$52,$a2,$58,$41,$df,$29,$6d,$b1,$4b,$22
  682      58 41 DF 29  
  682      6D B1 4B 22  
  682      24           
  683 2563:0B A0 12 D2  	.BYTE	$0b,$a0,$12,$d2,$a2,$52,$ab,$c9,$64,$29,$00
  683      A2 52 AB C9  
  683      64 29 00     
  684 256E:0B C8 12 D9  	.BYTE	$0b,$c8,$12,$d9,$2c,$46,$83,$30,$64,$82,$40
  684      2C 46 83 30  
  684      64 82 40     
  685 2579:0D 90 08 77  	.BYTE	$0d,$90,$08,$77,$c8,$d8,$4a,$45,$22,$89,$1c,$93
  685      C8 D8 4A 45  
  685      22 89 1C 93  
  685      48           
  686 2586:0B 10 B4 B6  	.BYTE	$0b,$10,$b4,$b6,$17,$4e,$72,$91,$32,$48,$d0
  686      17 4E 72 91  
  686      32 48 D0     
  687 2591:09 10 A4 B6  	.BYTE	$09,$10,$a4,$b6,$26,$1a,$b9,$23,$60
  687      26 1A B9 23  
  687      60           
  688 259A:0A 10 BC B6  	.BYTE	$0a,$10,$bc,$b6,$c7,$21,$10,$c9,$24,$18
  688      C7 21 10 C9  
  688      24 18        
  689 25A4:0A 18 BC B6  	.BYTE	$0a,$18,$bc,$b6,$48,$50,$a0,$91,$60,$58
  689      48 50 A0 91  
  689      60 58        
  690 25AE:09 18 24 0D  	.BYTE	$09,$18,$24,$0d,$14,$25,$1c,$0b,$00
  690      14 25 1C 0B  
  690      00           
  691 25B7:0A 20 1C C5  	.BYTE	$0a,$20,$1c,$c5,$b1,$25,$25,$24,$83,$00
  691      B1 25 25 24  
  691      83 00        
  692 25C1:09 20 1C 0D  	.BYTE	$09,$20,$1c,$0d,$1c,$bd,$96,$48,$d8
  692      1C BD 96 48  
  692      D8           
  693 25CA:07 28 14 45  	.BYTE	$07,$28,$14,$45,$0c,$0b,$00
  693      0C 0B 00     
  694 25D1:07 38 0C 35  	.BYTE	$07,$38,$0c,$35,$14,$83,$00
  694      14 83 00     
  695 25D8:04 40 3C 00  	.BYTE	$04,$40,$3c,$00
  695                   
  696 25DC:00           	.BYTE	$00
  697                   ; 315 total image bytes
  698 25DD:             face
  699                   ; Handy Sprite
  700 25DD:85           	.BYTE	THREE_PER_PIXEL+NONCOLL_SPRITE ; Control 0
  701 25DE:30           	.BYTE	RELOAD_HVST ; Control 1
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   89
                                                        07:11:20  

  702 25DF:00           	.BYTE	$00 ; Control 2
  703 25E0:00 00        	.WORD	$0000	; Next Sprite
  704 25E2:A2 24        	.WORD	face.Data	; ImageData
  705 25E4:40 00        	.WORD	64	; HPos
  706 25E6:1F 00        	.WORD	31	; VPos
  707 25E8:00 01        	.WORD	$0100	; HSize
  708 25EA:00 01        	.WORD	$0100	; VSize
  709 25EC:00 00        	.WORD	$0000	; Stretch
  710 25EE:00 00        	.WORD	$0000	; Tilt
  711                   	; Palette
  712 25F0:08 9A BC 00  	.BYTE	$08,$9a,$bc,$00
  712                   
  713                   
  714                   
  715                   
  716                   ;-----------------------------------------------------
  717                   ; include system variables
  718                   	.in sys.var
    1 25F4:             most.variables
    2                   ; some system variables
    3                   	.in 6502:src/hmusic.var
    1                   ; Tuesday 24-Apr-90 13:46:38
    2                   * === hmusic.src =====================================
    3                   *
    4                   * Handy Music Driver  --  Handy Software
    5                   *
    6                   * Confidential and Proprietary
    7                   * Copyright (C) 1989, Epyx, Inc.
    8                   * 
    9                   * Date		Name		Description
   10                   * ---------	--------------	---------------------------
   11                   * 24-Apr-90	SHL		ring0_flag and ring1_flag arrays repl
   12                   *				ring_flag array
   13                   * 18-Apr-90	SHL		HMUSIC_DEFAULT_PRIORITY added to give
   14                   *				a default priority level
   15                   *				Added HMusicVarStart and HMusicVarEnd markers
   16                   * 31-Aug-89	Stephen Jungels	Split this file from hsfx.
   17                   *
   18                   * ====================================================
   19                   
   20                   
   21                   ; Variables used by the HMUSIC driver
   22                   
   23                   ; If you are using HMUSIC you must include this file
   24                   
   25 25F4:             HMusicVarStart
   26                   
   27                   
   28 25F4:             VoiceInUse	.DS HMUSIC_CHANNELCOUNT	; Flags whether thi
   29                   
   30 25F8:             instance	.DS 1			; Holds next 'instance' value
   31 25F9:             VoiceInstance	.DS HMUSIC_CHANNELCOUNT	; Instances for 
   32                   
   33 25FD:             restore_ds	.DS HMUSIC_CHANNELCOUNT ; Flag for modified
   34 2601:             save_decayl	.DS HMUSIC_CHANNELCOUNT ; Save location fo
   35 2605:             save_decayh	.DS HMUSIC_CHANNELCOUNT
   36 2609:             save_sustainl	.DS HMUSIC_CHANNELCOUNT ; Save location 
   37 260D:             save_sustainh	.DS HMUSIC_CHANNELCOUNT
   38                   
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   90
                        6502:src/hmusic.var             07:11:20  

   39 2611:             voice_freq_ptrl	.DS HMUSIC_CHANNELCOUNT ; Address of p
   40 2615:             voice_freq_ptrh	.DS HMUSIC_CHANNELCOUNT
   41 2619:             voice_dur_ptrl	.DS HMUSIC_CHANNELCOUNT ; Address of du
   42 261D:             voice_dur_ptrh	.DS HMUSIC_CHANNELCOUNT
   43                   
   44 2621:             gatel		.DS HMUSIC_CHANNELCOUNT	; Gate timing
   45 2625:             gateh		.DS HMUSIC_CHANNELCOUNT
   46                   
   47 2629:             voicedata_ptrl	.DS HMUSIC_CHANNELCOUNT ; Current addre
   48 262D:             voicedata_ptrh	.DS HMUSIC_CHANNELCOUNT
   49                   
   50 2631:             frames_alivel	.DS HMUSIC_CHANNELCOUNT ; Number of audi
   51 2635:             frames_aliveh	.DS HMUSIC_CHANNELCOUNT ; has been alive
   52 2639:             voice_endframel	.DS HMUSIC_CHANNELCOUNT ; When current
   53 263D:             voice_endframeh	.DS HMUSIC_CHANNELCOUNT
   54                   
   55 2641:             hmflagsl	.DS 1		; Last CFW read
   56 2642:             hmflagsh	.DS 1
   57                   
   58 2643:             gating		.DS HMUSIC_CHANNELCOUNT ; Last AGD/AGS flag re
   59                   
   60 2647:             new_note	.DS HMUSIC_CHANNELCOUNT ; Flag - send new not
   61                   
   62 264B:             SFX_to_cancel	.DS HMUSIC_CHANNELCOUNT ; Priority of SF
   63                   
   64 264F:             did_outernext	.DS 1
   65 2650:             did_innernext	.DS 1
   66 2651:             did_ring_end	.DS 1	; One-shot prevention of recursive 
   67                   
   68 2652:             mloop_count0	.DS HMUSIC_CHANNELCOUNT
   69 2656:             mloop_adrl0	.DS HMUSIC_CHANNELCOUNT
   70 265A:             mloop_adrh0	.DS HMUSIC_CHANNELCOUNT
   71 265E:             mloop_count1	.DS HMUSIC_CHANNELCOUNT
   72 2662:             mloop_adrl1	.DS HMUSIC_CHANNELCOUNT
   73 2666:             mloop_adrh1	.DS HMUSIC_CHANNELCOUNT
   74                   
   75 266A:             ring_flag	.DS HMUSIC_CHANNELCOUNT
   76 266E:             ring0_returnl	.DS HMUSIC_CHANNELCOUNT ; RING0 info
   77 2672:             ring0_returnh	.DS HMUSIC_CHANNELCOUNT
   78 2676:             ring1_returnl	.DS HMUSIC_CHANNELCOUNT ; RING1 info
   79 267A:             ring1_returnh	.DS HMUSIC_CHANNELCOUNT
   80                   
   81 267E:             hmusic_base	.DS 2		; Address of music data
   82                   
   83 2680:             VoiceHSFXChannel .DS HMUSIC_CHANNELCOUNT ; Hardware ch
   84                   
   85                   
   86      TRUE         	#IFDEF MUTE_USER
   87 2684:             Mute_flag	.DS 1
   88                   	#ENDIF
   89                   
   90      FALSE        	#IFDEF	USERCALLS_USER
   93                   	#ENDIF ; of #IFDEF USERCALLS_USER
   94                   
   95                   
   96 2685:             HMusicVarEnd
   97                   
    4                   	.in 6502:src/hsfx.var
    1                   ; Thursday 19-Apr-90 16:17:32
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   91
                        6502:src/hsfx.var               07:11:20  

    2                   * === hsfx.var =======================================
    3                   *
    4                   * Handy Sound Effects Driver  --  Handy Software
    5                   *
    6                   * Confidential and Proprietary
    7                   * Copyright (C) 1989, Epyx, Inc.
    8                   *
    9                   * Date		Name		Description
   10                   * ---------	--------------	---------------------------
   11                   * 19-Apr-90	SHL		Moved top_of_loop0,1 variables from h
   12                   *				Moved hsfx_temp to zero page in hsfx.src
   13                   * 18-Apr-90	SHL		Added HSFXVarStart and HSFXVarEnd mar
   14                   * 31-Aug-89	Stephen Jungels	Split this file from hsfx.
   15                   *
   16                   * ====================================================
   17                   
   18                   
   19                   ; Variables used by the HSFX driver
   20                   
   21                   ; If you are using HSFX you must include this file
   22                   
   23                   
   24 2685:             HSFXVarStart
   25                   
   26                   
   27 2685:             audio_interruptus .ds 1	; Set on entry to audio interr
   28 2686:             audio_lockout	.ds 1	; flag to lock out audio interrupt
   29 2687:             audio_dropout	.ds 1	; count of audio frames that have 
   30                   
   31 2688:             top_of_loop0	.ds 1	; recursion flag
   32 2689:             top_of_loop1	.ds 1	; recursion flag
   33                   
   34                   
   35                   * ChannelInUse is used to denote both that the HSFX ch
   36                   * and the priority of the effect currently playing on 
   37                   * A ChannelInUse value of 0 (HSFX_FREECHANNEL) denotes
   38                   * A value of $FF (HSFX_NOCHANNEL) denotes channel not 
   39                   * Any other value is a channel-priority value, where s
   40                   * odd priorities and music notes get even priorities.
   41                   * Note that ChannelInUse has 5 elements, allowing for 
   42                   * "mock channel" which is guaranteed to always have a 
   43                   * Channel 4 is returned by StartHSFX when the effect c
   44                   
   45 268A:             ChannelInUse	.ds HSFX_CHANNELCOUNT+1
   46                   
   47                   
   48                   * NOTE:  The above software depends on the exact order
   49                   * accumulators and interpolators.
   50                   * Also, the software presumes that:  there are HSFX_AC
   51                   * accumulators; there are a total of HSFX_REGCOUNT arr
   52                   * and each pair is (HSFX_CHANNELCOUNT * HSFX_REGSIZE) 
   53                   
   54 268F:             freql		.ds HSFX_CHANNELCOUNT
   55 2693:             freqh		.ds HSFX_CHANNELCOUNT
   56 2697:             shiftl		.ds HSFX_CHANNELCOUNT
   57 269B:             shifth		.ds HSFX_CHANNELCOUNT
   58 269F:             feedbackl	.ds HSFX_CHANNELCOUNT
   59 26A3:             feedbackh	.ds HSFX_CHANNELCOUNT
   60 26A7:             volumel		.ds HSFX_CHANNELCOUNT
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   92
                        6502:src/hsfx.var               07:11:20  

   61 26AB:             volumeh		.ds HSFX_CHANNELCOUNT
   62 26AF:             freq_interpl	.ds HSFX_CHANNELCOUNT
   63 26B3:             freq_interph	.ds HSFX_CHANNELCOUNT
   64 26B7:             shift_interpl	.ds HSFX_CHANNELCOUNT
   65 26BB:             shift_interph	.ds HSFX_CHANNELCOUNT
   66 26BF:             feed_interpl	.ds HSFX_CHANNELCOUNT
   67 26C3:             feed_interph	.ds HSFX_CHANNELCOUNT
   68 26C7:             vol_interpl	.ds HSFX_CHANNELCOUNT
   69 26CB:             vol_interph	.ds HSFX_CHANNELCOUNT
   70                   
   71 26CF:             flagsl		.ds HSFX_CHANNELCOUNT	;16 bit flags
   72 26D3:             flagsh		.ds HSFX_CHANNELCOUNT
   73                   
   74 26D7:             next_keyframel	.ds HSFX_CHANNELCOUNT	;next 'change of 
   75 26DB:             next_keyframeh	.ds HSFX_CHANNELCOUNT
   76                   
   77 26DF:             current_framel	.ds HSFX_CHANNELCOUNT	;current frame be
   78 26E3:             current_frameh	.ds HSFX_CHANNELCOUNT
   79                   
   80 26E7:             loop_count0	.ds HSFX_CHANNELCOUNT	;# loops to perform
   81 26EB:             loop_adrl0	.ds HSFX_CHANNELCOUNT	;'top of loop' addres
   82 26EF:             loop_adrh0	.ds HSFX_CHANNELCOUNT
   83                   
   84 26F3:             loop_count1	.ds HSFX_CHANNELCOUNT	;# loops to perform
   85 26F7:             loop_adrl1	.ds HSFX_CHANNELCOUNT	;'top of loop' addres
   86 26FB:             loop_adrh1	.ds HSFX_CHANNELCOUNT
   87                   
   88 26FF:             shift_flag	.ds HSFX_CHANNELCOUNT
   89                   
   90 2703:             clock_temp	.ds HSFX_CHANNELCOUNT	;something wrong here
   91 2707:             preload_temp	.ds HSFX_CHANNELCOUNT
   92 270B:             data_temp	.ds HSFX_CHANNELCOUNT
   93 270F:             shift_temp	.ds HSFX_CHANNELCOUNT
   94 2713:             integrate	.ds HSFX_CHANNELCOUNT
   95                   
   96 2717:             hsfx_basel	.ds HSFX_CHANNELCOUNT	;pointers to data tab
   97 271B:             hsfx_baseh	.ds HSFX_CHANNELCOUNT
   98                   
   99 271F:             launch_channel	.ds HSFX_CHANNELCOUNT	;for out of phase
  100                   
  101                   
  102 2723:             HSFXVarEnd
  103                   
    5                   ; buffers
    6                   ; interrupt vector table
    7 2723:             MyIntTable		.ds 16
    8                   
    9                   ; color palette buffers
   10 2733:             new.colors.rgb
   11 2733:             new.colors.g		.ds 16
   12 2743:             new.colors.br		.ds 16
   13                   
   14 2753:             old.colors.rgb
   15 2753:             old.colors.g		.ds 16
   16 2763:             old.colors.br		.ds 16
   17      FALSE        	#ifdef MULTIPLAYER
   19                   	#endif
   20                   
   21                   ; screen buffers
Epyx HandyAsm 1.12      single                          16-Apr-12507:11:20 Page   93
                        sys.var                         07:11:20  

   22      E018         Buffer1	.eq {$ffff-{DISPLAY_BUFSIZE+4}}&$fffc
   23      C034         Buffer2	.eq {Buffer1-{DISPLAY_BUFSIZE+4}}&$fffc
   24                   
  719                   
  720                   
  721                   
  722                   ;-----------------------------------------------------
  723                   ; game variables/buffers (use the .ds command only)
  724 2773:             my.buffer	.ds 1000
  725                   
  726                   
  727                   ;-----------------------------------------------------
  728                   
  729                   
  730      94D9         len.free	.eq Buffer2-* ;number of bytes unused RAM for
  731                   
  732 2B5B:             	.or $200
  733                   
  734                   
  735                   ;-----------------------------------------------------
  736                   ; more game variables/buffers (use the .ds command onl
  737                   ; there is room for 512 bytes here
  738 0200:             my.small.buffer	.ds 512
  739                   
  740                   
  741                   ;-----------------------------------------------------
  742                   
  743                   	.list on	; enable list for symbol table in list
  744                   	.en
Epyx HandyAsm 1.12      Symbols                         16-Apr-12507:11:20 Page   94
                                                        07:11:20  

$0040 ACCUMULATE                        MACRO ADDMUSIC
$0100 AGD                               $0040 ALGO_3
$0F00 ALL_ACCUM                         $0200 ASD
$0000 ASM.EQUSYMS                       $010C ASM.VERSION
$FD40 ATTENREG0                         $FD41 ATTENREG1
$FD42 ATTENREG2                         $FD43 ATTENREG3
$FD86 AUDIN                             $0010 AUDIN_BIT
$FD20 AUDIO0                            $FD28 AUDIO1
$FD30 AUDIO2                            $FD38 AUDIO3
$0006 AUDIO_CLOCK_MASK                  $0001 AUDIO_DISABLE
$0040 AUDIO_PRELOAD                     $0006 AUDIO_TIMER
$0000 AUD_1                             $0004 AUD_16
$0001 AUD_2                             $0005 AUD_32
$0002 AUD_4                             $0006 AUD_64
$0003 AUD_8                             $0004 AUD_BACKUP
$0007 AUD_CLOCK_MASK                    $0005 AUD_CONTROL
$0006 AUD_COUNTER                       $0001 AUD_FEEDBACK
$0007 AUD_LINKING                       $0007 AUD_OTHER
$0002 AUD_OUTPUT                        $0003 AUD_SHIFT
$0000 AUD_VOLCNTRL                      $0001 A_BUTTON
$0000 A_OFFSET                          $0EA5 AddMusic
$0000 BACKGROUND_SPRITE                 $0001 BACKNONCOLL_SPRITE
$0000 BACK_SHADOW_SPRITE                MACRO BEGIN_ALLOCATE_ZEROPAGE
MACRO BEGIN_ZPAGE                       $00C0 BITS_MASK
$FDB0 BLUERED0                          $FDB1 BLUERED1
$FDB2 BLUERED2                          $FDB3 BLUERED3
$FDB4 BLUERED4                          $FDB5 BLUERED5
$FDB6 BLUERED6                          $FDB7 BLUERED7
$FDB8 BLUERED8                          $FDB9 BLUERED9
$FDBA BLUEREDA                          $FDBB BLUEREDB
$FDBC BLUEREDC                          $FDBD BLUEREDD
$FDBE BLUEREDE                          $FDBF BLUEREDF
$0002 BORROW_IN                         $0001 BORROW_OUT
$0003 BOUNDARY_SPRITE                   $0015 BREAK_CONTROLS
$0002 BSHADOW_SPRITE                    $0013 BUS_MONITOR
$0001 BUTTON_A                          $0002 BUTTON_B
$0002 B_BUTTON                          $E018 Buffer1
$C034 Buffer2                           $0002 CART0_IO_INACTIVE
$0004 CART1_IO_INACTIVE                 $0002 CART_ADDR_DATA
$0001 CART_ADDR_STROBE                  $0002 CART_POWER_OFF
$0001 CHEAP_PAUSED                      MACRO CLEARACCUM
MACRO CLEARUSER                         $FC0F COLLADRH
$FC0E COLLADRL                          $FC0B COLLBASH
$FC0A COLLBASL                          $FC25 COLLOFFH
$FC24 COLLOFFL                          $0080 COMMAND
$0003 CONTINUE_REQUEST                  $FD91 CPUSLEEP
$FFFE CPU_IRQ                           $FFFA CPU_NMI
$FFFC CPU_RESET                         $14EE CartDirectory
$14EC CartIOCount                       $14EA CartOffsetHigh
$14E9 CartOffsetLow                     $14EB CartPage
$268A ChannelInUse                      $0002 DATA
MACRO DBUF_DISPLAY                      $0003 DEBOUNCE
$FD95 DISPADRH                          $FD94 DISPADRL
$FD92 DISPCTL                           $0B8C DISPCTL_RAM
MACRO DISPLAY                           $14CB DISPLAY.003B
$14D1 DISPLAY.003B2                     $1FE0 DISPLAY_BUFSIZE
$0080 DISPLAY_EOFFLAG                   $0040 DISPLAY_EOLFLAG
MACRO DISP_AX                           MACRO DISP_AY
Epyx HandyAsm 1.12      Symbols                         16-Apr-12507:11:20 Page   95
                                                        07:11:20  

$0008 DISP_COLOR                        $0002 DISP_FLIP
$0004 DISP_FOURBIT                      $0001 DMA_ENABLE
$0001 DOWNLOAD_REQUEST                  $0001 DRAW_LEFT
$0002 DRAW_UP                           $0008 DURATION
$0B91 DisplayBuffer                     $0B94 DisplayFlags
$148D DisplayFrameCount                 MACRO ECHO_VALUE
$0008 ENABLE_COUNT                      $0080 ENABLE_INT
$0020 ENABLE_INTEGRATE                  $0010 ENABLE_RELOAD
MACRO END_ALLOCATE_ZEROPAGE             MACRO END_DISABLE
$0001 END_OF_EFFECT                     $0000 END_OF_FILE
$0001 END_OF_VOICE                      MACRO END_ZPAGE
$0001 EOF_USER                          $0002 ESCAPE
$0004 EVER_ON                           $0040 EXPAND_CFW
$0001 EXTERNAL_POWER                    $0200 FBACK_ACCUM
$0020 FBACK_INTERP                      $0080 FEEDBACK_7
$0011 FILL_MEM                          MACRO FLIP
$0004 FLIP_BUTTON                       $00C0 FOUR_PER_PIXEL
$0001 FRAMECOUNT_UP                     $0004 FRAMERR
$0004 FRAME_RATE                        $0800 FREQ_ACCUM
$0080 FREQ_INTERP                       $14A5 FrameEnd
$14E6 FrameEndExit                      $0C0B FreeAudio
MACRO GETDIR                            MACRO GETDIRFAST
$0001 GETDIR_USER                       MACRO GETJOY
MACRO GETSWITCH                         $0005 GO_REQUEST
$FDA0 GREEN0                            $FDA1 GREEN1
$FDA2 GREEN2                            $FDA3 GREEN3
$FDA4 GREEN4                            $FDA5 GREEN5
$FDA6 GREEN6                            $FDA7 GREEN7
$FDA8 GREEN8                            $FDA9 GREEN9
$FDAA GREENA                            $FDAB GREENB
$FDAC GREENC                            $FDAD GREEND
$FDAE GREENE                            $FDAF GREENF
$15D7 GetDirAddress                     $0001 HANDYIO
$0000 HANDYMATH                         $0001 HANDYMUSIC
$FC00 HARDWARE_START                    MACRO HBRK
$FD00 HCOUNT                            $0020 HFLIP
$0007 HIDE_HOWARD_REQUEST               $0004 HMUSIC_CHANNELCOUNT
$0064 HMUSIC_DEFAULT_PRIORITY           $0004 HMUSIC_USERCOUNT
$2685 HMusicVarEnd                      $25F4 HMusicVarStart
MACRO HOFF16                            MACRO HOFF8
$FC05 HOFFH                             $FC04 HOFFL
$0001 HORIZONTAL_INT                    $0016 HOWARD_ABUS
$0017 HOWARD_BBUS                       $0018 HOWARD_CBUS
$0019 HOWARD_DBUS                       $FCC4 HOWIE
$FC15 HPOSSTRTH                         $FC14 HPOSSTRTL
$2723 HSFXVarEnd                        $2685 HSFXVarStart
$0004 HSFX_ACCUMCOUNT                   $00FE HSFX_BIGPRIORITY
$0004 HSFX_CHANNELCOUNT                 $0000 HSFX_FREECHANNEL
$0001 HSFX_LILPRIORITY                  $00FF HSFX_NOCHANNEL
$0008 HSFX_REGCOUNT                     $0002 HSFX_REGSIZE
$FC29 HSIZOFFH                          $FC28 HSIZOFFL
MACRO INITEOF                           MACRO INITHMUSIC
MACRO INITHSFX                          MACRO INITINT
$045D INITINT.0006                      MACRO INITSUZY
MACRO INITSYS                           $0002 INNER_BUTTON
$0008 INTEGRATE                         $00B0 INTERP
$FD80 INTRST                            $FD81 INTSET
$0B93 INTSET_RAM                        $FD8B IODAT
$0B8D IODAT_RAM                         $FD8A IODIR
Epyx HandyAsm 1.12      Symbols                         16-Apr-12507:11:20 Page   96
                                                        07:11:20  

$0B8E IODIR_RAM                         $FCC3 IOData
$FCC2 IOStatus                          $148E InitEOF
$0E67 InitHMusic                        $0B95 InitHSFX
$1484 IntReturn                         $FBF0 IntTable
$FCB0 JOYSTICK                          $0080 JOY_DOWN
$0010 JOY_LEFT                          $0020 JOY_RIGHT
$0040 JOY_UP                            $0012 LARGE_DATA
$0004 LAST_CLOCK                        $FCC0 LEDS
$0010 LEFT0_SELECT                      $0020 LEFT1_SELECT
$0040 LEFT2_SELECT                      $0080 LEFT3_SELECT
$0008 LEFTHAND                          $0008 LEFTHANDED
$00F0 LEFT_ATTENMASK                    $0080 LITERAL
$8000 LOOP0                             $2000 LOOP1
$FFF9 MAPCTL                            $FC55 MATHA
$FC54 MATHB                             $FC53 MATHC
$0020 MATHCARRY                         $FC52 MATHD
$FC63 MATHE                             $FC62 MATHF
$FC61 MATHG                             $FC60 MATHH
$FC6F MATHJ                             $FC6E MATHK
$FC6D MATHL                             $FC6C MATHM
$FC57 MATHN                             $FC56 MATHP
$0040 MATHWARNING                       $0080 MATHWORKING
$FD88 MIKEYHREV                         $FD89 MIKEYSREV
$FD00 MIKEY_BASE                        $0002 MIKEY_SPACE
$0010 MONITOR_BYTECOUNT                 $0001 MONITOR_I
$F900 MONITOR_RAM_RESERVED              $00F8 MONITOR_ZP_RESERVED
$FD44 MPAN                              $0020 MSFX
$FD50 MSTEREO                           $FD9C MTEST0
$FD9D MTEST1                            $FD9E MTEST2
MACRO MUTE                              $0001 MUTE_USER
$0F6C Mute                              $2684 Mute_flag
$2723 MyIntTable                        $05C7 MyReturn
$4000 NEXT0                             $1000 NEXT1
$0031 NEXTZPG                           $0004 NOEXP
$0005 NONCOLL_SPRITE                    $0000 NOP_REQUEST
$0004 NORMAL_SPRITE                     $0020 NO_COLLIDE
$0000 ONE_PER_PIXEL                     MACRO OPENFILE
$0008 OPTION1_BUTTON                    $0004 OPTION2_BUTTON
$0001 ORIGIN                            $0001 OUTER_BUTTON
$0008 OVERRUN                           $14F6 OpenFile0
$0001 PARBIT                            $0010 PAREN
$0010 PARERR                            $0001 PAREVEN
$0001 PAUSE_SWITCH                      $FD93 PBKUP
$0004 PC_OFFSET                         $0004 PITCH
MACRO PLAYHSFX                          MACRO PLAYMUSIC
$0002 POWERON                           $FC2F PROCADRH
$FC2E PROCADRL                          $0006 P_OFFSET
$0E80 PlayMusic                         $FCB2 RCART_0
$FCB3 RCART_1                           MACRO READCART
MACRO READFILE                          $0010 READ_ENABLE
$0010 REGISTER                          $0007 REGISTER_BYTECOUNT
$0010 RELOAD_HV                         $0020 RELOAD_HVS
$0030 RELOAD_HVST                       $0030 RELOAD_MASK
$0000 RELOAD_NONE                       $0008 RESETERR
MACRO RESETHSFX                         $0040 RESET_DONE
MACRO RESET_TIMEOUT                     MACRO RESPRITE
$0008 RESTART_BUTTON                    $0008 RESTLESS
MACRO RESTORE_CART                      $0008 REUSE_PALETTE
MACRO RGB16                             MACRO RGB16_I
Epyx HandyAsm 1.12      Symbols                         16-Apr-12507:11:20 Page   97
                                                        07:11:20  

MACRO RGB_AXY                           $0001 RIGHT0_SELECT
$0002 RIGHT1_SELECT                     $0004 RIGHT2_SELECT
$0008 RIGHT3_SELECT                     $000F RIGHT_ATTENMASK
$0800 RING                              $001A ROM
$0004 ROMDIR_DEST                       $0008 ROMDIR_ENTRY_SIZE
$019A ROMDIR_FILE0_OFFSET               $0000 ROMDIR_FILE0_PAGE
$01A2 ROMDIR_FILE1_LOC                  $01A2 ROMDIR_FILE1_OFFSET
$0000 ROMDIR_FILE1_PAGE                 $0003 ROMDIR_FLAG
$0001 ROMDIR_OFFSET                     $0000 ROMDIR_PAGE
$0006 ROMDIR_SIZE                       $0001 ROMFILE_ALIGN
$0100 ROMPAGECOUNT                      $0400 ROMPAGESIZE
$0000 ROMSIZE                           $019A ROM_HEADER_SIZE
$00F3 ROM_SCREENBLANK_VALUE             $0004 ROM_SPACE
$0003 RUN_ADDRESS                       $0002 RXBRK
$0040 RXINTEN                           $0040 RXRDY
$1542 ReadFile0                         $0B8F RenderBuffer
$0B9F ResetHSFX                         $1536 RestoreReturn
$FC2D SCBADRH                           $FC2C SCBADRL
$FC11 SCBNEXTH                          $FC10 SCBNEXTL
$0000 SCB_CTRL0                         $0001 SCB_CTRL1
$0002 SCB_CTRL2                         $0005 SCB_DATA
$0007 SCB_HPOS                          $000B SCB_HSIZE
$0003 SCB_NEXT                          $0013 SCB_PALETTE
$001B SCB_SIZEOF                        $000F SCB_STRETCH
$0011 SCB_TILT                          $0009 SCB_VPOS
$000D SCB_VSIZE                         $0003 SCORE_SIZE
$0001 SCREEN_CLEAR                      $FC23 SCVPOSH
$FC22 SCVPOSL                           $FD90 SDONEACK
$0006 SEE_HOWARD_REQUEST                $FD8C SERCTL
$FD8D SERDAT                            $FD10 SERIALRATE
$0010 SERIAL_INT                        MACRO SETCARTADDR
MACRO SETCARTPAGE                       MACRO SETCOLL
MACRO SETDBUF                           MACRO SETDISP
MACRO SETDISP_50                        MACRO SETDISP_60
MACRO SETDISP_75                        MACRO SETUSER
MACRO SET_AUDIO_CLOCK                   MACRO SET_BRK
MACRO SET_TO_READ_CART                  $264B SFX_to_cancel
$0007 SHADOW_SPRITE                     $0400 SHIFT_ACCUM
$0004 SHIFT_ALWAYS                      $0040 SHIFT_INTERP
$0080 SIGNMATH                          $0004 SKIP_SPRITE
$0004 SLAVE_REQUEST                     $0070 SONG_DURATIONBITS
$0008 SONG_MAINVOICES                   $000F SONG_PITCHBITS
$0000 SONG_STARTUPVOICE0                $0002 SONG_STARTUPVOICE1
$0004 SONG_STARTUPVOICE2                $0006 SONG_STARTUPVOICE3
$0009 SONG_VOICEFX_OFFSETS              $FC82 SPRCOLL
$FC80 SPRCTL0                           $FC81 SPRCTL1
$FC13 SPRDLINEH                         $FC12 SPRDLINEL
$FC21 SPRDOFFH                          $FC20 SPRDOFFL
$FC91 SPRGO                             $FC19 SPRHSIZH
$FC18 SPRHSIZL                          $FC83 SPRINIT
MACRO SPRITES                           $0002 SPRITESTOP
$0002 SPRITETOSTOP                      $0001 SPRITEWORKING
$0001 SPRITE_GO                         $FC92 SPRSYS
$0B8B SPRSYS_RAM                        $FC1B SPRVSIZH
$FC1A SPRVSIZL                          MACRO STARTVOICE
MACRO START_DISABLE                     MACRO STOPMUSIC
$0001 STOPMUSIC_USER                    MACRO STOPVOICE
$FC1D STRETCHH                          $FC1C STRETCHL
$FC90 SUZYBUSEN                         $FC88 SUZYHREV
Epyx HandyAsm 1.12      Symbols                         16-Apr-12507:11:20 Page   98
                                                        07:11:20  

$FC89 SUZYSREV                          $FC00 SUZY_BASE
$0001 SUZY_SPACE                        $FCB1 SWITCHES
$FD87 SYSCTL1                           $0003 S_OFFSET
$1517 SetCartAddress                    $1523 SetCartOffset
$15B0 SetCartPage                       $0BB3 StartHSFX
$0BF0 StopHSFX                          $0F41 StopMusic
$15F7 TEMPORG                           $0001 TESTCART2_FILE
$0000 TESTCART_FILE                     $0002 TEST_1_FILE
$0003 TEST_2_FILE                       $0004 TEST_3_FILE
$0005 TEST_4_FILE                       $0080 THREE_PER_PIXEL
$FC03 TILTACUMH                         $FC02 TILTACUML
$FC1F TILTH                             $FC1E TILTL
MACRO TIMEOUT                           $FD00 TIMER0
$0001 TIMER0_INT                        $FD04 TIMER1
$0002 TIMER1_INT                        $FD08 TIMER2
$0004 TIMER2_INT                        $FD0C TIMER3
$0008 TIMER3_INT                        $FD10 TIMER4
$FD14 TIMER5                            $0020 TIMER5_INT
$FD18 TIMER6                            $0040 TIMER6_INT
$FD1C TIMER7                            $0080 TIMER7_INT
$0008 TIMER_DONE                        $0000 TIM_BACKUP
$0001 TIM_CONTROLA                      $0003 TIM_CONTROLB
$0002 TIM_COUNT                         $FC01 TMPADRH
$FC00 TMPADRL                           $0014 TRACE
$0080 TURBO_DISABLE                     $0040 TWO_PER_PIXEL
$0002 TXBRK                             $0020 TXEMPTY
$0080 TXINTEN                           $0004 TXOPEN
$0080 TXRDY                             $0004 UNSAFEACCESS
$0004 UNSAFEACCESSRST                   $0002 UPLOAD_REQUEST
$0002 UP_CURRENT_PAGE                   $0005 UP_HAHDATA
$0004 UP_MEMWATCH                       $0003 UP_REGISTERS
$0001 UP_THIS_PAGE                      $0010 USER
$146E UserIntHandler                    $FD08 VCOUNT
$0008 VECTOR_SPACE                      $0004 VERTICAL_INT
$0010 VFLIP                             $FC0D VIDADRH
$FC0C VIDADRL                           $FC09 VIDBASH
$FC08 VIDBASL                           MACRO VOFF16
MACRO VOFF8                             $FC07 VOFFH
$FC06 VOFFL                             $0100 VOL_ACCUM
$0010 VOL_INTERP                        $FC17 VPOSSTRTH
$FC16 VPOSSTRTL                         $FC27 VSIZACUMH
$FC26 VSIZACUML                         $FC2B VSIZOFFH
$FC2A VSIZOFFL                          $0010 VSTRETCH
$0010 VSTRETCHING                       $2680 VoiceHSFXChannel
$25F4 VoiceInUse                        $25F9 VoiceInstance
MACRO WAITEOF                           MACRO WAITEOL
MACRO WAITMATH                          MACRO WAITNEOF
MACRO WAITNEOL                          MACRO WAITSUZY
$0514 WAITSUZY.000F1                    $0553 WAITSUZY.00111
$073D WAITSUZY.001F1                    $08F3 WAITSUZY.00271
$0006 XOR_SHADOW_SPRITE                 $0006 XOR_SPRITE
$0001 X_OFFSET                          $0002 Y_OFFSET
$0B56 add.big.score                     $0B54 add.score
$0B5E add.score.1                       $0EAB addMusicEntry
$0CBF advance_channels                  $20F0 all.black
$1198 asd_agd_considered                $1398 attackframe_v0
$13CE attackframe_v1                    $1404 attackframe_v2
$143A attackframe_v3                    $139C attackfreq_v0
$2687 audio_dropout                     $2685 audio_interruptus
Epyx HandyAsm 1.12      Symbols                         16-Apr-12507:11:20 Page   99
                                                        07:11:20  

$2686 audio_lockout                     $0E63 audio_offsets
$001E audio_ptr                         $0B8B beg.sys
$0002 big.bang                          $21CD big.bang.fxdata
$0B77 black                             $0B72 black.Data
$0000 black.pal                         $07E0 black.screen
$248B blob                              $2419 blob.Data
$000A boggle                            $22BB boggle.fxdata
$0004 boing                             $2209 boing.fxdata
$0E0A calc_next_audio                   $05E4 check.controls
$05E1 check.controls.pause.loop         $05E7 check.controls.player.loop
$06B3 clear.paused                      $08CC clear.score.nib
$0529 clear.screen                      $138B clear_voice
$1396 clear_voice_end                   $2703 clock_temp
$0400 cold.start                        $20EA color.pnts
$05CC continue.delay                    $0018 control.edge
$0017 control.level                     $000C count
$26E3 current_frameh                    $26DF current_framel
$270B data_temp                         $13AA decayframe_v0
$13E0 decayframe_v1                     $1416 decayframe_v2
$144C decayframe_v3                     $05C8 delay
$2650 did_innernext                     $264F did_outernext
$2651 did_ring_end                      $0008 dig.wid
$064E do.flip                           $0771 do.reset
$057C do.screen                         $04FE do.sprite
$10A6 do_CFW                            $12B9 do_note
$0882 done.fade                         $0B6D done.score
$0B6F done.score.1                      $11FF dur_tbl_considered
$0023 duration_ptr                      $001A edge
$227B elevator.fxdata                   $0009 elevsnd
$125D end_escape                        $0E1D end_freq
$0E07 end_of_effect                     $1293 end_voice
$13C8 endframe_v0                       $13FE endframe_v1
$1434 endframe_v2                       $146A endframe_v3
$127B escape_considered                 $25DD face
$24A2 face.Data                         $0827 fade
$083C fade.1                            $080C fade.to.black
$0883 fader                             $0891 fader.1
$0894 fader.2                           $0012 fading
$26C3 feed_interph                      $26BF feed_interpl
$26A3 feedbackh                         $269F feedbackl
$0C16 find_lesser_channel               $10D3 first_RING
$26D3 flagsh                            $26CF flagsl
$2635 frames_aliveh                     $2631 frames_alivel
$0C2D freeChannelX                      $26B3 freq_interph
$26AF freq_interpl                      $1219 freq_tbl_considered
$2693 freqh                             $268F freql
$0021 frequency_ptr                     $04EC game.frame
$15F7 game.start                        $2625 gateh
$2621 gatel                             $2643 gating
$0666 get.controls                      $105B getNextData
$000D giggle                            $23A3 giggle.fxdata
$0006 gulp                              $229B gulp.fxdata
$1470 hardInt                           $2642 hmflagsh
$2641 hmflagsl                          $267E hmusic_base
$0F8C hmusic_driver                     $0FA3 hmusic_interrupt_core
$000F hscroll                           $0001 hsfxSysCancel
$271B hsfx_baseh                        $2717 hsfx_basel
$0C46 hsfx_driver_grunt                 $0020 hsfx_temp
$0D3E infinite0                         $0D7C infinite1
Epyx HandyAsm 1.12      Symbols                         16-Apr-12507:11:20 Page  100
                                                        07:11:20  

$25F8 instance                          $2713 integrate
$1487 jumpIntTable                      $0C2F killChannelX
$271F launch_channel                    $0CA0 launch_channels
$0CA3 launch_next_channel               $2245 laz.fxdata
$0007 lazsnd                            $94D9 len.free
$0A6C len.sys                           $0019 level
$161C loop                              $26EF loop_adrh0
$26FB loop_adrh1                        $26EB loop_adrl0
$26F7 loop_adrl1                        $26E7 loop_count0
$26F3 loop_count1                       $0D0F loop_frame
$0001 mid.bang                          $21A5 mid.bang.fxdata
$1166 mloop0_considered                 $1182 mloop1_considered
$265A mloop_adrh0                       $2666 mloop_adrh1
$2656 mloop_adrl0                       $2662 mloop_adrl1
$2652 mloop_count0                      $265E mloop_count1
$1095 mloop_frame                       $1147 mnext0_done
$1124 mnext1_done                       $25F4 most.variables
$11DD msfx_considered                   $1165 mstuff0
$1181 mstuff1                           $0F40 musicReturn
$0F5F muteVoiceX                        $000E my.bang
$23F7 my.bang.fxdata                    $2773 my.buffer
$0200 my.small.buffer                   $0027 my.var1
$0B15 nada.data                         $0011 new.colors
$2743 new.colors.br                     $2733 new.colors.g
$2733 new.colors.rgb                    $10E0 new_RING
$2647 new_note                          $0D4F next0_done
$0D8E next1_done                        $26DB next_keyframeh
$26D7 next_keyframel                    $05C7 no.screen
$0D66 no_loop0                          $0DA5 no_loop1
$0001 normal.pal                        $00FF num
$0B24 num.tab.hi                        $0B19 num.tab.lo
$0926 num0.data                         $095C num1.data
$098B num2.data                         $09BB num3.data
$09EC num4.data                         $0A1F num5.data
$0A4D num6.data                         $0A7E num7.data
$0AAF num8.data                         $0AE3 num9.data
$2763 old.colors.br                     $2753 old.colors.g
$2753 old.colors.rgb                    $001C opt2.timer
$2110 pal1                              $2130 pal2
$001D pause.flag                        $076D pause.save.1
$076E pause.save.2                      $076F pause.save.3
$0770 pause.save.4                      $001B pause.timer
$07A3 paused.data                       $0792 paused.scb
$10F8 post_ring                         $2707 preload_temp
$0B3F random                            $0006 random.ndx
$155E readCart0Grunt                    $13BE releaseframe_v0
$13F4 releaseframe_v1                   $142A releaseframe_v2
$1460 releaseframe_v3                   $25FD restore_ds
$12A6 return_from_ring0                 $129E return_from_ring1
$2672 ring0_returnh                     $266E ring0_returnl
$267A ring1_returnh                     $2676 ring1_returnl
$10F9 ring_considered                   $266A ring_flag
$12AC ring_return                       $2605 save_decayh
$2601 save_decayl                       $260D save_sustainh
$2609 save_sustainl                     $0014 score
$08D0 score.nib.1                       $08D4 score.nib.2
$0911 score.scb                         $0070 scpos
$080E set.colors                        $0F0D setNewVoice
$0EF1 setUpMusicPtrs                    $2259 shield.fxdata
Epyx HandyAsm 1.12      Symbols                         16-Apr-12507:11:20 Page  101
                                                        07:11:20  

$0008 shieldsnd                         $26FF shift_flag
$26BB shift_interph                     $26B7 shift_interpl
$270F shift_temp                        $269B shifth
$2697 shiftl                            $0003 shoot
$21F5 shoot.fxdata                      $06CF show.paused
$0895 show.score                        $08B3 show.score.byte
$08AA show.score.loop                   $08C4 show.score.nib
$0013 slow.fade                         $0000 small.bang
$217D small.bang.fxdata                 $216E sound.hi
$215F sound.lo                          $2150 sound.pri
$0002 star.pal                          $0B2F start.sound
$07D7 start.tune                        $0F4B stopAllVoices
$0F56 stopVoiceX                        $0D65 stuff0
$0DA4 stuff1                            $13B4 sustainframe_v0
$13EA sustainframe_v1                   $1420 sustainframe_v2
$1456 sustainframe_v3                   $2723 sysIntTable
$0000 sysptr                            $0002 sysptr2
$0004 sysptr3                           $07F0 systemp
$1135 takeloop0                         $1112 takeloop1
$0008 tmp                               $06AB toggle.pause
$2688 top_of_loop0                      $2689 top_of_loop1
$22E3 trans.fxdata                      $000B transnd
$166D tune.1                            $0D05 update_frame
$11E5 user_considered                   $1396 voice0
$13CC voice1                            $1402 voice2
$1438 voice3                            $1021 voiceLaunchLoop
$0FA6 voiceLoop                         $101C voiceLoopEnd
$0EE8 voiceReturn                       $261D voice_dur_ptrh
$2619 voice_dur_ptrl                    $263D voice_endframeh
$2639 voice_endframel                   $2615 voice_freq_ptrh
$2611 voice_freq_ptrl                   $1387 voice_offsets
$262D voicedata_ptrh                    $2629 voicedata_ptrl
$0025 voiceoffsets_ptr                  $26CB vol_interph
$26C7 vol_interpl                       $26AB volumeh
$26A7 volumel                           $000D vscroll
$059B wait.for.more.frames              $000C whoosh
$2337 whoosh.fxdata                     $221D zap.fxdata
$0005 zapsnd                            
